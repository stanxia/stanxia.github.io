{"meta":{"title":"东篱下","subtitle":"斯坦@森","description":"技术改变世界，阅读塑造人生","author":"森","url":"https://stanxia.github.io"},"posts":[{"title":"火之意志","slug":"火之意志","date":"2022-10-27T00:54:07.000Z","updated":"2019-04-17T06:08:31.950Z","comments":false,"path":"2022/10/27/火之意志/","link":"","permalink":"https://stanxia.github.io/2022/10/27/火之意志/","excerpt":"","text":"","raw":null,"content":null,"categories":[{"name":"photo","slug":"photo","permalink":"https://stanxia.github.io/categories/photo/"}],"tags":[{"name":"photo","slug":"photo","permalink":"https://stanxia.github.io/tags/photo/"}]},{"title":"A big week for American banks","slug":"A-big-week-for-American-banks","date":"2019-04-17T14:06:36.000Z","updated":"2019-04-17T06:08:31.918Z","comments":true,"path":"2019/04/17/A-big-week-for-American-banks/","link":"","permalink":"https://stanxia.github.io/2019/04/17/A-big-week-for-American-banks/","excerpt":"","text":"Our weekly podcast on the markets, the economy and the world of business Podcasts | Apr 16th 2019 AMERICA’S LARGEST banks reported earnings this week. Bank of America’s chief executive, Brian Moynihan, tells Anne McElvoy why he is bullish about the American economy and justifies his pay package. Also, can Goldman Sachs reinvent itself in the shadow of a scandal? And Tiger Woods’s stroke of genius—for the business of golf. Simon Long hosts. Listen on: Apple Podcasts | Spotify | Google | Stitcher | TuneIn","raw":null,"content":null,"categories":[{"name":"economist","slug":"economist","permalink":"https://stanxia.github.io/categories/economist/"}],"tags":[{"name":"economist","slug":"economist","permalink":"https://stanxia.github.io/tags/economist/"}]},{"title":"","slug":"Have Arthur Miller’s plays lost their edge","date":"2019-04-17T06:08:31.918Z","updated":"2019-04-17T06:08:31.918Z","comments":true,"path":"2019/04/17/Have Arthur Miller’s plays lost their edge/","link":"","permalink":"https://stanxia.github.io/2019/04/17/Have Arthur Miller’s plays lost their edge/","excerpt":"","text":"title: Have Arthur Miller’s plays lost their edge date: 2019-04-16 23:16:48 tags: economist categories: economist The problem often lies in the staging, not the works themselves Prospero | Apr 15th 2019 ARTHUR MILLER did not aim to please his audiences. He reckoned that new ideas were a “humiliation” and an “affront” not only to people’s sensibilities but to their convictions, too. Like the ancient Greeks, Miller thought of drama as a “civic art”, a discipline that could contribute towards a state’s social and political progress. Unlike his contemporaries, he was not commercially minded. He said what no one else had the courage to, and his audiences would weep, or sit with their heads bowed. Irate patriots picketed theatres, and producers shied away from his work. Actors who appeared in his plays were shunned by their friends. Miller’s observations hold true in the 21st century, particularly about the fallacy of the American Dream. Many still think of material wealth and status as essential to happiness, as Willy Loman does in “Death of a Salesman”. “The American Clock”, which reflects on the Wall Street Crash and the Great Depression, is a reminder of the perils of short-termism. “The Price”, set 30 years later, focuses on the longer-term repercussions. In “All My Sons” Miller questions individualist thinking. “The Crucible” examines the destructive allure of ideologies. Those insights, far from alienating today’s audiences, are now Miller’s selling points. Productions of his work have increased since his death in 2005, according to Susan Abbotson, the president of the Arthur Miller Society. He has been among the ten most-performed playwrights in American theatres for the past four years. Six productions of his work are currently being staged in London, an unusually high number for any playwright other than William Shakespeare. Tickets in the West End sell for as much as £142 ($186), a sum Miller would no doubt have been uncomfortable with given his belief that theatre should be affordable. Does this popularity suggest that his plays have lost their subversive edge? Perhaps—time can dull even radical ideas. It is no longer shocking to hear that humans are doomed to repeat their mistakes. But Miller’s fashionableness also suggests that directors have stopped confronting their audiences, and have started pandering to them. A recent production at the Union Theatre of “An Enemy of the People”, Miller’s adaptation of Henrik Ibsen’s play, had an image of President Donald Trump on its poster. The action was set in a contemporary “small-town Republican” community. Mayor Stockmann, a manipulative politician, dresses in a red suit, grinning and waving to chants of “USA! USA!” Miller never assigned a political persuasion to the play’s characters—he saw himself as a mediator, showing disparate groups what they have in common—but the suggestion here was that only Republicans can succumb to populist rhetoric and misinformation. This version of “An Enemy of the People” reinforced divisions, and allowed its audience to leave feeling smug. Productions can also be too reverent of the source material. “The Price” (at Wyndham’s Theatre) strives for a historically accurate depiction of New York in the 1960s. The audience sees Gregory Solomon, a Russian-Jewish émigré, blessing his meagre lunch—a hard-boiled egg—in Hebrew. When the play was first performed in 1968, such details invited audiences to reflect on their city’s recent past, particularly the emotional fall-out from the boom and busts of the ‘20s and ‘30s. Now heightened for comic effect, they seem alien and strange. Miller wanted his plays to be relatable, not preserved in aspic—“there are museums for such activities,” he said—and so the setting must be familiar. In 2012 a production in Mumbai turned Solomon into a Muslim nonagenarian to great effect. Miller’s plays provoked because they were about the audience as much as for them. “The Crucible” (pictured, at the Yard Theatre) opens with the townspeople of Salem dressed in the same style of clothing—beanie hats, baggy t-shirts, cargo trousers—as the audience of this edgy North London theatre. They are invited to confront an uncomfortable truth: any society, no matter how educated or tolerant it believes itself to be, can submit to hysteria. Reactions ranged from brow-furrowed confusion to wide-eyed fascination. It is difficult for Miller’s plays to have the same effect today as when their themes were still unfamiliar, even taboo. Perhaps contemporary playwrights are better placed to touch modern nerves. But thoughtful stagings can continue to make audiences reflect on their own prejudices and shortcomings.","raw":null,"content":null,"categories":[],"tags":[]},{"title":"India’s enormous election, and more from our daily podcast","slug":"India’s-enormous-election,-and-more-from-our-daily-podcast-","date":"2019-04-17T01:32:52.000Z","updated":"2019-04-17T06:08:31.936Z","comments":true,"path":"2019/04/17/India’s-enormous-election,-and-more-from-our-daily-podcast-/","link":"","permalink":"https://stanxia.github.io/2019/04/17/India’s-enormous-election,-and-more-from-our-daily-podcast-/","excerpt":"","text":"Also, moderating social media and pole-dancing’s sporting ambitions Podcasts | Apr 15th 2019 THE WORLD’S largest democratic exercise is under way in India. The prime minister, Narendra Modi, looks likely to win on a divisive platform of Hindu nationalism and aggression towards Pakistan, even if those are not voters’ biggest concerns. Social-media companies are increasingly under the microscope of regulators; we take a look at the seemingly intractable problem of policing online content. And pole-dancing is trying to shed its seedy image. But can it develop into a global sport? Runtime: 21 min. Listen on: Apple Podcasts | Spotify | Google | Stitcher | TuneIn","raw":null,"content":null,"categories":[{"name":"economist","slug":"economist","permalink":"https://stanxia.github.io/categories/economist/"}],"tags":[{"name":"economist","slug":"economist","permalink":"https://stanxia.github.io/tags/economist/"}]},{"title":"Lessons of the Mueller report","slug":"Lessons of the Mueller report","date":"2019-04-17T01:16:19.000Z","updated":"2019-04-17T06:08:31.936Z","comments":true,"path":"2019/04/17/Lessons of the Mueller report/","link":"","permalink":"https://stanxia.github.io/2019/04/17/Lessons of the Mueller report/","excerpt":"","text":"Every political scandal sets a precedent for the next Mar 28th 2019 ROBERT MUELLER toiled over his report for two years, slightly longer than it took Herman Melville to write “Moby Dick”. Going by a summary provided by the attorney-general, though, the endings are the same: the whale gets away. The special counsel did not find that members of the Trump campaign conspired with the Russian government when it interfered in the 2016 election. The president is crowing. Democrats in Congress point out that Mr Mueller did not exonerate the president over obstruction of justice, which is also true. But make no mistake: this is as good an outcome as Donald Trump could have wished for. For the rest of his first term, and perhaps long into his second, he will be able to point to an exhaustive investigation and say he was right all along. The president thrives on grievance—against the media, the federal bureaucracy, or anyone he suspects of feeling superior. The outcome of the Mueller report will feed that. As a result, the silver harpoon that some Americans hoped would finish off Mr Trump may in fact strengthen him. A few lessons can be drawn from this episode. The first is not to confuse a legal process with a political one. Ever since Mr Trump won power, those Americans who could not bear the idea of him as president have dreamed of some non-political way to erase the result—of a jurist who could simply declare it all over. Mr Mueller seemed the likeliest candidate for this role, just as Kenneth Starr did in the campaign to remove Bill Clinton. In fact the fate of Mr Trump’s presidency will depend on politics, probably through the ballot box in 2020. Even those Democrats who cling to the fantasy of using Congress to impeach and remove him need to understand just how political this process would be. The fevered speculation during the two years of the Mueller investigation has often masked that. The other lesson Democrats should heed is to keep quiet about a legal process until it is over. That is worth bearing in mind as House committees under Democratic control pursue their own investigations, and courts and prosecutors look into allegations about Mr Trump and his family. Some of his opponents have prejudged these investigations. If it turns out that he did not commit the crimes they expect, they risk not just having distracted voters from the real agenda, but also giving him a boost. They should not make the same mistake twice. The Mueller investigation also holds lessons for those Republicans emboldened to seek vengeance for what they say was treason against their president. Thanks to Mr Mueller, the president’s campaign manager and personal lawyer are both heading to prison. His national security adviser pleaded guilty to lying to the FBI about his conversations with the Russian ambassador. Since Watergate, nothing like this has happened in American politics. By revealing duplicitous and corrupt behaviour among Mr Trump’s team, and by bringing prosecutions, Mr Mueller has helped cleanse political campaigning. The investigation also revealed that the president misled voters about his business interests in Russia. While the candidate was rewriting orthodox Republican Party policy towards Vladimir Putin, his company was trying to build a skyscraper in Moscow. His retrospective justification was that he might have lost the election, in which case it would have been a shame to give up on a deal. This conflict of interest did not amount to criminal collusion or conspiracy, in the special counsel’s view. It is nevertheless the sort of transgression that America’s political system would not have tolerated before Mr Trump came along. There is a last reason to be thankful to Mr Mueller. Each time America’s political system goes through an upheaval, it sets a precedent for how its institutions will handle the next one. Mr Mueller’s conduct was exemplary. If widespread misconduct once again occurs in an American presidential election, the expectation will be that a special counsel will investigate. Though Mr Trump repeatedly denounced the investigation as a witch-hunt, he did not fire the witch-finder. Mr Mueller was able to finish his work. For that, at least, Mr Trump deserves credit.","raw":null,"content":null,"categories":[{"name":"economist","slug":"economist","permalink":"https://stanxia.github.io/categories/economist/"}],"tags":[{"name":"economist","slug":"economist","permalink":"https://stanxia.github.io/tags/economist/"}]},{"title":"America must stop Binyamin Netanyahu from annexing Palestinian land","slug":"America must stop Binyamin Netanyahu from annexing Palestinian land","date":"2019-04-17T00:18:03.000Z","updated":"2019-04-17T06:08:31.918Z","comments":true,"path":"2019/04/17/America must stop Binyamin Netanyahu from annexing Palestinian land/","link":"","permalink":"https://stanxia.github.io/2019/04/17/America must stop Binyamin Netanyahu from annexing Palestinian land/","excerpt":"","text":"Some of his election pledges would kill the chance of a two-state solution Apr 11th 2019 MAKE IT OFFICIAL: henceforth, the Hebrew word for magician is Bibi. This is not just because Binyamin Netanyahu, Israel’s prime minister, appears to have won a record fifth term in office on April 9th. It is also because he pulled off the trick with corruption charges hanging over him, and in the face of a tough challenge from a new party packed with generals. Bibi, as he is known, made some parties vanish by taking their supporters, and conjured more seats for his own Likud party. He may soon surpass David Ben-Gurion, the country’s founding father, as Israel’s longest-serving leader (see article). His victory has come at a cost. His potion—mixing muscular nationalism with Jewish chauvinism and anti-elitism—has helped poison Israel’s politics. He claims he is innocent, blaming the charges against him on shadowy plots and sowing distrust of institutions: the police, the judiciary and the media. Mr Netanyahu may do yet more lasting damage. In the final days of the campaign he vowed to annex parts of the West Bank beyond Jerusalem, something no previous leader has thought prudent. This risks killing any chance of peace based on a two-state solution—which involves the creation of a Palestinian state—and of thus turning Israel into a rogue nation. Fear not, say the optimists: Mr Netanyahu was just throwing out sweets to win over right-wing voters; he knows full well that annexation of the occupied territories would breach international law, cause an outcry in Europe and alienate Arab states that have been moving closer to Israel. The problem with this view is that it ignores the changing political and strategic landscape. Mr Netanyahu must still form a government, which means making concessions to his likely allies on the right, who feel more strongly about annexation than he does. The prime minister’s legal troubles—he faces indictment on three cases of alleged corruption—leave him vulnerable. What will be the price when the Knesset considers a bill that would shield him from prosecution? If it is annexation, the process may begin with Maale Adumim, a large settlement on the outskirts of Jerusalem which the prime minister specifically promised to bring under Israeli sovereignty. But as Mr Netanyahu himself has said, it is unlikely to end there. America’s role has changed, too. For decades its presidents acted as a counterweight to Israeli annexationists (and gave cover to prime ministers fearful of standing up to them). President Donald Trump, though, has taken America’s finger off the scales. He has emboldened the right by recognising Israel’s annexation of the Golan Heights, which it captured from Syria in 1967, and moving the embassy to Jerusalem, a contested city. Mr Netanyahu made good use of these moves in his campaign. Even if he does not feel the need to go further by formally annexing territory, there is nothing to stop the creeping sort: the expansion of Jewish settlements and their infrastructure. That is happening with barely a peep from the world, let alone the divided Palestinians. The Trump administration says it is about to release a plan for the “ultimate deal” between Israelis and Palestinians. If this is to have any hope of success, or even of starting a process, the president must rule out unilateral annexation—whether or not the Palestinians participate. If Israelis can grab land at a whim, they will have little incentive to negotiate. If Palestinians see parts of their future state taken away willy-nilly, neither will they. In the end, Israel faces a stark choice. Jews and Arabs count roughly equal numbers between the Mediterranean and the Jordan river. So Israel cannot permanently hold on to all the land without sacrificing either its Jewish majority or the ideal of a proper democracy that does not discriminate against Arabs. The more Mr Netanyahu abandons land-for-peace, the more the choice will be annexation-for-apartheid. That dilemma is something even Bibi cannot conjure away.","raw":null,"content":null,"categories":[{"name":"economist","slug":"economist","permalink":"https://stanxia.github.io/categories/economist/"}],"tags":[{"name":"economist","slug":"economist","permalink":"https://stanxia.github.io/tags/economist/"}]},{"title":"“Fosse/Verdon” is a compelling examination of a creative partnership","slug":"“Fosse-Verdon” is a compelling examination of a creative partnership","date":"2019-04-16T23:54:24.000Z","updated":"2019-04-17T06:08:31.950Z","comments":true,"path":"2019/04/16/“Fosse-Verdon” is a compelling examination of a creative partnership/","link":"","permalink":"https://stanxia.github.io/2019/04/16/“Fosse-Verdon” is a compelling examination of a creative partnership/","excerpt":"","text":"Bob Fosse and Gwen Verdon were integral to some of the 20th century’s biggest musicals Prospero | Apr 16th 2019 “FOSSE/VERDON”, a new mini-series about two Broadway legends, could have been a simple paean to the magic of the stage. Bob Fosse (Sam Rockwell), a director, and his wife Gwen Verdon (Michelle Williams), a dancer, helped to create hits such as “Damn Yankees!”, “Chicago” and “Cabaret”. There is plenty of exquisite choreography, as legs kick in perfect time and dazzling costumes shimmer on twisting bodies, plus a sparkling rendition of “Big Spender”. Elsewhere, in a fantasy scene, Fosse twirls effortlessly down a corridor, surrounded by colourful dancers. But the show turns out to be a surprisingly moving examination of the characters of Fosse and Verdon, as well as their extraordinary careers. It opens with the build-up to “Cabaret”, Fosse’s best-known film, which he directed and choreographed in 1971. The viewer is transported from Hollywood to damp, dark Munich, where it was shot, and the pressure is palpable. The film cannot afford to be “another $20m fiasco”, a producer warns, referring to one of Fosse’s previous misses. Fosse, in turn, takes it out on his crew. “I wanna see every muscle, every tendon,” he barks during exhausting rehearsals for “Mein Herr”, one of the nightclub songs. After seeing the first cut, he moans to his assistant that “it’s unwatchable”. On the night of the premiere, he paces in the auditorium rather than watching the film (it was a box-office triumph and would go on to win eight Oscars). His personal torment, and abject terror of failure, is clear. The programme dances back and forth in time. Title cards, such as “Hollywood: 19 years left” and “Gwen Verdon: 14 years after her last Tony award”, contextualise the scenes, which range across five decades. It allows the viewer to see patterns emerge. A flashback to Fosse’s childhood dance classes, for example—“don’t show me the effort, Bobby, don’t show me the sweat. All they wanna see is that smile”—helps to explain Fosse’s treatment of his own dancers. Depictions of his career highs jar with his descent into depression and alcoholism, as well as scenes of childhood abuse. His wild lifestyle of pills, sex, parties and more pills, is juxtaposed with images of Verdon feeding their daughter dinner and arranging child care. The effect is troubling, and powerful. Mr Rockwell’s thoughtful and pained performance elicits a surprising amount of sympathy for Fosse, even as he behaves appallingly. One excruciating scene shows a lead dancer refusing his sexual advances; she is subsequently fired. But the decision to give Verdon equal billing in the production was a wise one (the series was originally adapted from “Fosse”, a biography written in 2013, but the producers realised that this would result in a narrow, uneven story). She emerges as a quiet kind of hero, helped by an elegant performance by Ms Williams. Verdon, as well as being Fosse’s long-suffering wife, was his creative collaborator. Her career peaked in the 1950s, when she won a string of Tony awards, but she gradually lost her hold over Hollywood and was eventually eclipsed by her husband. Yet when “Cabaret” hits a crisis—the endless rehearsals are ruining the shooting schedule, and the budget—it is Verdon that Fosse needs, begging her to come and join him in Germany. She sweeps in, taking charge of hair and make-up and fine-tuning the dancing. Where Fosse had used the dancers as moving props, Verdon makes them into fleshed-out characters with backstories. As such, “Fosse/Verdon” reminds viewers that great feats are rarely accomplished alone (a theme that Lin-Manuel Miranda, an executive producer of the series, touched upon in “Hamilton”, his own musical hit). Tributes to Tinseltown and Broadway, such as “La La Land”, often focus on the glamour and romanticism of it all. “Fosse/Verdon” is all the better for lifting the stage curtain to look at the people behind it. The series understands that while show business projects an image of human perfection, its masters are as flawed as they are brilliant. “Fosse/Verdon” is showing on FX in America now. It will be released in Britain on BBC Two later this year","raw":null,"content":null,"categories":[{"name":"economist","slug":"economist","permalink":"https://stanxia.github.io/categories/economist/"}],"tags":[{"name":"economist","slug":"economist","permalink":"https://stanxia.github.io/tags/economist/"}]},{"title":"Chevron is buying Anadarko for $33bn","slug":"Chevron is buying Anadarko for $33bn","date":"2019-04-16T23:16:56.000Z","updated":"2019-04-17T06:08:31.918Z","comments":true,"path":"2019/04/16/Chevron is buying Anadarko for $33bn/","link":"","permalink":"https://stanxia.github.io/2019/04/16/Chevron is buying Anadarko for $33bn/","excerpt":"","text":"The deal signals greater consolidation in the shale business Apr 13th 2019 IN RECENT MONTHS a question has been hanging over the plains of Texas: what would be the next big shale deal? The logic for consolidation seemed clear. Texas’s Permian basin is America’s most productive oilfield, despite a patchwork of plots with hundreds of owners. Shale companies looked cheap, with investors sceptical about firms’ ability to produce both oil and profits. On April 12th the curious got their answer. Chevron, a giant oil company, will pay $33bn in cash and shares to buy Anadarko, an independent producer with rich holdings in the Permian. It will also assume Anadarko’s $16bn debt. The deal transforms Chevron into the world’s second-biggest publicly traded oil-producer, behind only ExxonMobil. It is the latest sign of shale’s growing importance to the world’s biggest energy firms. Oil majors have arrived relatively late to fracking. Small, independent companies were first to set about coaxing oil from shale. They developed ways to drill not just down but horizontally, then assault shale with water and sand until the rock gave up its hydrocarbon riches. But the industry titans have warmed to the idea. Unlike, say, a complex deepwater project in a distant jurisdiction, shale offers quick drilling times, predictable cashflow and favourable American regulation. Smaller companies have often fracked frenetically, eager to reinvest proceeds and chase growth. Too frenetically at times; some took on more debt than they could handle. Giant companies have less experience with the technique. But their diversified revenue and larger balance-sheets allow them to accumulate acreage even as they drill at a more measured pace. Last year BP, a British firm, paid $10.5bn to acquire the shale assets of BHP, a giant miner. ExxonMobil and Chevron have placed the biggest bets. Chevron’s shale holdings were vast even before the Anadarko deal. The company controlled 1.7m acres (690,000 hectares) in two of the Permian’s most productive regions. In March ExxonMobil said it expects production in the Permian to exceed 1m barrels a day within five years. With Anadarko, Chevron’s Permian production may be 60% higher than ExxonMobil’s, according to Rystad Energy, a research firm. Anadarko gives Chevron more than just shale. Its assets include a liquefied-natural-gas project in Mozambique and holdings in the Gulf of Mexico. Still, Anadarko’s Permian plots would have been the main lure. With them, Chevron can drill more wells, more efficiently. Adjacent plots will let the company move farther sideways through the rock and simplify the transport of equipment and other inputs, such as the millions of gallons of water required to wrest oil from each well. Chevron reckons that the deal will bring $2bn in savings, all told. Some investors hope that, as shale companies consolidate, they will mature and their performance will improve. Independent producers may now bulk up, following the lead of Concho Resources. Last year it bought RSP Permian, a rival, for $9.5bn. Meanwhile, the supermajors’ holdings look poised to expand. ExxonMobil has said it would consider additional shale acquisitions. Royal Dutch Shell is rumoured to be weighing the purchase of Endeavor Energy, whose headquarters sit in the heart of the Permian. Not all investors are sold on the attractions of shale. Follow This, a group of them concerned about climate change, expressed disappointment that Chevron would spend $33bn on Anadarko, rather than on renewable energy. At its annual meeting next month, Chevron’s shareholders will vote on a resolution that would compel the company to disclose how it can reduce its carbon footprint in line with the Paris climate agreement. Chevron insists that it is “positioned to win in any environment”. An environmentally friendlier one may be an exception.","raw":null,"content":null,"categories":[{"name":"economist","slug":"economist","permalink":"https://stanxia.github.io/categories/economist/"}],"tags":[{"name":"economist","slug":"economist","permalink":"https://stanxia.github.io/tags/economist/"}]},{"title":"Tiger Woods wins his fifth Masters in a comeback for the ages","slug":"Tiger Woods wins his fifth Masters in a comeback for the ages","date":"2019-04-16T23:16:55.000Z","updated":"2019-04-17T06:08:31.936Z","comments":true,"path":"2019/04/16/Tiger Woods wins his fifth Masters in a comeback for the ages/","link":"","permalink":"https://stanxia.github.io/2019/04/16/Tiger Woods wins his fifth Masters in a comeback for the ages/","excerpt":"","text":"But if history is any guide, he is running out of time to beat Jack Nicklaus’s 18 major victories Game theory | Apr 15th 2019 JUST A YEAR and a half ago, the most common question about Tiger Woods’s future was not whether he would win another major tournament, but whether he would ever play competitively again. After an unprecedented run of glory in which he won 14 majors in just over 12 years, Mr Woods saw his career derailed by an infidelity scandal, injuries and over-use of prescription drugs. Already on the wrong side of 40 years old, Mr Woods’s legacy appeared to be fixed: a star that burned brighter than any other but was extinguished far too soon, a victim of the hubris caused by too much success at too young an age. That was then. On April 14th Tiger unleashed his roar once again—literally. After winning the Masters Tournament for the fifth time and a major championship for the 15th, he screamed at the top of his lungs while lofting his arms and putter high into the air, before embracing his caddy, family members and vanquished rivals as he seemed to fight back tears of joy. Much like the broader narrative of his career, it was also the first time he had come from behind to secure a major: in all of his previous victories, he had led at the start of the final round. Mr Woods’s title is not only a personal triumph, but also a welcome boon to golf as a game. Only the presence of its biggest star atop the leaderboards enables it to compete with the most popular team sports for viewership and cultural relevance. No one would confuse the play of the grizzled, 43-year old Mr Woods with that of the 21-year-old phenom who won the Masters by a record 12 strokes in 1997. Whereas the young Mr Woods was so dominant that he barely seemed to be playing the same sport as his competitors were, this version seemed all too human. He frequently sprayed drives into the trees and misfired on straightforward putts, turning birdies into pars and pars into bogeys. He trailed by four strokes after the first round, by one at the cut and by two on Sunday morning. But just as Mr Woods has learned how to deal with adversity in his personal life, so too has he mastered how to limit the cost of mistakes on the golf course. Time and again, Mr Woods found a window through trees or a path around hazards, recovering from an errant tee shot with a pinpoint approach. (His driving accuracy of 62.5% was among the worst in the tournament, while his 81% rate of reaching greens in regulation was the best.) On the par-four ninth hole on the final day, his second shot landed at the far end of a long, downward-sloping green—a predicament in which the younger Mr Woods rarely found himself, where escaping with a par would feel like an eagle. Now a wily veteran, Mr Woods uncorked a lag putt for the ages. He aimed the ball on a line far above the straight path to the hole, and barely tapped it despite the vast distance. It almost stopped short as it approached the ridge—and then veered hard towards the hole, gaining speed as it plunged downhill, before coming to rest just inches from its target. The stroke he saved after tapping in for par wound up constituting his entire margin of victory, encapsulating the story of the tournament: unlike his rivals, Mr Woods refused to beat himself. Even after that par save, Mr Woods trailed Francesco Molinari by a stroke—a deficit that doubled after he bogeyed the tenth hole. EAGLE, The Economist’s statistical win-probability model for golf tournaments, gave Mr Molinari a 65% chance of victory heading into the 12th hole, while Mr Woods languished at 16% (see chart). Just last July, Mr Molinari got the better of Mr Woods, when they were in the same playing group on the final day of the Open Championship in Scotland and Mr Molinari went on to win. This time, however, Mr Molinari succumbed to the demons that have undone so many a contender on the back nine on Sunday at Augusta National Golf Club. He left his tee shot short on the par-three 12th, seeing it disappear into the waters of Rae’s Creek, and then failed to make his putt for bogey. Mr Woods, in contrast, played it safe and made par. Three holes later, Mr Molinari saw his hopes of trying on his first Masters victor’s green jacket dashed for good. A poor drive on the par-five 15th forced Mr Molinari into an awkward approach shot, which bounced off a tree and wound up in the water as well. Mr Woods, meanwhile, displayed the steely resolve that made him an icon a decade ago. On the same hole that finished Mr Molinari, Mr Woods secured a birdie with a dead-centre drive, a meticulous approach to the green, and a clean two-putt. And on the next hole, the par-three 16th, he delighted the fans with a taste of his magic of yesteryear. His high-arcing tee shot first hit the green beyond one-putt range. But it then rolled sideways towards the hole like a heat-seeking missile, until he was assured of a tap-in birdie and a two-stroke lead. Even then, Mr Woods wound up needing stumbles from his rivals to compensate for his own. Both Dustin Johnson, who by most statistical measures is currently the best player in the world, and Brooks Koepka, who had won three of the past six majors he had entered, reached the 18th green at 12 under par with achievable, if challenging, birdie putts. Both missed—barely, in Mr Johnson’s case. That wound up making the difference in the tournament, as Mr Woods muffed both his approach shot on the 18th and his putt for par. No one dreams about winning the Masters with a bogey, but it was a fitting end to a gritty triumph. Must it be St Nicklaus? Mr Woods’s victory gives him a long-overdue 15th major title, leaving him three behind Jack Nicklaus’s all-time record of 18. Mr Nicklaus won his last at the age of 46, suggesting that Mr Woods has at least three more years to bridge the gap. Now that Mr Woods has rediscovered his form, might golf’s most treasured record now be within reach? The afterglow of Mr Woods’s win is probably not the best time to preach faith in statistical golf models. EAGLE gave him just a 2.2% chance of winning the Masters, less than half the probability implied by pricing in betting markets. Although such odds might appear uncommonly long, they were no knock on Mr Woods’s game: most major victors start the tournament with less than a one-in-20 chance. In EAGLE’s estimation, Mr Woods was playing sufficiently well before the Masters began that he was already one of the top ten players in the world. Instead, the daunting odds were merely a reflection of how much good fortune is required, in addition to elite skill, to beat a field containing all of the world’s best players over just 72 holes. Even Mr Johnson, whom the model anointed as the favourite and finished tied for second, had less than a 10% shot to win. The brutal arithmetic of large golf tournaments suggests that if Mr Woods is now a top-five player, he would be expected to win another major roughly once every 3.5 years. As a “mere” top-ten competitor, that frequency would fall to around one every six years. From this perspective, Mr Nicklaus should only feel threatened if Mr Woods manages to regain his former status as the unquestioned world number one despite his advanced age. That would mean following up this Masters victory with a steady drumbeat of scores in the 60s and finishes in the top 5 and 10 of PGA Tour events. (Mr Woods’s Masters performance alone has improved EAGLE’s estimate of his expected score on a typical course by over a tenth of a stroke per round). Otherwise, the smart money will probably remain on Mr Woods’s major-championship tally remaining at 15. However, statistical models rely on extrapolating historical patterns into the future. And since no one has ever played golf as well as Mr Woods did at his best, there is no precedent on which to train a model for the second act of such a career. As the crowds roared following his every birdie and his rivals’ every misstep, distracting players two or three holes away, a victory that was still statistically improbable already felt inevitable in the heart of every fan who had seen Mr Woods in his heyday. Much to the delight of the lords of golf, even the most casual of observers will make sure to tune in the next time Mr Woods strides to the tee box with a major on the line.","raw":null,"content":null,"categories":[{"name":"economist","slug":"economist","permalink":"https://stanxia.github.io/categories/economist/"}],"tags":[{"name":"economist","slug":"economist","permalink":"https://stanxia.github.io/tags/economist/"}]},{"title":"A new era at Goldman Sachs starts in the shadow of a scandal","slug":"A new era at Goldman Sachs starts in the shadow of a scandal","date":"2019-04-16T23:16:54.000Z","updated":"2019-04-17T06:08:31.903Z","comments":true,"path":"2019/04/16/A new era at Goldman Sachs starts in the shadow of a scandal/","link":"","permalink":"https://stanxia.github.io/2019/04/16/A new era at Goldman Sachs starts in the shadow of a scandal/","excerpt":"","text":"Can the bank reinvent itself? Apr 15th 2019 NO ONE IS more aware of the value of a brand than Goldman Sachs. The investment bank, founded in 1869, has advised the biggest and best American companies on the value of theirs for the past 150 years. It helped F.W. Woolworth, a pioneering department store, with its initial public offering in 1912. It took Ford and Disney public in the 1950s, helped Amazon buy Whole Foods in 2017 and will take Uber public later this year. Yet these are troubling times for its own brand, tarnished by association with a fraud-ridden Malaysian state-run fund, 1MDB, and hurt by the bank’s failure to adapt after the global financial crisis. These issues were echoed in the firm’s first-quarter results, released on April 15th. Revenues came in below expectations—13% lower than for the first quarter of 2018—largely as the result of lower trading revenues. The share price fell more than 3% and the earnings call was peppered with analysts asking questions about 1MDB. The first task for David Solomon, who took over as chief executive last October, is to clean up Goldman’s reputation. In 2012 and 2013 it helped 1MDB raise $6.5bn across three bond offerings, earning $600m in fees—way above the norm for such work. American and Malaysian authorities have alleged that much of the money raised was stolen in a scheme masterminded by Jho Low, a Malaysian financier. He has denied wrongdoing (and vanished). Last November America’s Department of Justice (DoJ) announced that a former senior partner at Goldman, Tim Leissner, had pleaded guilty to conspiracy to launder money and to violate foreign bribery laws. And they indicted Mr Low and another former Goldman banker, Roger Ng, who has also denied wrongdoing. Goldman claims that Mr Ng and Mr Leissner, who transferred embezzled funds into his personal bank account, kept the bank in the dark about their actions. But criminal charges have been filed against the firm in Malaysia. Though Goldman is contesting the case, it is spooking shareholders, who worry about both onerous fines and what it implies about oversight at the bank. Since November its share price has under-performed an index of other bank stocks by 10.3 percentage points, suggesting that the scandal may have wiped as much as $9.1bn off its value. It is against these headwinds that Mr Solomon must try to convince investors that Goldman can reinvent itself. Its peers have already digested the fact that Wall Street’s traditional model, in which banks advise on huge corporate deals and make bold trades on their own behalf, has become less profitable. According to Michael Spellacy of Accenture, a consultancy, 90% of the economic profit made in the capital-markets industry is now earned on the buy side—that is, by those who manage assets or investments—and just 10% from sell-side investment-banking activities. A decade ago, he says, that split was closer to 50-50. Goldman’s slowness in reacting to these structural changes has allowed its competitors to catch up. In 2010 its return on equity (ROE) was 11%, easily beating the 8% average for “bulge-bracket” American investment banks, a group including JP Morgan and Morgan Stanley. But last year that group averaged an ROE of 11.2%, placing Goldman, at 12%, near the middle of the pack. And investors are becoming concerned about the way it earns its returns. Volatile profits, like those from trading businesses, mergers and acquisitions, are considered less valuable than steady fee-based income, for example from wealth management. In 2016 Mr Solomon’s predecessor, Lloyd Blankfein, took the first steps towards a new strategy by launching a consumer bank, Marcus. In 2017 Goldman announced a target of increasing yearly revenues by $5bn by 2020. But the focus on expanding consumer lending, which offers a relatively low return on investment, did not impress shareholders. They have had a rough ride. Holding shares in the firm since 2010 would have earned just 13% (without adjusting for inflation), compared with an average of 71% for its bulge-bracket peers and 152% for the S&amp;P 500. Goldman continues to trade at just 0.9 times its tangible book value, a measure of the money that might be returned to shareholders if it were liquidated. The average ratio of price to tangible book value for a bulge-bracket bank is 1.15. As far as 1MDB is concerned, the big worry for shareholders is the size and scope of the penalties. A large fine is all but inevitable. It could be based on the $600m Goldman earned from the bond issuance—or the $2.7bn American authorities say was stolen from the proceeds. That will be multiplied by anything up to four, depending on the degree to which the firm is found culpable. That Goldman is co-operating with the DoJ will bring the multiplier down; if the DoJ decides the firm’s oversight of compliance procedures was inadequate, it will be towards the higher end. Steven Chubak of Wolfe Research, an equity-research firm, thinks the total will be somewhere between $1bn and $4bn. When it comes to the required shift in strategy, however, Goldman’s efforts may soon start to bear fruit. Its expansion into consumer businesses is continuing apace. In 2018 it acquired Clarity Money, a personal-finance app. Last month Tim Cook, Apple’s chief executive, announced that it will launch a credit card with Goldman this summer. When Marcus launched it was as a consumer lender; since then it has added deposit-taking. Though it offers market-leading rates, deposits are still a cheap source of funding. In 2012 just 8% of Goldman’s funding came from deposits. Last year that share had risen to 19%. If it can keep replacing wholesale funding with deposits at the pace of the past five years, says Mr Chubak, it will have reduced funding costs by $500m by 2022. The consumer space is not the only place Goldman is rolling out new technology. More than a quarter of Goldman’s employees are now engineers, says Heather Kennedy Miner, the bank’s head of investor relations. The firm has deployed a new platform, called Marquee, for institutional investors and will expand into corporate cash management in 2020, which will further increase low-cost deposits. The firm also seems to be planning an overdue restructuring of its fixed-income, currency and commodities (FICC) business. Revenues earned from FICC have fallen from $13.6bn in 2010, accounting for more than a third of Goldman’s revenues, to $5.9bn now, or just a sixth. Last October Stephen Scherr, Goldman’s newly appointed chief financial officer, announced a review of all its business lines, which will be published early next year. In February the Wall Street Journal reported that the commodities business would be scaled back. (Mr Scherr emphasises that Goldman has no plans to abandon commodities entirely, as some of its competitors, including JP Morgan and Morgan Stanley, have.) In March Mr Solomon announced plans to cut the number of staff in sales and trading by 5% this year. Its new strategy will mean Goldman is competing on less familiar territory. Consumer deposits and corporate cash management are competitive markets that JP Morgan and Bank of America have dominated for decades. But they are also huge markets. Even a small slice could have a big impact on Goldman’s profits, says Mr Scherr. Compared with established banks, Goldman is able to develop and deploy new technology easily; but unlike startup digital competitors, its innovations are backed by a $925bn balance-sheet. America’s financial-services industry has been slow to adapt to technological change. An old bank with a new direction might be well-placed to disrupt it.","raw":null,"content":null,"categories":[{"name":"economist","slug":"economist","permalink":"https://stanxia.github.io/categories/economist/"}],"tags":[{"name":"economist","slug":"economist","permalink":"https://stanxia.github.io/tags/economist/"}]},{"title":"A terrible blaze devastates Notre Dame cathedral","slug":"A terrible blaze devastates Notre Dame cathedral","date":"2019-04-16T23:16:53.000Z","updated":"2019-04-17T06:08:31.903Z","comments":true,"path":"2019/04/16/A terrible blaze devastates Notre Dame cathedral/","link":"","permalink":"https://stanxia.github.io/2019/04/16/A terrible blaze devastates Notre Dame cathedral/","excerpt":"","text":"Stunned Parisians watch centuries of history dissolve in flames Apr 15th 2019 THEY GATHERED on the bridges over the Seine to watch in disbelief. Some Parisians were in tears; most watched in eerie silence. The devastating fire that broke out in the wood-timbered roof of the gothic cathedral of Notre Dame in the early evening of April 15th rapidly spread before their eyes, consuming the central spire and defeating the efforts of fire-fighters to bring the flames under control. President Emmanuel Macron, spoke for many across France when he tweeted that he was witnessing “part of us burn.” By midnight in Paris the worst seemed to be over. The main stone structure appeared to have been saved, and the prompt action of hundreds of fire-fighters had rescued many works of art and relics from the burning building. But as well as the medieval oak-beamed roof and the later-built spire, the damage to the interior has been immense. The 850-year-old edifice had survived war, revolution and Nazi occupation, an emblem of resistance in the face of a constantly disrupted history. It was the site of Napoleon’s coronation in 1804 and the inspiration for literary works, most famously Victor Hugo’s “The Hunchback of Notre-Dame”, and one of the city’s most iconic landmarks, visited by 13m tourists each year. Notre Dame was at once a living place of worship for the French Catholic church and the property of the French secular state: a symbol in itself of the country’s history and its present, in all its glorious contradictions. The heartbreak felt by many as they watched nine centuries of history dissolve in flames was profound. Bertrand Delanoë, the former mayor of Paris, called the cathedral a “jewel of the heritage of humanity”. Mr Macron, who had been preparing to give a televised address to the nation at the end of his “great national debate”, cancelled the speech and went straight to the site of the disaster. It will take time and a full investigation before the exact cause of the fire is established. Early reports from the Paris fire service suggested that it was not a work of arson but an accident that broke out in the central roof, where building works were underway to renovate the 19th-century spire. But already questions are being asked about disaster-planning for a monument of this scale and national importance, situated amid narrow streets on an inaccessible island in the centre of the city. The search for somebody to blame will absorb France for weeks and months to come. The public prosecutor has opened an inquiry. When shock and disbelief turns to anger, many will want to know exactly what precautions were taken by those working on the renovation, and why it was so difficult for fire-fighters to stop the blaze spreading. Five hundred were deployed, but it took them ages to get there. Some will look to Anne Hidalgo, the mayor of Paris, who tweeted that she had “no words for the pain” she felt. Others still will look to Mr Macron. The unpopular president already had his hands full dealing with the gilets jaunes (yellow jackets) protests, which have dragged on since last November. This evening was supposed to mark the moment that he reconnected with the French people, and put his reputation for haughty rule behind him. Now he has a different challenge. Paris, and all of France, is hurting. The tragic devastation of Notre Dame will touch the country for a long time—and put the head of state’s capacity to touch the French with the right words of consolation to a severe test. He made a good start last night, visiting the scene and pledging that “we will rebuild” the cathedral. It is a task that will take many, many years.","raw":null,"content":null,"categories":[{"name":"economist","slug":"economist","permalink":"https://stanxia.github.io/categories/economist/"}],"tags":[{"name":"economist","slug":"economist","permalink":"https://stanxia.github.io/tags/economist/"}]},{"title":"Right-wing populist parties are polling well in Britain","slug":"Right-wing populist parties are polling well in Britain","date":"2019-04-16T23:16:52.000Z","updated":"2019-04-17T06:08:31.936Z","comments":true,"path":"2019/04/16/Right-wing populist parties are polling well in Britain/","link":"","permalink":"https://stanxia.github.io/2019/04/16/Right-wing populist parties are polling well in Britain/","excerpt":"","text":"Recent opinion surveys show the new Brexit Party is gathering support Apr 15th 2019 BRITAIN’S NEW Brexit party has gathered support with remarkable speed. Formed in January 2019, it is already registering double-digit support in opinion polls and has nearly caught up with the UK Independence Party (UKIP), from which it split. The new party is headed by Nigel Farage, the former leader of UKIP, who successfully pushed the Conservative party to call a referendum on Britain’s membership of the European Union in 2016—and helped the Leave campaign to victory. It was a stunning achievement for what had been regarded as a fringe party, and Mr Farage announced his retirement from politics. Now he is back. Without Mr Farage, UKIP has drifted ever farther to the xenophobic far right under successive leaders. The Brexit Party, for its part, says it aims to draw support from across the political spectrum, from both Conservatives and Labour Brexiteers, to ensure that Britain leaves the EU. The referendum marked UKIP’s high point. In the general election held in 2017 it received just 1.8% of the votes, down from 12.6% in 2015. Even as it became clear that Brexit—at least as hardline Brexiteers had imagined it—was running into trouble, UKIP still polled only about 4% on average in 2018. But populist parties have regained momentum since the beginning of this year. The government lost one vote after another on its deal with the EU, and Brexit has been repeatedly delayed. The original deadline of March 29th has been pushed back to October 31st. Unless an agreement is reached soon, Britain will have to hold elections to the European Parliament next month, which will be another humiliation for Theresa May, the prime minister. Populists and hard Brexiteers accuse members of Parliament of betraying Brexit. The latest survey gives populist parties a combined vote of 21%. The Brexit Party, which Mr Farage recently described as “a virtual” party, consisting of little more than a website, is just behind UKIP on 10%. Both are ahead of the pro-Remain Liberal Democrats on 8% and not far behind the Conservatives on 14%. The contrast between the Brexit party and its mirror-image, Change UK, a new party made up of Remainers drawn from Labour and the Conservatives, is striking. Change UK barely figures in the polls despite having lots of favourable press coverage and several prominent MPs. It suffers from a serious branding problem: it faffed around with its name, does not have a leader and failed to present itself as a full-throated anti-Brexit Party. It could learn a lesson or two from the astute Mr Farage.","raw":null,"content":null,"categories":[{"name":"economist","slug":"economist","permalink":"https://stanxia.github.io/categories/economist/"}],"tags":[{"name":"economist","slug":"economist","permalink":"https://stanxia.github.io/tags/economist/"}]},{"title":"Sudan’s protesters stand firm for civilian rule","slug":"Sudan’s protesters stand firm for civilian rule","date":"2019-04-16T23:16:50.000Z","updated":"2019-04-17T06:08:31.936Z","comments":true,"path":"2019/04/16/Sudan’s protesters stand firm for civilian rule/","link":"","permalink":"https://stanxia.github.io/2019/04/16/Sudan’s protesters stand firm for civilian rule/","excerpt":"","text":"The generals have blinked and replaced one of their own Apr 15th 2019 AWAD IBN AUF was leader of Sudan for just over a day. In his brief spell as head of state the former vice-president and defence chief declared a three-month state of emergency, suspended the constitution, arrested a few senior officials and announced a curfew. “The people asked us to take over…and we did,” he said in a stony-faced televised address on April 11th, shortly after placing his boss, Omar al-Bashir, under house arrest. It looked as if four months of nationwide protests against Mr Bashir and his 30-year-old autocracy had culminated in a coup. Sudan’s demonstrators, who have been camped outside the headquarters of the armed forces in central Khartoum since April 6th, were having none of it. Though they had called on the army to side with them in order to topple Mr Bashir, who has ruled since 1989, his bloodstained deputy was far from the replacement they had in mind. Mr Auf has had sanctions placed on him by America for his role in war crimes (his former boss has been indicted by the International Criminal Court for genocide in Sudan’s Darfur region). Faced with a storm of popular outrage, the short-lived autocrat stepped down on April 12th. He was replaced by another general, Abdel-Fattah Burhan, then head of the army. Mr Burhan is said to be more popular with rank-and-file soldiers, many of whom are sympathetic to the demonstrators. Mr Burhan has so far made a better fist of the job. His speech on April 13th was less tone-deaf than that of his predecessor. He commended the revolution, particularly noting the prominent role played by women in the protests that began in December in response to rising food prices. He paid tribute to the civilians who have been killed by security forces in the past four months. More concretely, he promised to hand over power to civilians after a transition period of no more than two years. On April 13th the opposition nominated delegates to begin negotiating with a military council headed by Mr Burhan. In the first meeting the council promised to repeal all repressive laws and to oversee a predominantly civilian administration, according to the Sudanese Professionals’ Association (SPA), which organised many of the protests. Alongside this, the military council moved to weaken the power of the former tyrant. It replaced Salah Abdallah Gosh, the intelligence chief widely regarded as the second most powerful man in the country after Mr Bashir. On April 14th the military council said it had arrested members of Mr Bashir’s National Congress Party (NCP) and would begin seizing the party’s assets. It also promised to restructure Mr Gosh’s notorious intelligence agency and to allow the opposition to choose a new prime minister. But the protesters remain dissatisfied. “We can’t live on promises,” says Hamid Murtada, an activist. The SPA has called for the sit-in outside the defence ministry to continue until the “deep state” is fully dismantled. Many people are particularly worried by the appointment of Mohamed Hamdan Dagalo (known as Hemeti) as the military council’s deputy leader. A paramilitary unit he was in charge of, the Rapid Support Forces, with links to the notorious Janjaweed militia, was involved in the mass rape and butchery of civilians while battling rebels in Darfur. He and others in the junta’s top ranks are close to Saudi Arabia and the United Arab Emirates, both of which welcomed developments over the weekend. Saudi Arabia has promised aid to help ease the country’s economic woes. Whether the junta will actually relinquish power remains to be seen. “It’s very possible the military said all that just to end the sit-in,” says Mohammed Osman, an analyst in Khartoum. Indeed, on the morning of April 15th it tried again to disband the protest, this time asking demonstrators to help clear roadblocks. After a brief stand-off the soldiers retreated. “Clean up the regime and we’ll clean up the square,” shouted protesters as they departed. The generals had better put their aprons on.","raw":null,"content":null,"categories":[{"name":"economist","slug":"economist","permalink":"https://stanxia.github.io/categories/economist/"}],"tags":[{"name":"economist","slug":"economist","permalink":"https://stanxia.github.io/tags/economist/"}]},{"title":"Why British wage growth is picking up at last","slug":"Why British wage growth is picking up at last","date":"2019-04-16T23:16:47.000Z","updated":"2019-04-17T06:08:31.936Z","comments":true,"path":"2019/04/16/Why British wage growth is picking up at last/","link":"","permalink":"https://stanxia.github.io/2019/04/16/Why British wage growth is picking up at last/","excerpt":"","text":"A tight labour market, better jobs and higher productivity are rewarding workers at last Apr 16th 2019 The obvious cause of strengthening pay is the tight labour market. When unemployment hit its post-crisis high of 8.5% in 2011, employers knew that they could get away with offering meagre or no pay rises. Workers’ bargaining power has since grown, as joblessness has fallen. Unemployment is just 3.9%, the lowest in four decades. Britain has about three vacancies for each 100 employee jobs, the highest ratio since the data began in 2001, meaning bosses have to try harder to fill posts. Nominal pay in the hospitality sector, which has a particularly high number of job postings, is growing at 5% a year. A hot jobs market is not the only cause of rising average pay. Another relates to the mix of jobs in the economy. Following the financial crisis, posts in low-productivity, low-paying sectors such as agriculture proliferated. Having more poorly paid positions dragged down the average. Yet lately Britain has created relatively more high-paying jobs—strawberry-pickers have made way for stock-pickers. In the year to September 2018 the changing composition of the workforce boosted average nominal wage growth by 0.5 percentage points. Stronger pay may also owe something to rising productivity. How much workers produce ultimately determines how much they earn. After stagnating in 2007-14, more recently output per hour has grown by about 1% a year in real terms. Silvana Tenreyro of the Bank of England has floated the idea that some of these gains might not have yet shown up in the statistics. The question is whether wage growth will accelerate further. Workers will hope that it does: at its current rate real pay will not return to its pre-crisis peak until 2022. Yet few economists believe Britain will soon resume the healthy productivity growth of the post-war period, which was consistent with real-terms pay rises of some 3% a year. Most economic forecasts have productivity growing at an annual rate of about 1% this year and next. Already there are signs that firms are struggling to afford the modest pay settlements that their workers are demanding. The cost of staffing per unit of output, a measure of domestically generated inflation, grew by 1.7% in 2017 but by 2.7% last year. To absorb these extra costs some firms are accepting lower profits. Other firms are passing them on to customers, stoking consumer-price inflation, which hovers around the Bank of England’s 2% target. For now there is little need for the bank to raise interest rates, which would bring down inflation. Uncertainty over Brexit, which is likely to continue until October and perhaps beyond, argues in favour of holding fire. Yet the difficult truth is that Britain’s current rate of wage growth, modest by historical standards, is about as high as it can go without pushing inflation above target. It will be some time before Britons’ pay squeeze is truly over.","raw":null,"content":null,"categories":[{"name":"economist","slug":"economist","permalink":"https://stanxia.github.io/categories/economist/"}],"tags":[{"name":"economist","slug":"economist","permalink":"https://stanxia.github.io/tags/economist/"}]},{"title":"Big carmakers are placing vast bets on battery power","slug":"Big carmakers are placing vast bets on battery power","date":"2019-04-16T23:16:46.000Z","updated":"2019-04-17T06:08:31.918Z","comments":true,"path":"2019/04/16/Big carmakers are placing vast bets on battery power/","link":"","permalink":"https://stanxia.github.io/2019/04/16/Big carmakers are placing vast bets on battery power/","excerpt":"","text":"From GM and Geely to Mitsubishi and Mercedes, giants of the industry are revving up their electric plans Apr 16th 2019 IN 1900 ONE in three cars on American roads ran on volts. Then oil began gushing out of Texas. Cheaper than batteries, and easier to top up, petrol fuelled the rise of mass-produced automobiles. Cost and worries about limited range have kept electric vehices (EVs) in a niche ever since. Tesla, which has made battery power sexy again in the past decade, produced just 250,000 units last year, a fraction of what Volkswagen or Toyota churn out each year. For every one of the 2m or so pure EVs and plug-in hybrids, which combine batteries and internal-combustion engines (ICEs), sold in 2018, the world’s carmakers shifted 50 petrol or diesel cars. EV sales are, however, accelerating as quickly as electric motors. Some industry-watchers reckon that they will account for nearly 15% of the global total by 2025. One in five new cars in China will run on batteries then, according to Bloomberg New Energy Finance, a consultancy. The chief reason such optimistic forecasts no longer look outlandish is the entry into the electric race of the car industry’s juggernauts. A survey by Reuters in January put the industry’s total planned EV-related spending worldwide (including on batteries) at around $300bn over the next five to ten years. From GM and Geely to Mercedes and Nissan, big carmakers all want to turn out millions of such cars—and turn a profit doing so. Their strategies range from cautious to aggressive. Making a profitable, mass-produced EV has proved elusive. A battery powertrain can be three times the price of an ICE. But a combination of better technology and greater scale may soon allow EVs to compete on price with petrol vehicles, and enable motorists to drive long distances without the fear of running out of juice. They had better, carmakers are hoping. Worries about climate change and air pollution are prompting authorities around the world to consider phasing out new petrol and diesel engines in the coming decade. In the absence of federal regulations under America’s climate-sceptical president, Donald Trump, some progressive cities and states are tightening local rules. Fiat Chrysler (whose chairman, John Elkann, sits on the board of The Economist’s parent company) has just agreed to pay Tesla hundreds of millions of euros to count the Californian marque as part of its fleet, and thus avoid steep fines for exceeding average CO2-emissions standards for carmakers due to come into force in the European Union next year. In China, where half the world’s EVs are already sold, the government sees electrification of transport as a way to combat choking urban smog—and to lap the West technologically. Western premium brands appear best positioned to take an early lead. While batteries remain pricey, fancy marques can offset the cost with the higher prices that their vehicles command. Jaguar and Audi have already broken Tesla’s monopoly at the lucrative top end of the market. Daimler, which owns Mercedes, has committed €10bn ($11.3bn) to its EQ range and wants 20% of its cars to be fully electric by 2025. Daimler and BMW, which has been bruised by losses on its poorly selling i3 electric hatchback, are hedging their bets by backing platforms (as the basic architecture of a car is known in the business) that are able to accommodate petrol and diesel engines as well as electric motors. This should help them contain costs, but at the expense of compromises over battery size and layout. Sacrificing range and interior space in this way may dent brands built on luxury and technological prowess, says Patrick Hummel of UBS, a bank. Many mass-market firms are likewise proceeding cautiously. Their thinner margins leave less room to absorb the cost of batteries. Renault of France and South Korea’s Hyundai are nevertheless toying with the idea of a dedicated electric-only platform. PSA Group has said it plans to electrify more Peugeots, Citroëns and Opels. Fiat Chrysler has made similar noises, though the Tesla tie-up suggests its near-term plans are less ambitious. Toyota’s early bet on hydrogen fuel cells, which lag behind batteries on the road to widespread adoption, had long been a distraction. The Japanese giant has now acknowledged that buyers want battery-power. It is planning ten models by the early 2020s. The most daring by a long way is VW. The German group’s heft—it produces 10m cars a year—affords it economies of scale only Toyota could hope to match. The €30bn VW plans to spend on developing EVs over the next five years, plus €50bn to fit them with batteries, leaves all other carmakers in the dust. In March Herbert Diess, its chief executive, promised 70 new electric models by 2028, rather than 50 as previously pledged, and 22m EVS delivered over the next ten years. The company is contemplating a huge investment in a “gigafactory” to supply its own batteries rather than depending on outside suppliers. VW is already developing a dedicated platform and converting entire factories to EV production. The first, at Zwickau in Germany, will eventually turn out 330,000 cars a year for the VW brand as well as Audi and SEAT. Its medium-sized ID hatchback, to be shipped next year, will cost around €30,000, similar to an equivalent diesel-powered Golf, and travel 400-600km (250-370 miles) on a single charge. On April 14th in Shanghai Mr Diess unveiled a sport-utility vehicle to compete with Tesla’s snazzy Model X in China from 2021. Once the range of EVs reaches full production in 2022, VW believes, such models will start breaking even. By 2025, when it hopes one-quarter of its output will be electric, they should be as profitable as petrol cars. As Mike Manley, boss of Fiat Chrysler, observers, it is no longer a question of whether carmakers can deliver a fleet of EVs but whether people will pay for them. If governments withdraw generous subsidies which EV-owners have enjoyed, charging infrastructure fails to materialise or electric cars’ pitiful resale value does not increase, motorists may be reluctant to abandon their tried and tested petrol wheels. Poor sales, combined with the large upfront investments, would hit carmakers’ margins, which for mass-market brands are already about as exciting as a Soviet-era Trabant in mud brown. The financial consequences could be “ugly”, warns Bernstein, an equity-research firm. Electric fieldAt the same time, the big carmakers can expect more competition from rivals unburdened by complex ICE supply chains and large workforces. VW has 40,000 suppliers worldwide and directly employs 660,000 people. Lower capital intensity, and the relative simplicity of EVs, which use many fewer parts than petrol vehicles and are easier to assemble, is drawing in upstarts. They include Dyson, a British maker of vacuum cleaners, and a raft of Chinese Tesla-wannabes, such as NIO and Byton. Bigger Chinese carmakers, such as Geely and JAC, have also developed expertise in EVs. With domestic sales stalling, they are beginning to eye export markets. Other technological bumps are meanwhile beginning to test the industry’s chassis. Self-driving cars and ride-sharing are forcing car companies to rethink their established business model. If carmakers miss the electric turn now, they will find it harder to find their way in these futuristic areas. The electric race may prove to be a practice lap for wider disruption.","raw":null,"content":null,"categories":[{"name":"economist","slug":"economist","permalink":"https://stanxia.github.io/categories/economist/"}],"tags":[{"name":"economist","slug":"economist","permalink":"https://stanxia.github.io/tags/economist/"}]},{"title":"The fire in Notre Dame cathedral, and more from our daily podcast","slug":"The fire in Notre Dame cathedral, and more from our daily podcast","date":"2019-04-16T23:16:44.000Z","updated":"2019-04-17T06:08:31.936Z","comments":true,"path":"2019/04/16/The fire in Notre Dame cathedral, and more from our daily podcast/","link":"","permalink":"https://stanxia.github.io/2019/04/16/The fire in Notre Dame cathedral, and more from our daily podcast/","excerpt":"","text":"Also, counting civilian casualties and Cuba’s sporting export Podcasts | Apr 16th 2019 EMMANUEL MACRON, the president of France, was already dealing with national protests when a massive fire broke out at the Notre Dame cathedral, an 850-year old Parisian landmark. Can the tragedy, and Mr Macron’s leadership, bring the country together? America’s armed forces often don’t know how many civilians are killed in its air-strike campaigns—but that’s changing, thanks to pressure from the Pentagon’s loudest critics. And, though the Trump administration has cancelled a deal for Cuban baseball players, that won’t stop them making their way to the big leagues. Runtime: TK min. Listen on: Apple Podcasts | Spotify | Google | Stitcher | TuneIn","raw":null,"content":null,"categories":[{"name":"economist","slug":"economist","permalink":"https://stanxia.github.io/categories/economist/"}],"tags":[{"name":"economist","slug":"economist","permalink":"https://stanxia.github.io/tags/economist/"}]},{"title":"Cathedrals are neglected in much of Europe","slug":"Cathedrals are neglected in much of Europe","date":"2019-04-16T23:16:41.000Z","updated":"2019-04-17T06:08:31.918Z","comments":true,"path":"2019/04/16/Cathedrals are neglected in much of Europe/","link":"","permalink":"https://stanxia.github.io/2019/04/16/Cathedrals are neglected in much of Europe/","excerpt":"","text":"Ancient churches are the greatest glory of Europe’s cities, and a headache for those trying to look after them Erasmus | Apr 16th 2019 THE CATHEDRAL of Notre Dame in Paris, and the vast outpouring of sorrow over its semi-destruction by fire on April 15th, epitomises the power of great houses of prayer to touch and inspire people. More palpably than any other kind of monument, they connect visitors with another world: one in which the finest composers, singers, sculptors, glass-makers, embroiderers and craft-workers of a given era joyfully mixed their energies in a vast, disinterested enterprise. To some degree, that enterprise continues as long as the building stands. That alone makes great historic churches a source of fascination, even for those with little interest in Christian worship. People want them to be there, even if they don’t wish to share the cost or join the prayers. In almost every country in Europe, that creates an acute problem. The cost of maintaining the delicate stone fabric of a cathedral seems to rise geometrically, far out-stripping the ability of small congregations to sustain them. Governments and other secular bodies are minded to help but they also feel compelled, in most places, to respect the independence of the buildings’ historic stewards, in other words the churches. In England, the established church boasts 42 cathedrals (technically defined as the seat of a bishop), of which 39 are listed as historic buildings whose preservation is both mandated by law and entitled to some public help. (About 12,000 of the 16,000 other places of worship controlled by the Church of England are also listed.) The Church of England likes to call the cathedrals one of its “success stories” with rising numbers of worshippers and visitors, and growing revenue. But as a recent report led by a bishop delicately put it, “recent failures of governance and management within a small number of cathedrals have highlighted vulnerabilities across the sector…” In plain language, at least two cathedrals have run into severe financial difficulties, which better stewardship might have avoided. English cathedrals are relatively independent bodies, run by a cleric known as a dean who relies on a group of advisers known as a chapter. They are free to raise money in many ways, from concerts to exhibitions to simply charging an admission fee, as about a quarter of them do. In recent weeks Derby Cathedral raised eyebrows by hosting films that included graphic sex scenes and depictions of paganism. Churches in Germany have an advantage. The system of religious taxes (under which people of Catholic or Lutheran heritage pay a levy to their respective denominations) has ensured an ample income stream. Germany’s religious masters have done better at hauling in revenue than at retaining worshippers, the figures would suggest. But a massive fund-raising effort, drawing in generous private-sector donors and ordinary well-wishers in Germany and Britain, was needed for one of the biggest church reconstruction projects of modern times: the rebuilding of the Frauenkirche in Dresden. This showpiece of German Baroque was destroyed, along with much of the city, in a British bombing raid in February 1945. The project, completed in 2005, was a complement to the erection in 1962 of a new cathedral in Coventry, replacing the one wrecked by a German air raid on the English Midlands. Most European states subsidise their historically dominant Christian denominations, directly or indirectly, while also leaving the sects’ religious masters relatively autonomous. In Italy, despite the notional separation of Catholic church and state, the two are deeply intertwined, through tax breaks and state help for maintaining the artistic heritage which is one of Italy’s greatest tourist draws. Belgium offers generous help to all its main religions, but Catholic cathedrals still charge stiff admission fees as though they were museums. In church-state relations, France is an outlier. Under the regime of laïcité, or strict secularism, municipalities took over formal responsibility for Catholic churches; clerics and their congregations are merely users. And clerics, in particular, are thin on the ground. In rural France, it is common for a priest to look after 30 old churches. That paucity of active users prompts municipal authorities to assign a low priority to conserving church buildings. In 2013 a huge neo-Gothic church in the northern French town of Abbeville was dramatically demolished by municipal leaders, who said the place was a safety hazard and too expensive to repair. Hundreds of other French churches may soon have a similar fate. Nor have France’s state authorities done very well at protecting houses of prayer from a wave of vandalism, including arson and desecration, that has afflicted them this year. Indeed, all over western Europe, churches are closing for lack of worshippers. In the Netherlands, a cardinal predicted in 2013 that two-thirds of the Roman Catholic churches in the country would shut by 2025. But a diametrically opposing trend is at work further east in Europe. Perhaps the most spectacular act of church reconstruction of recent times was the re-erection of Moscow’s Cathedral of Christ the Saviour, which was dynamited by Stalin in 1931 and thrown back up over five years starting in 1995. It was rebuilt in about a tenth of the time needed for the original construction. Elsewhere in Russia, under a crash building programme decreed by the Russian Orthodox church, at least three new churches are said to be opening per day. And in other parts of central and eastern Europe, from Serbia to Georgia, vast new Orthodox churches now adorn capital cities which were already endowed with many places of prayer. Indeed, the Russian church building spree extends far beyond the borders of the motherland. Anyone who takes a short walk along the banks of the Seine from the wreckage of Notre Dame will soon see a boldly modernistic structure, topped with onion domes: this “spiritual and cultural” centre, opened in 2016, was a pet project of President Vladimir Putin’s. It competes hard with an older Russian-style cathedral in Paris which the Muscovite authorities, to their frustration, do not control. As the Russian state media were eager to point out, western Europe is gaining some new Christian places of worship even as many others are destroyed, accidentally or otherwise. See alsoA terrible blaze devastates Notre Dame cathedral (April 15th 2019)","raw":null,"content":null,"categories":[{"name":"economist","slug":"economist","permalink":"https://stanxia.github.io/categories/economist/"}],"tags":[{"name":"economist","slug":"economist","permalink":"https://stanxia.github.io/tags/economist/"}]},{"title":"Fire in the heart of Paris","slug":"Politics this week","date":"2019-04-16T18:15:21.000Z","updated":"2019-04-17T06:08:31.936Z","comments":true,"path":"2019/04/16/Politics this week/","link":"","permalink":"https://stanxia.github.io/2019/04/16/Politics this week/","excerpt":"","text":"Fire in the heart of ParisPolitics this week Apr 11th 2019 Following months of mass protests in Sudan, it appeared that Omar al-Bashir had been ousted as president by the army. Mr al-Bashir had misruled since taking power in a coup in 1989. His civil war against non-Muslim black Africans ended with the secession of South Sudan. Separately, the International Criminal Court charged him with overseeing genocide in Darfur. See article. Binyamin Netanyahu won a record fifth term as prime minister of Israel. His Likud party tied with Blue and White, a centrist rival. But the right-wing and religious bloc, of which Likud is a part, won a majority of seats in the Knesset. In the final days of the campaign Mr Netanyahu vowed to begin annexing parts of the West Bank, further dimming the prospect of any peace with the Palestinians based on a two-state solution. See here and here. Khalifa Haftar, Libya’s most powerful warlord, attacked Tripoli, which is controlled by the UN-backed government. Dozens of people were killed in the fighting, as militias allied to the government rallied to defend the capital. A UN peace conference, scheduled for this month, was postponed. See article. Protests continued in Algeria, where crowds called for the resignation of Abdelkader Bensalah, the interim president. Mr Bensalah succeeded Abdelaziz Bouteflika, who resigned amid widespread anger at his regime after 20 years in charge. For the first time police used tear-gas to disperse the demonstrators. Mr Bensalah said the country would hold a presidential election on July 4th. Theresa May, Britain’s prime minister, attended a summit in Brussels to discuss another delay to Brexit. The European Union offered Britain six more months, pushing the deadline to October 31st, Halloween. That means Britain faces having to vote in elections to the European Parliament next month, though British MEPs will have to step down if Brexit actually happens. The president of the European Commission, Jean-Claude Juncker, joked that if there was another late-night meeting on the last day of the talks he might have to leave at midnight; his term ends on November 1st. See article. Julian Assange, a founder of WikiLeaks, was arrested by British police in the Ecuadorean embassy in London. Ecuador had granted Mr Assange refuge in 2012 after he had jumped bail while facing rape allegations. His relationship with his hosts soured after a change of government in Ecuador, where a leftist president was replaced by a more moderate one. Mr Assange has said he fears extradition to the United States, where WikiLeaks is not popular, having published reams of leaked American military secrets. Turkey’s ruling party demanded a fresh vote in Istanbul, where it narrowly lost the mayoralty in elections on March 31st. Italy’s deputy prime minister, Matteo Salvini, announced the formation of a new nationalist group within the European Parliament, to be called the European Alliance for People and Nations. However, none of the party leaders he hoped would attend from other countries turned up. The Trump administration cancelled a four-month-old agreement under which Cuban baseball players could join Major League teams in America without defecting from their country. The administration said the agreement would encourage human trafficking and help enrich Cuba’s communist government. See article. Jair Bolsonaro, Brazil’s president, sacked the education minister, Ricardo Vélez, who shared his socially conservative views. Mr Vélez had courted controversy by instructing schools to film classes singing the national anthem and repeating Mr Bolsonaro’s campaign slogan. His replacement, Abraham Weintraub, an economist, has said that crack cocaine was introduced to Brazil deliberately by the left. See here. Thanathorn Juangroongruangkit, the leader of the Future Forward party, was charged with sedition in relation to a protest against Thailand’s military junta in 2015. It is one of several repressive steps that has marred the country’s supposed return to democracy after an election last month. See article. Kassym Jomart Tokayev, Kazakhstan’s interim president following the sudden resignation of Nursultan Nazarbayev after three decades in power, called a snap election for June 9th. See article. South Korea’s constitutional court ruled that the government must end the country’s ban on abortion, in place since 1953, before the end of 2020. Doctors can currently be imprisoned if they perform the procedure. However, tens of thousands of abortions are carried out each year. Voting began in India’s seven-stage election. The final phase will take place on May 19th and the results for all seven stages will be announced on May 23rd. Polls suggest the ruling Bharatiya Janata Party will remain the biggest party. See article. A court in Hong Kong found nine people guilty of “public nuisance” charges relating to their leading roles in the Umbrella Movement of 2014, which involved weeks of sit-ins and demonstrations in busy commercial districts in support of democratic reform. Among the defendants were three founders of a group involved in the unrest. Kirstjen Nielsen resigned as the secretary of America’s Department of Homeland Security. Donald Trump is trying to replace the department’s top officials with people who will try harder to keep Mexicans out of the United States. Mr Trump has threatened to close the border entirely, despite advice that this would cause economic chaos. See article. Randolph Alles, the head of America’s Secret Service, is quitting. He had reportedly been asked to go before the recent security breach at Mr Trump’s private club, involving a Chinese woman with several thumb drives. Amnesty International’s annual report on the death penalty recorded a drop of nearly a third in known executions worldwide last year. There were 690 in 2018, down from 1,061 in 2015. The number of death sentences passed by courts also declined slightly, though in the Middle East and north Africa death sentences nearly doubled to 1,170. The region is responsible for two-thirds of the world’s known executions. (China is also thought to execute thousands of people every year, but keeps its figures secret.) Of the countries that release figures, Iran is by far the most avid executioner, putting 409 people to death each year on average for the past decade.","raw":null,"content":null,"categories":[{"name":"economist","slug":"economist","permalink":"https://stanxia.github.io/categories/economist/"}],"tags":[{"name":"economist","slug":"economist","permalink":"https://stanxia.github.io/tags/economist/"}]},{"title":"IDEA 使用技巧","slug":"IDEA 使用技巧","date":"2017-12-28T09:34:44.000Z","updated":"2019-04-17T06:08:31.936Z","comments":true,"path":"2017/12/28/IDEA 使用技巧/","link":"","permalink":"https://stanxia.github.io/2017/12/28/IDEA 使用技巧/","excerpt":"","text":"前言 在生产中主力是使用 IDEA ，工欲善其事，必先利其器。因而总结一下在使用过程中的经验，为方便初学者更快的掌握这个神器。 配置阿里云配置 阿里云 作为 maven 的仓库来源，原因大家都懂得，国外的仓库速度有时候很呵呵，国内的这方面还是靠谱点。 第一步：打开 IDEA 左上角的偏好设置 Preferences，接连点击 Build &gt;&gt; Build Tools &gt;&gt; Maven ，在 Maven home directory 处选择 IDEA 自带的 maven 版本，在本地文件系统中找到该路径，找到并进入 conf 目录，打开编辑 settings.xml 。 第二步：在 settings.xml 中搜索 mirrors ,将以下配置写入该处：1234567&lt;!-- 阿里amven库 --&gt;&lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;&lt;/mirror&gt; NOTE:注意将上述代码放入 &lt;mirrors&gt;这里面&lt;/mirrors&gt; 。 第三步：回到 Maven 的配置界面，User settings file 处点击 Override ,选择刚才编辑的 settings.xml 文件全路径。 第四步：Apply ,OK,完活。现在可以验证是否成功。","raw":null,"content":null,"categories":[{"name":"idea","slug":"idea","permalink":"https://stanxia.github.io/categories/idea/"}],"tags":[{"name":"idea","slug":"idea","permalink":"https://stanxia.github.io/tags/idea/"},{"name":"mac","slug":"mac","permalink":"https://stanxia.github.io/tags/mac/"}]},{"title":"Phoenix Secondary Indexing","slug":"Phoenix-Secondary-Indexing","date":"2017-12-27T16:48:35.000Z","updated":"2019-04-17T06:08:31.936Z","comments":true,"path":"2017/12/27/Phoenix-Secondary-Indexing/","link":"","permalink":"https://stanxia.github.io/2017/12/27/Phoenix-Secondary-Indexing/","excerpt":"二级索引是从主访问路径访问数据的正交方式。在 HBase 中，您有一个索引按字典顺序排序在主键行上。以不同于主要行的方式访问记录需要扫描表中的所有行，以针对您的过滤器对其进行测试。通过二级索引，您索引的列或表达式形成一个备用行键，以允许沿着这个新轴进行点查找和范围扫描。\nCovered Indexes 覆盖索引\nPhoenix 是特别强大的，因为我们提供覆盖索引 - 一旦找到索引条目，我们不需要返回主表。相反，我们将我们关心的数据绑定到索引行，节省了读取时间的开销。\n例如，以下内容将在v1和v2列上创建索引，并在索引中包含v3列以防止从数据表中获取该列：\n1CREATE INDEX my_index ON my_table (v1,v2) INCLUDE(v3)","text":"二级索引是从主访问路径访问数据的正交方式。在 HBase 中，您有一个索引按字典顺序排序在主键行上。以不同于主要行的方式访问记录需要扫描表中的所有行，以针对您的过滤器对其进行测试。通过二级索引，您索引的列或表达式形成一个备用行键，以允许沿着这个新轴进行点查找和范围扫描。 Covered Indexes 覆盖索引 Phoenix 是特别强大的，因为我们提供覆盖索引 - 一旦找到索引条目，我们不需要返回主表。相反，我们将我们关心的数据绑定到索引行，节省了读取时间的开销。 例如，以下内容将在v1和v2列上创建索引，并在索引中包含v3列以防止从数据表中获取该列： 1CREATE INDEX my_index ON my_table (v1,v2) INCLUDE(v3) Functional Indexes 函数索引 函数索引（在4.3和更高版本中可用）允许您不仅在列上而且在任意表达式上创建索引。然后，当一个查询使用该表达式时，索引可以用来检索结果而不是数据表。例如，您可以在 UPPER（FIRST_NAME ||’’|| LAST_NAME）上创建一个索引，以允许您对组合的名字和姓氏进行不区分大小写的搜索。 例如，下面将创建这个功能索引： 1CREATE INDEX UPPER_NAME_IDX ON EMP (UPPER(FIRST_NAME||' '||LAST_NAME)) 有了这个索引，发出下面的查询时，将使用索引而不是数据表来检索结果：1SELECT EMP_ID FROM EMP WHERE UPPER(FIRST_NAME||' '||LAST_NAME)='JOHN DOE' Phoenix 支持两种索引技术：全局索引和本地索引。每个在不同的情况下都很有用，并且有自己的故障概况和性能特点。 Global Indexes 全局索引 全局索引目标是重度读操作用例。使用全局索引，索引的所有性能损失都是在写入时发生的。我们拦截数据表更新写（DELETE，UPSERT VALUES和UPSERT SELECT），建立索引更新，然后发送任何必要的更新到所有感兴趣的索引表。在读的时候，Phoenix 会选择使用的索引表，这将产生最快的查询时间，并直接扫描它，就像任何其他的 HBase 表一样。默认情况下，除非暗示，否则索引不会用于引用不属于索引的列的查询。 Local Indexes 本地索引 本地索引目标针对重度写操作，空间受限的用例。就像全局索引一样，Phoenix 会在查询时自动选择是否使用本地索引。使用本地索引，索引数据和表数据共同驻留在同一台服务器上，防止写入期间的任何网络开销。即使查询没有完全覆盖，也可以使用本地索引（即，Phoenix 自动检索不在索引中的列，通过与数据表相对应的索引）。与全局索引不同，表中的所有本地索引都存储在4.8.0版之前的单独的共享表中。从4.8.0开始，我们将所有本地索引数据存储在相同数据表中的单独的影子列族中。在读取本地索引时，由于不能确定索引数据的确切区域位置，所以必须检查每个区域的数据。因此在读取时会发生一些开销。 Index Population 默认情况下，创建索引时，会在 CREATE INDEX 调用期间同步填充该索引。根据数据表的当前大小，这可能是不可行的。从4.5开始，可以通过在索引创建 DDL 语句中包含 ASYNC 关键字来异步完成索引的填充：1CREATE INDEX async_index ON my_schema.my_table (v) ASYNC 必须通过 HBase 命令行单独启动填充索引表的 map-reduce 作业，如下所示：123$&#123;HBASE_HOME&#125;/bin/hbase org.apache.phoenix.mapreduce.index.IndexTool --schema MY_SCHEMA --data-table MY_TABLE --index-table ASYNC_IDX --output-path ASYNC_IDX_HFILES 只有 map-reduce 作业完成后，索引才会被激活并开始在查询中使用。这项工作对于退出的客户端是有弹性的。输出路径选项用于指定用于写入 HFile 的 HDFS 目录。 Index Usage 索引使用 Phoenix 自动使用索引来服务一个查询，当它确定更有效的时候。但是，除非查询中引用的所有列都包含在索引中，否则不会使用全局索引。例如，以下查询不会使用索引，因为在查询中引用了v2，但未包含在索引中：1SELECT v2 FROM my_table WHERE v1 = 'foo' 在这种情况下，有三种获取索引的方法： 1.通过在索引中包含v2来创建一个覆盖索引：1CREATE INDEX my_index ON my_table (v1) INCLUDE (v2) 这将导致v2列值被复制到索引中，并随着更改而保持同步。这显然会增加索引的大小。 2.提示查询强制它使用索引：1SELECT /*+ INDEX(my_table my_index) */ v2 FROM my_table WHERE v1 = 'foo' 这将导致在遍历索引时找到每个数据行以找到缺少的v2列值。这个提示只有在你知道索引有很好的选择性的时候才可以使用（例如，在这个例子中有少量的表格行的值是’foo’），否则你可以通过默认的行为来获得更好的性能全表扫描。 3.创建一个本地索引：1CREATE LOCAL INDEX my_index ON my_table (v1) 与全局索引不同，即使查询中引用的所有列都不包含在索引中，本地索引也将使用索引。这是默认为本地索引完成的，因为我们知道在同一个区域服务器上的表和索引数据coreside确保查找是本地的。 Index Removal 索引移除 要删除索引，使用以下语句：1DROP INDEX my_index ON my_table 如果索引列在数据表中被删除，索引将自动被删除。另外，如果在数据表中删除一个被覆盖的列，它也会自动从索引中删除。 Index Properties 索引属性 就像使用CREATE TABLE语句一样，CREATE INDEX语句可以通过属性应用到底层的HBase表，包括对其进行限制的能力:12CREATE INDEX my_index ON my_table (v2 DESC, v1) INCLUDE (v3) SALT_BUCKETS=10, DATA_BLOCK_ENCODING='NONE' 请注意，如果主表是加盐的，则对于全局索引，该索引将以相同的方式自动被加盐。另外，相对于主索引表与索引表的大小，索引的MAX_FILESIZE向下调整。欲了解更多信息，请参阅这里。另一方面，使用本地索引时，不允许指定SALT_BUCKETS。 Consistency Guarantees 一致性保证 在提交后成功返回到客户端，所有数据保证写入所有相关的索引和主表。换句话说，索引更新与HBase提供的相同强一致性保证是同步的。 但是，由于索引存储在与数据表不同的表中，因此根据表的属性和索引的类型，表和索引之间的一致性会因服务器端崩溃而失败。这是您的需求和使用案例驱动的重要设计考虑因素。 下面概述了各种一致性保证的不同选项。 Transactional Tables 事务表通过将您的表声明为事务性的，您可以实现表和索引之间最高级别的一致性保证。在这种情况下，您的表突变和相关索引更新的提交是具有强 ACID 保证的原子。如果提交失败，那么您的数据（表或索引）都不会更新，从而确保您的表和索引始终保持同步。 为什么不总是把你的表声明为事务性的？这可能很好，特别是如果你的表被声明为不可变的，因为在这种情况下事务开销非常小。但是，如果您的数据是可变的，请确保与事务性表发生冲突检测相关的开销和运行事务管理器的运行开销是可以接受的。此外，具有二级索引的事务表可能会降低写入数据表的可用性，因为数据表及其辅助索引表必须可用，否则写入将失败。 Immutable Tables 不可变表对于其中数据只写入一次而从不更新的表，可以进行某些优化以减少增量维护的写入时间开销。这是常见的时间序列数据，如日志或事件数据，一旦写入行，它将永远不会被更新。要利用这些优化，通过将 IMMUTABLE_ROWS = true 属性添加到您的 DDL 语句中，将您的表声明为不可变：1CREATE TABLE my_table (k VARCHAR PRIMARY KEY, v VARCHAR) IMMUTABLE_ROWS=true 使用 IMMUTABLE_ROWS = true 声明的表上的所有索引都被认为是不可变的（请注意，默认情况下表被认为是可变的）。对于全局不可变索引，索引完全在客户端维护，索引表是在数据表发生更改时生成的。另一方面，本地不可变索引在服务器端保持不变。请注意，没有任何保护措施可以强制执行，声明为不可变的表实际上不会改变数据（因为这会否定所达到的性能增益）。如果发生这种情况，索引将不再与表同步。 如果您有一个现有的表，您想从不可变索引切换到可变索引，请使用ALTER TABLE命令，如下所示：1ALTER TABLE my_table SET IMMUTABLE_ROWS=false 非事务性，不可变表的索引没有自动处理提交失败的机制。保持表和索引之间的一致性留给客户端处理。因为更新是幂等的，所以最简单的解决方案是客户端继续重试一批突变，直到它们成功。 Mutable Tables 可变表对于非事务性可变表，我们通过将索引更新添加到主表行的预写日志（WAL）条目来维护索引更新持久性。只有在WAL条目成功同步到磁盘后，我们才会尝试更新索引/主表。我们默认并行编写索引更新，从而导致非常高的吞吐量。如果服务器在我们写索引更新的时候崩溃了，我们会重播所有索引更新到WAL恢复过程中的索引表，并依赖更新的幂等性来确保正确性。因此，非事务性可变表上的索引只是主表背后的一批编辑。 重要的是要注意几点： 对于非事务性表，您可以看到索引表与主表不同步。 如上所述，这是可以的，因为我们在很短的时间内只有很小的一部分，并且不同步 每个数据行及其索引行都保证被写入或丢失 - 我们从来没有看到部分更新，因为这是HBase原子性保证的一部分。 首先将数据写入表中，然后写入索引表（如果禁用WAL，则反之亦然）。 Singular Write Path有一个保证失败属性的写入路径。所有写入HRegion的内容都被我们的协处理器拦截。然后，我们根据挂起更新（或更新，如果是批处理）构建索引更新。然后这些更新被附加到原始更新的WAL条目。 如果在此之前我们遇到任何问题，我们会将失败返回给客户端，并且没有任何数据被持久化或者不可见。 一旦WAL被写入，我们确保即使在失败的情况下，索引和主表数据也将变得可见。 如果服务器发生崩溃，我们会使用通常的WAL重播机制重播索引更新。 如果服务器没有崩溃，我们只是将索引更新插入到它们各自的表中。 如果索引更新失败，下面概述了保持一致性的各种方法。 如果Phoenix系统目录表发生故障时无法到达，我们强制服务器立即中止并失败，请在JVM上调用System.exit，强制服务器死机。通过杀死服务器，我们确保WAL将在恢复时重播，将索引更新重播到相应的表中。这确保了二级索引在知道无效状态时不会继续使用。 禁止表写入，直到可变的索引是一致的在非事务性表和索引之间保持一致性的最高级别是声明在更新索引失败的情况下应暂时禁止写入数据表。在此一致性模式下，表和索引将保留在发生故障之前的时间戳，写入数据表将被禁止，直到索引重新联机并与数据表同步。该索引将保持活动状态，并像往常一样继续使用查询。 以下服务器端配置控制此行为： phoenix.index.failure.block.write必须为true，以便在发生提交失败时写入数据表以失败，直到可以使用数据表追上索引。 phoenix.index.failure.handling.rebuild必须为true（默认值），以便在发生提交失败的情况下在后台重建可变索引。 写入失败时禁用可变索引，直到一致性恢复如果在提交时写入失败，具有可变索引的默认行为是将索引标记为禁用,在后台部分重建它们，然后在恢复一致性时再次将其标记为活动状态。在这种一致性模式下，在重建二级索引时，写入数据表不会被阻塞。但是，在重建过程中，二级索引不会被查询使用。 以下服务器端配置控制此行为： phoenix.index.failure.handling.rebuild必须为true（缺省值），以便在发生提交失败的情况下在后台重建可变索引。 phoenix.index.failure.handling.rebuild.interval控制服务器检查是否需要部分重建可变索引以赶上数据表更新的毫秒频率。默认值是10000或10秒。 phoenix.index.failure.handling.rebuild.overlap.time控制执行部分重建时从发生故障的时间戳开始返回的毫秒数。默认值是1。 写入失败时禁用可变索引，需要手动重建这是可变二级索引的最低一致性水平。在这种情况下，当写入二级索引失败时，索引将被标记为禁用，并且手动重建所需的索引以使其再次被查询使用。 以下服务器端配置控制此行为： 如果提交失败，phoenix.index.failure.handling.rebuild必须设置为false，以禁止在后台重建可变索引。 Setup 设置 非事务性，可变索引需要在区域服务器和主服务器上运行特殊的配置选项 - Phoenix确保在表上启用可变索引时，它们已正确设置;如果未设置正确的属性，则将无法使用辅助索引。将这些设置添加到您的hbase-site.xml后，您需要重启集群。 您将需要将以下参数添加到每个区域服务器上的hbase-site.xml：1234&lt;property&gt; &lt;name&gt;hbase.regionserver.wal.codec&lt;/name&gt; &lt;value&gt;org.apache.hadoop.hbase.regionserver.wal.IndexedWALEditCodec&lt;/value&gt;&lt;/property&gt; 上面的属性使定制的WAL编辑能够被写入，确保索引更新的正确写入/重播。这个编解码器支持通常的主机WALEdit选项，最显着的是WALEdit压缩。12345678910&lt;property&gt; &lt;name&gt;hbase.region.server.rpc.scheduler.factory.class&lt;/name&gt; &lt;value&gt;org.apache.hadoop.hbase.ipc.PhoenixRpcSchedulerFactory&lt;/value&gt; &lt;description&gt;Factory to create the Phoenix RPC Scheduler that uses separate queues for index and metadata updates&lt;/description&gt;&lt;/property&gt;&lt;property&gt; &lt;name&gt;hbase.rpc.controllerfactory.class&lt;/name&gt; &lt;value&gt;org.apache.hadoop.hbase.ipc.controller.ServerRpcControllerFactory&lt;/value&gt; &lt;description&gt;Factory to create the Phoenix RPC Scheduler that uses separate queues for index and metadata updates&lt;/description&gt;&lt;/property&gt; 通过确保索引更新的优先级高于数据更新，上述属性可防止在全局索引（HBase 0.98.4+和Phoenix 4.3.1+）的索引维护过程中发生死锁。它还通过确保元数据rpc调用比数据rpc调用具有更高的优先级来防止死锁。 从Phoenix 4.8.0开始，不需要更改配置就可以使用本地索引。在Phoenix 4.7及更低版本中，主服务器节点和区域服务器节点上的服务器端hbase-site.xml需要进行以下配置更改：123456789101112&lt;property&gt; &lt;name&gt;hbase.master.loadbalancer.class&lt;/name&gt; &lt;value&gt;org.apache.phoenix.hbase.index.balancer.IndexLoadBalancer&lt;/value&gt;&lt;/property&gt;&lt;property&gt; &lt;name&gt;hbase.coprocessor.master.classes&lt;/name&gt; &lt;value&gt;org.apache.phoenix.hbase.index.master.IndexMasterObserver&lt;/value&gt;&lt;/property&gt;&lt;property&gt; &lt;name&gt;hbase.coprocessor.regionserver.classes&lt;/name&gt; &lt;value&gt;org.apache.hadoop.hbase.regionserver.LocalIndexMerger&lt;/value&gt;&lt;/property&gt; 升级4.8.0之前创建的本地索引在服务器上将Phoenix升级到4.8.0以上版本时，如果存在，请从hbase-site.xml中除去以上三个与本地索引相关的配置。从客户端，我们支持在线（在初始化来自4.8.0+版本的phoenix客户端的连接时）和离线（使用psql工具）在4.8.0之前创建的本地索引的升级。作为升级的一部分，我们以ASYNC模式重新创建本地索引。升级后用户需要使用IndexTool建立索引。 在升级之后使用客户端配置。 phoenix.client.localIndexUpgrade 值为 true 则表示在线升级, false 表示离线升级。 默认为 true 。 命令使用psql工具$ psql [zookeeper] -l运行离线升级。 Tuning 索引是相当快的。但是，要优化您的特定环境和工作负载，可以调整一些属性。 以下所有参数必须在hbase-site.xml中设置 - 对于整个集群和所有索引表，以及在同一台服务器上的所有区域上都是如此（例如，一台服务器也不会一次写入许多不同的索引表）。 index.builder.threads.max 用于从主表更新构建索引更新的线程数 增加此值克服了从底层HRegion读取当前行状态的瓶颈。调整这个值太高，只会增加HRegion瓶颈，因为它将无法处理太多的并发扫描请求，以及一般的线程交换问题。 Default: 10 index.builder.threads.keepalivetime 在构建器线程池中使线程过期后的时间（以秒为单位）。 未使用的线程会在这段时间后立即释放，而不会保留核心线程 Default: 60 index.writer.threads.max Number of threads to use when writing to the target index tables. The first level of parallelization, on a per-table basis - it should roughly correspond to the number of index tables Default: 10 index.writer.threads.keepalivetime Amount of time in seconds after we expire threads in the writer thread pool. Unused threads are immediately released after this amount of time and not core threads are retained (though this last is a small concern as tables are expected to sustain a fairly constant write load), but simultaneously allows us to drop threads if we are not seeing the expected load. Default: 60 hbase.htable.threads.max Number of threads each index HTable can use for writes. Increasing this allows more concurrent index updates (for instance across batches), leading to high overall throughput. Default: 2,147,483,647 hbase.htable.threads.keepalivetime Amount of time in seconds after we expire threads in the HTable’s thread pool. Using the “direct handoff” approach, new threads will only be created if it is necessary and will grow unbounded. This could be bad but HTables only create as many Runnables as there are region servers; therefore, it also scales when new region servers are added. Default: 60 index.tablefactory.cache.size Number of index HTables we should keep in cache. Increasing this number ensures that we do not need to recreate an HTable for each attempt to write to an index table. Conversely, you could see memory pressure if this value is set too high. Default: 10 org.apache.phoenix.regionserver.index.priority.min Value to specify to bottom (inclusive) of the range in which index priority may lie. Default: 1000 org.apache.phoenix.regionserver.index.priority.max Value to specify to top (exclusive) of the range in which index priority may lie. Higher priorites within the index min/max range do not means updates are processed sooner. Default: 1050 org.apache.phoenix.regionserver.index.handler.count Number of threads to use when serving index write requests for global index maintenance. Though the actual number of threads is dictated by the Max(number of call queues, handler count), where the number of call queues is determined by standard HBase configuration. To further tune the queues, you can adjust the standard rpc queue length parameters (currently, there are no special knobs for the index queues), specifically ipc.server.max.callqueue.length and ipc.server.callqueue.handler.factor. See the HBase Reference Guide for more details. Default: 30 Performance We track secondary index performance via our performance framework. This is a generic test of performance based on defaults - your results will vary based on hardware specs as well as you individual configuration. That said, we have seen secondary indexing (both immutable and mutable) go as quickly as &lt; 2x the regular write path on a small, (3 node) desktop-based cluster. This is actually pretty reasonable as we have to write to multiple tables as well as build the index update. Index Scrutiny Tool With Phoenix 4.12, there is now a tool to run a MapReduce job to verify that an index table is valid against its data table. The only way to find orphaned rows in either table is to scan over all rows in the table and do a lookup in the other table for the corresponding row. For that reason, the tool can run with either the data or index table as the “source” table, and the other as the “target” table. The tool writes all invalid rows it finds either to file or to an output table PHOENIX_INDEX_SCRUTINY. An invalid row is a source row that either has no corresponding row in the target table, or has an incorrect value in the target table (i.e. covered column value). The tool has job counters that track its status. VALID_ROW_COUNT, INVALID_ROW_COUNT, BAD_COVERED_COL_VAL_COUNT. Note that invalid rows - bad col val rows = number of orphaned rows. These counters are written to the table PHOENIX_INDEX_SCRUTINY_METADATA, along with other job metadata. The Index Scrutiny Tool can be launched via the hbase command (in hbase/bin) as follows: 1hbase org.apache.phoenix.mapreduce.index.IndexScrutinyTool -dt my_table -it my_index -o It can also be run from Hadoop using either the phoenix-core or phoenix-server jar as follows: 1HADOOP_CLASSPATH=$(hbase mapredcp) hadoop jar phoenix-&lt;version&gt;-server.jar org.apache.phoenix.mapreduce.index.IndexScrutinyTool -dt my_table -it my_index -o By default two mapreduce jobs are launched, one with the data table as the source table and one with the index table as the source table. The following parameters can be used with the Index Scrutiny Tool: 翻译自:secondary_indexing","raw":null,"content":null,"categories":[{"name":"phoenix","slug":"phoenix","permalink":"https://stanxia.github.io/categories/phoenix/"}],"tags":[{"name":"phoenix","slug":"phoenix","permalink":"https://stanxia.github.io/tags/phoenix/"}]},{"title":"Google Bigtable 中文版","slug":"Google-Bigtable-中文版","date":"2017-12-25T16:48:35.000Z","updated":"2019-04-17T06:08:31.918Z","comments":true,"path":"2017/12/25/Google-Bigtable-中文版/","link":"","permalink":"https://stanxia.github.io/2017/12/25/Google-Bigtable-中文版/","excerpt":"摘要\nBigtable 是一个分布式的结构化数据存储系统，它被设计用来处理海量数据:通常是分布在数千台普通服务器上的 PB 级的数据。\nGoogle 的很多项目使用 Bigtable 存储数据，包括 Web 索引、Google Earth、Google Finance。这些应用对 Bigtable 提出的要求差异非常大，无论是在数据量上(从 URL 到网页到卫星图像)还是在响应速度上(从后端的批量处理到实时数据服务)。尽管应用需求差异很大，但是，针对 Google 的这些产品，Bigtable 还是成功的提供了一个灵活的、高性能的解决方案。\n本论文描述了 Bigtable 提供的简单的数据模型。利用这个模型，用户可以动态的控制数据的分布和格式。 我们还将描述 Bigtable 的设计和实现。","text":"摘要 Bigtable 是一个分布式的结构化数据存储系统，它被设计用来处理海量数据:通常是分布在数千台普通服务器上的 PB 级的数据。 Google 的很多项目使用 Bigtable 存储数据，包括 Web 索引、Google Earth、Google Finance。这些应用对 Bigtable 提出的要求差异非常大，无论是在数据量上(从 URL 到网页到卫星图像)还是在响应速度上(从后端的批量处理到实时数据服务)。尽管应用需求差异很大，但是，针对 Google 的这些产品，Bigtable 还是成功的提供了一个灵活的、高性能的解决方案。 本论文描述了 Bigtable 提供的简单的数据模型。利用这个模型，用户可以动态的控制数据的分布和格式。 我们还将描述 Bigtable 的设计和实现。介绍在过去两年半时间里，我们设计、实现并部署了一个分布式的结构化数据存储系统 — 在 Google，我们称之为 Bigtable。Bigtable 的设计目的是可靠的处理 PB 级别的数据，并且能够部署到上千台机器上。Bigtable 已经实现了下面的几个目标:适用性广泛、可扩展、高性能和高可用性。 Bigtable 已经在超过 60 个 Google 的产品和项目上得到了应用，包括 Google Analytics、Google Finance、 Orkut、Personalized Search、Writely 和 Google Earth。这些产品对 Bigtable 提出了迥异的需求，有的需要高吞吐量的批处理，有的则需要及时响应，快速返回数据给最终用户。它们使用的 Bigtable 集群的配置也有很大的差异，有的集群只有几台服务器，而有的则需要上千台服务器、存储几百 TB 的数据。 在很多方面，Bigtable 和数据库很类似:它使用了很多数据库的实现策略。并行数据库和内存数据库已经具备可扩展性和高性能，但是 Bigtable 提供了一个和这些系统完全不同的接口。Bigtable 不支持完整的关系数据模型;与之相反，Bigtable 为客户提供了简单的数据模型，利用这个模型，客户可以动态控制数据的分布和格式，用户也可以自己推测底层存储数据的位置相关性。数据的下标是行和列的名字，名字可以是任意的字符串。Bigtable 将存储的数据都视为字符串，但是 Bigtable 本身不去解析这些字符串，客户程序通常会在把各种结构化或者半结构化的数据串行化到这些字符串里。通过仔细选择数据的模式，客户可以控制数据的位置相关性。最后，可以通过 BigTable 的模式参数来控制数据是存放在内存中还是硬盘上。 第 3 节描述关于数据模型更多细节方面的东西; 第 4 节概要介绍了客户端 API; 第 5 节简要介绍了 BigTable 底层使用的 Google 的基础框架; 第 6 节描述了 BigTable 实现的关键部分; 第 7 节描述了我们为了提高 BigTable 的性能采用的一些精细的调优方法; 第 8 节提供了 BigTable 的性能数据; 第 9 节讲述了几个 Google 内部使用 BigTable 的例子; 第 10 节是我们在设计和后期支持过程中得到一些经验和教训; 最后，在第 11 节列出我们的相关研究工作，第 12 节是我们的结论。数据模型Bigtable 是一个稀疏的、分布式的、持久化存储的多维度排序 Map。Map 的索引是行关键字、列关键字以及时间戳;Map 中的每个 value 都是一个未经解析的 byte 数组。(row:string, column:string,time:int64)-&gt;string我们在仔细分析了一个类似 Bigtable 的系统的种种潜在用途之后，决定使用这个数据模型。我们先举个具体的例子，这个例子促使我们做了很多设计决策;假设我们想要存储海量的网页及相关信息，这些数据可以用于很多不同的项目，我们姑且称这个特殊的表为 Webtable。在 Webtable 里，我们使用 URL 作为行关键字，使用网页的某些属性作为列名，网页的内容存在“contents:”列中，并用获取该网页的时间戳作为标识,如图一所示。行名是一个反向 URL。contents 列族存放的是网页的内容，anchor 列族存放引用该网页的锚链接文本。 CNN 的主页被 Sports Illustrator 和 MY-look 的主页引用，因此该行包含了名为“anchor:cnnsi.com”和 “anchhor:my.look.ca”的列。每个锚链接只有一个版本;而 contents 列则有三个版本，分别由时间戳 t3，t5，和 t6 标识。 行表中的行关键字可以是任意的字符串(目前支持最大 64KB 的字符串，但是对大多数用户，10-100 个字 节就足够了)。对同一个行关键字的读或者写操作都是原子的(不管读或者写这一行里多少个不同列)，这个 设计决策能够使用户很容易的理解程序在对同一个行进行并发更新操作时的行为。 Bigtable 通过行关键字的字典顺序来组织数据。表中的每个行都可以动态分区。每个分区叫做一个”Tablet”， Tablet 是数据分布和负载均衡调整的最小单位。这样做的结果是，当操作只读取行中很少几列的数据时效率很 高，通常只需要很少几次机器间的通信即可完成。用户可以通过选择合适的行关键字，在数据访问时有效利 用数据的位置相关性，从而更好的利用这个特性。举例来说，在 Webtable 里，通过反转 URL 中主机名的方 式，可以把同一个域名下的网页聚集起来组织成连续的行。具体来说，我们可以把 maps.google.com/index.html 的数据存放在关键字 com.google.maps/index.html 下。把相同的域中的网页存储在连续的区域可以让基于主机 和域名的分析更加有效。 列族列关键字组成的集合叫做“列族“，列族是访问控制的基本单位。存放在同一列族下的所有数据通常都 属于同一个类型(我们可以把同一个列族下的数据压缩在一起)。列族在使用之前必须先创建，然后才能在列 族中任何的列关键字下存放数据;列族创建后，其中的任何一个列关键字下都可以存放数据。根据我们的设 计意图，一张表中的列族不能太多(最多几百个)，并且列族在运行期间很少改变。与之相对应的，一张表可 以有无限多个列。 列关键字的命名语法如下:列族:限定词。 列族的名字必须是可打印的字符串，而限定词的名字可以是 任意的字符串。比如，Webtable 有个列族 language，language 列族用来存放撰写网页的语言。我们在 language 列族中只使用一个列关键字，用来存放每个网页的语言标识 ID。Webtable 中另一个有用的列族是 anchor;这 个列族的每一个列关键字代表一个锚链接，如图一所示。Anchor 列族的限定词是引用该网页的站点名;Anchor 列族每列的数据项存放的是链接文本。 访问控制、磁盘和内存的使用统计都是在列族层面进行的。在我们的 Webtable 的例子中，上述的控制权 限能帮助我们管理不同类型的应用:我们允许一些应用可以添加新的基本数据、一些应用可以读取基本数据并创建继承的列族、一些应用则只允许浏览数据(甚至可能因为隐私的原因不能浏览所有数据)。 时间戳在 Bigtable 中，表的每一个数据项都可以包含同一份数据的不同版本;不同版本的数据通过时间戳来索 引。Bigtable 时间戳的类型是 64 位整型。Bigtable 可以给时间戳赋值，用来表示精确到毫秒的“实时”时间; 用户程序也可以给时间戳赋值。如果应用程序需要避免数据版本冲突，那么它必须自己生成具有唯一性的时 间戳。数据项中，不同版本的数据按照时间戳倒序排序，即最新的数据排在最前面。 为了减轻多个版本数据的管理负担，我们对每一个列族配有两个设置参数，Bigtable 通过这两个参数可以 对废弃版本的数据自动进行垃圾收集。用户可以指定只保存最后 n 个版本的数据，或者只保存“足够新”的 版本的数据(比如，只保存最近 7 天的内容写入的数据)。 在 Webtable 的举例里，contents:列存储的时间戳信息是网络爬虫抓取一个页面的时间。上面提及的垃圾 收集机制可以让我们只保留最近三个版本的网页数据。APIBigtable 提供了建立和删除表以及列族的 API 函数。Bigtable 还提供了修改集群、表和列族的元数据的 API ，比如修改访问权限。 // Open the table Table *T = OpenOrDie(“/bigtable/web/webtable”); // Write a new anchor and delete an old anchor RowMutation r1(T, “com.cnn.www”); r1.Set(“anchor:www.c-span.org”, “CNN”); r1.Delete(“anchor:www.abc.com”); Operation op; Apply(&amp;op, &amp;r1); 客户程序可以对 Bigtable 进行如下的操作:写入或者删除 Bigtable 中的值、从每个行中查找值、或者遍历表中的一个数据子集。图 2 中的C++代码使用 RowMutation 抽象对象进行了一系列的更新操作。(为了保持 示例代码的简洁，我们忽略了一些细节相关代码)。调用 Apply 函数对Webtable 进行了一个原子修改操作:它为 www.cnn.com 增加了一个锚点，同时删除了另外一个锚点。 Scanner scanner(T); ScanStream *stream; stream = scanner.FetchColumnFamily(“anchor”); stream-&gt;SetReturnAllVersions(); scanner.Lookup(“com.cnn.www”); for (; !stream-&gt;Done(); stream-&gt;Next()) { printf(“%s %s %lld %s\\n”, scanner.RowName(), stream-&gt;ColumnName(), stream-&gt;MicroTimestamp(), stream-&gt;Value()); } 图表 3 Reading from Bigtable.图 3 中的 C++代码使用 Scanner 抽象对象遍历一个行内的所有锚点。客户程序可以遍历多个列族，有几种方法可以对扫描输出的行、列和时间戳进行限制。例如，我们可以限制上面的扫描，让它只输出那些匹配 正则表达式*.cnn.com 的锚点，或者那些时间戳在当前时间前 10 天的锚点。 Bigtable 还支持一些其它的特性，利用这些特性，用户可以对数据进行更复杂的处理。首先，Bigtable 支 持单行上的事务处理，利用这个功能，用户可以对存储在一个行关键字下的数据进行原子性的读-更新-写操作。 虽然 Bigtable 提供了一个允许用户跨行批量写入数据的接口，但是，Bigtable 目前还不支持通用的跨行事务处 理。其次，Bigtable 允许把数据项用做整数计数器。最后，Bigtable 允许用户在服务器的地址空间内执行脚本 程序。脚本程序使用 Google 开发的 Sawzall数据处理语言。虽然目前我们基于的 Sawzall 语言的 API 函数还不允许客户的脚本程序写入数据到 Bigtable，但是它允许多种形式的数据转换、基于任意表达式的数据 过滤、以及使用多种操作符的进行数据汇总。 Bigtable 可以和 MapReduce 一起使用，MapReduce 是 Google 开发的大规模并行计算框架。我们已 经开发了一些 Wrapper 类，通过使用这些 Wrapper 类，Bigtable 可以作为 MapReduce 框架的输入和输出。BigTable 构件Bigtable是建立在其它的几个Google基础构件上的。BigTable使用Google的分布式文件系统(GFS存储日志文件和数据文件。BigTable 集群通常运行在一个共享的机器池中，池中的机器还会运行其它的各种各样的分布式应用程序，BigTable 的进程经常要和其它应用的进程共享机器。BigTable 依赖集群管理系统来调度任务、管理共享的机器上的资源、处理机器的故障、以及监视机器的状态。 BigTable 内部存储数据的文件是 Google SSTable 格式的。SSTable 是一个持久化的、排序的、不可更改的 Map 结构，而 Map 是一个 key-value 映射的数据结构，key 和 value 的值都是任意的 Byte 串。可以对 SSTable 进行如下的操作:查询与一个 key 值相关的 value，或者遍历某个 key 值范围内的所有的 key-value 对。从内 部看，SSTable 是一系列的数据块(通常每个块的大小是 64KB，这个大小是可以配置的)。SSTable 使用块索 引(通常存储在 SSTable 的最后)来定位数据块;在打开 SSTable 的时候，索引被加载到内存。每次查找都可 以通过一次磁盘搜索完成:首先使用二分查找法在内存中的索引里找到数据块的位置，然后再从硬盘读取相 应的数据块。也可以选择把整个 SSTable 都放在内存中，这样就不必访问硬盘了。 BigTable 还依赖一个高可用的、序列化的分布式锁服务组件，叫做 Chubby【8】。一个 Chubby 服务包括 了 5 个活动的副本，其中的一个副本被选为 Master，并且处理请求。只有在大多数副本都是正常运行的，并 且彼此之间能够互相通信的情况下，Chubby 服务才是可用的。当有副本失效的时候，Chubby 使用 Paxos 算法 【9,23】来保证副本的一致性。Chubby 提供了一个名字空间，里面包括了目录和小文件。每个目录或者文件 可以当成一个锁，读写文件的操作都是原子的。Chubby 客户程序库提供对 Chubby 文件的一致性缓存。每个 Chubby 客户程序都维护一个与 Chubby 服务的会话。如果客户程序不能在租约到期的时间内重新签订会话的 租约，这个会话就过期失效了9。当一个会话失效时，它拥有的锁和打开的文件句柄都失效了。Chubby 客户 程序可以在文件和目录上注册回调函数，当文件或目录改变、或者会话过期时，回调函数会通知客户程序。 Bigtable 使用 Chubby 完成以下的几个任务: 确保在任何给定的时间内最多只有一个活动的 Master 副本; 存储 BigTable 数据的自引导指令的位置(参考 5.1 节); 查找 Tablet 服务器，以及在 Tablet 服务器失效时进行善后(5.2 节); 存储 BigTable 的模式信息(每张表的列族信息); 以及存储访问控制列表。 如果 Chubby 长时间无法访问，BigTable 就会失效。最近我们在使用 11 个 Chubby 服务实例的 14 个 BigTable集群上测量了这个影响。由于 Chubby 不可用而导致 BigTable 中的部分数据不能访问的平均比率是 0.0047% (Chubby 不能访问的原因可能是 Chubby 本身失效或者网络问题)。单个集群里，受 Chubby 失效影响最大的 百分比是 0.0326%10。介绍Bigtable 包括了三个主要的组件:链接到客户程序中的库、一个 Master 服务器和多个 Tablet 服务器。针 对系统工作负载的变化情况，BigTable 可以动态的向集群中添加(或者删除)Tablet 服务器。 Master 服务器主要负责以下工作:为 Tablet 服务器分配 Tablets、检测新加入的或者过期失效的 Table 服 务器、对 Tablet 服务器进行负载均衡、以及对保存在 GFS 上的文件进行垃圾收集。除此之外，它还处理对模 式的相关修改操作，例如建立表和列族。 每个 Tablet 服务器都管理一个 Tablet 的集合(通常每个服务器有大约数十个至上千个 Tablet)。每个 Tablet 服务器负责处理它所加载的 Tablet 的读写操作，以及在 Tablets 过大时，对其进行分割。 和很多 Single-Master 类型的分布式存储系统【17.21】类似，客户端读取的数据都不经过 Master 服务器: 客户程序直接和 Tablet 服务器通信进行读写操作。由于 BigTable 的客户程序不必通过 Master 服务器来获取 Tablet 的位置信息，因此，大多数客户程序甚至完全不需要和 Master 服务器通信。在实际应用中，Master 服 务器的负载是很轻的。 一个 BigTable 集群存储了很多表，每个表包含了一个 Tablet 的集合，而每个 Tablet 包含了某个范围内的 行的所有相关数据。初始状态下，一个表只有一个 Tablet。随着表中数据的增长，它被自动分割成多个 Tablet， 缺省情况下，每个 Tablet 的尺寸大约是 100MB 到 200MB。 Tablet 的位置我们使用一个三层的、类似B+树[10]的结构存储 Tablet 的位置信息(如图 4)。第一层是一个存储在 Chubby 中的文件，它包含了 Root Tablet 的位置信息。Root Tablet 包含了一个特殊 的 METADATA 表里所有的 Tablet 的位置信息。METADATA 表的每个 Tablet 包含了一个用户 Tablet 的集合。 Root Tablet 实际上是 METADATA 表的第一个 Tablet，只不过对它的处理比较特殊 — Root Tablet 永远不会被 分割 — 这就保证了 Tablet 的位置信息存储结构不会超过三层。 在 METADATA 表里面，每个 Tablet 的位置信息都存放在一个行关键字下面，而这个行关键字是由 Tablet 所在的表的标识符和 Tablet 的最后一行编码而成的。METADATA 的每一行都存储了大约 1KB 的内存数据。 在一个大小适中的、容量限制为 128MB 的 METADATA Tablet 中，采用这种三层结构的存储模式，可以标识 2^34 个 Tablet 的地址(如果每个 Tablet 存储 128MB 数据，那么一共可以存储 2^61 字节数据)。 客户程序使用的库会缓存 Tablet 的位置信息。如果客户程序没有缓存某个 Tablet 的地址信息，或者发现 它缓存的地址信息不正确，客户程序就在树状的存储结构中递归的查询 Tablet 位置信息;如果客户端缓存是 空的，那么寻址算法需要通过三次网络来回通信寻址，这其中包括了一次 Chubby 读操作;如果客户端缓存的 地址信息过期了，那么寻址算法可能需要最多6次网络来回通信才能更新数据，因为只有在缓存中没有查到 数据的时候才能发现数据过期11。尽管 Tablet 的地址信息是存放在内存里的，对它的操作不必访问 GFS 文件 系统，但是，通常我们会通过预取 Tablet 地址来进一步的减少访问的开销:每次需要从 METADATA 表中读取一个 Tablet 的元数据的时候，它都会多读取几个 Tablet 的元数据。 在 METADATA 表中还存储了次级信息12，包括每个 Tablet 的事件日志(例如，什么时候一个服务器开始为该 Tablet 提供服务)。这些信息有助于排查错误和性能分析。 Tablet 分配在任何一个时刻，一个 Tablet 只能分配给一个 Tablet 服务器。Master 服务器记录了当前有哪些活跃的 Tablet 服务器、哪些 Tablet 分配给了哪些 Tablet 服务器、哪些 Tablet 还没有被分配。当一个 Tablet 还没有被分配、 并且刚好有一个 Tablet 服务器有足够的空闲空间装载该 Tablet 时，Master 服务器会给这个 Tablet 服务器发送 一个装载请求，把 Tablet 分配给这个服务器。 BigTable 使用 Chubby 跟踪记录 Tablet 服务器的状态。当一个 Tablet 服务器启动时，它在 Chubby 的一个 指定目录下建立一个有唯一性名字的文件，并且获取该文件的独占锁。Master 服务器实时监控着这个目录(服 务器目录)，因此 Master 服务器能够知道有新的 Tablet 服务器加入了。如果 Tablet 服务器丢失了 Chubby 上的 独占锁 — 比如由于网络断开导致 Tablet 服务器和 Chubby 的会话丢失 — 它就停止对 Tablet 提供服务。 (Chubby 提供了一种高效的机制，利用这种机制，Tablet 服务器能够在不增加网络负担的情况下知道它是否 还持有锁)。只要文件还存在，Tablet 服务器就会试图重新获得对该文件的独占锁;如果文件不存在了，那么 Tablet 服务器就不能再提供服务了，它会自行退出13。当 Tablet 服务器终止时(比如，集群的管理系统将运行 该 Tablet 服务器的主机从集群中移除)，它会尝试释放它持有的文件锁，这样一来，Master 服务器就能尽快把 Tablet 分配到其它的 Tablet 服务器。 Master 服务器负责检查一个 Tablet 服务器是否已经不再为它的 Tablet 提供服务了，并且要尽快重新分配 它加载的 Tablet。Master 服务器通过轮询 Tablet 服务器文件锁的状态来检测何时 Tablet 服务器不再为 Tablet 提供服务。如果一个 Tablet 服务器报告它丢失了文件锁，或者 Master 服务器最近几次尝试和它通信都没有得到响应，Master 服务器就会尝试获取该 Tablet 服务器文件的独占锁;如果 Master 服务器成功获取了独占锁， 那么就说明 Chubby 是正常运行的，而 Tablet 服务器要么是宕机了、要么是不能和 Chubby 通信了，因此，Master 服务器就删除该 Tablet 服务器在 Chubby 上的服务器文件以确保它不再给 Tablet 提供服务。一旦 Tablet 服务器 在 Chubby 上的服务器文件被删除了，Master 服务器就把之前分配给它的所有的 Tablet 放入未分配的 Tablet 集合中。为了确保 Bigtable 集群在 Master 服务器和 Chubby 之间网络出现故障的时候仍然可以使用，Master 服务器在它的 Chubby 会话过期后主动退出。但是不管怎样，如同我们前面所描述的，Master 服务器的故障不 会改变现有 Tablet 在 Tablet 服务器上的分配状态。 当集群管理系统启动了一个 Master 服务器之后，Master 服务器首先要了解当前 Tablet 的分配状态，之后 才能够修改分配状态。Master 服务器在启动的时候执行以下步骤: Master 服务器从 Chubby 获取一个唯一的 Master 锁，用来阻止创建其它的 Master 服务器实例; Master 服务器扫描 Chubby 的服务器文件锁存储目录，获取当前正在运行的服务器列表; Master 服务器和所有的正在运行的 Tablet 表服务器通信，获取每个 Tablet 服务器上 Tablet 的分配信息; Master 服务器扫描 METADATA 表获取所有的 Tablet 的集合。 在扫描的过程中，当 Master 服务器发现了一个还没有分配的 Tablet，Master 服务器就将这个 Tablet 加入未分配的 Tablet 集合等待合适的时机分配。 可能会遇到一种复杂的情况:在 METADATA 表的 Tablet 还没有被分配之前是不能够扫描它的。因此，在开始扫描之前(步骤 4)，如果在第三步的扫描过程中发现 Root Tablet 还没有分配，Master 服务器就把 Root Tablet 加入到未分配的 Tablet 集合。这个附加操作确保了 Root Tablet 会被分配。由于 Root Tablet 包括了所有 METADATA 的 Tablet 的名字，因此 Master 服务器扫描完 Root Tablet 以后，就得到了所有的 METADATA 表 的 Tablet 的名字了。 保存现有 Tablet 的集合只有在以下事件发生时才会改变:建立了一个新表或者删除了一个旧表、两个 Tablet 被合并了、或者一个 Tablet 被分割成两个小的 Tablet。Master 服务器可以跟踪记录所有这些事件，因为 除了最后一个事件外的两个事件都是由它启动的。Tablet 分割事件需要特殊处理，因为它是由 Tablet 服务器启 动。在分割操作完成之后，Tablet 服务器通过在 METADATA 表中记录新的 Tablet 的信息来提交这个操作;当 分割操作提交之后，Tablet 服务器会通知 Master 服务器。如果分割操作已提交的信息没有通知到 Master 服务 器(可能两个服务器中有一个宕机了)，Master 服务器在要求 Tablet 服务器装载已经被分割的子表的时候会发现一个新的 Tablet。通过对比 METADATA 表中 Tablet 的信息，Tablet 服务器会发现 Master 服务器要求其装载的 Tablet 并不完整，因此，Tablet 服务器会重新向 Master 服务器发送通知信息。 Tablet 服务如图 5 所示，Tablet 的持久化状态信息保存在 GFS 上。更新操作提交到 REDO 日志中14。在这些更新操 作中，最近提交的那些存放在一个排序的缓存中，我们称这个缓存为 memtable;较早的更新存放在一系列 SSTable 中。为了恢复一个 Tablet，Tablet 服务器首先从 METADATA 表中读取它的元数据。Tablet 的元数据包 含了组成这个 Tablet 的 SSTable 的列表，以及一系列的 Redo Point15，这些 Redo Point 指向可能含有该 Tablet 数据的已提交的日志记录。Tablet 服务器把 SSTable 的索引读进内存，之后通过重复 Redo Point 之后提交的更 新来重建 memtable。 当对 Tablet 服务器进行写操作时，Tablet 服务器首先要检查这个操作格式是否正确、操作发起者是否有执 行这个操作的权限。权限验证的方法是通过从一个 Chubby 文件里读取出来的具有写权限的操作者列表来进行 验证(这个文件几乎一定会存放在 Chubby 客户缓存里)。成功的修改操作会记录在提交日志里。可以采用批 量提交方式16来提高包含大量小的修改操作的应用程序的吞吐量【13，16】。当一个写操作提交后，写的内容 插入到 memtable 里面。 当对 Tablet 服务器进行读操作时，Tablet 服务器会作类似的完整性和权限检查。一个有效的读操作在一个 由一系列 SSTable 和 memtable 合并的视图里执行。由于 SSTable 和 memtable 是按字典排序的数据结构，因此 可以高效生成合并视图。 当进行 Tablet 的合并和分割时，正在进行的读写操作能够继续进行。 空间收缩随着写操作的执行，memtable 的大小不断增加。当 memtable 的尺寸到达一个门限值的时候，这个 memtable 就会被冻结，然后创建一个新的 memtable;被冻结住 memtable 会被转换成 SSTable，然后写入 GFS18。Minor Compaction 过程有两个目的:shrink 19Tablet 服务器使用的内存，以及在服务器灾难恢复过程中，减少必须从 提交日志里读取的数据量。在 Compaction 过程中，正在进行的读写操作仍能继续。 每一次 Minor Compaction 都会创建一个新的 SSTable。如果 Minor Compaction 过程不停滞的持续进行下 去，读操作可能需要合并来自多个 SSTable 的更新;否则，我们通过定期在后台执行 Merging Compaction 过 程合并文件，限制这类文件的数量。Merging Compaction 过程读取一些 SSTable 和 memtable 的内容，合并成 一个新的 SSTable。只要 Merging Compaction 过程完成了，输入的这些 SSTable 和 memtable 就可以删除了。 合并所有的 SSTable 并生成一个新的 SSTable 的 Merging Compaction 过程叫作 Major Compaction。由非 Major Compaction 产生的 SSTable 可能含有特殊的删除条目，这些删除条目能够隐藏在旧的、但是依然有效的 SSTable 中已经删除的数据20。而 Major Compaction 过程生成的 SSTable 不包含已经删除的信息或数据。Bigtable 循环扫描它所有的 Tablet，并且定期对它们执行 Major Compaction。Major Compaction 机制允许 Bigtable 回收 已经删除的数据占有的资源，并且确保 BigTable 能及时清除已经删除的数据21，这对存放敏感数据的服务是 非常重要。优化上一章我们描述了 Bigtable 的实现，我们还需要很多优化工作才能使 Bigtable 到达用户要求的高性能、 高可用性和高可靠性。本章描述了 Bigtable 实现的其它部分，为了更好的强调这些优化工作，我们将深入细 节。 局部性群组客户程序可以将多个列族组合成一个局部性群族。对 Tablet 中的每个局部性群组都会生成一个单独的SSTable。将通常不会一起访问的列族分割成不同的局部性群组可以提高读取操作的效率。例如，在 Webtable表中，网页的元数据(比如语言和 Checksum)可以在一个局部性群组中，网页的内容可以在另外一个群组: 当一个应用程序要读取网页的元数据的时候，它没有必要去读取所有的页面内容。 此外，可以以局部性群组为单位设定一些有用的调试参数。比如，可以把一个局部性群组设定为全部存 储在内存中。Tablet 服务器依照惰性加载的策略将设定为放入内存的局部性群组的 SSTable 装载进内存。加载 完成之后，访问属于该局部性群组的列族的时候就不必读取硬盘了。这个特性对于需要频繁访问的小块数据 特别有用:在 Bigtable 内部，我们利用这个特性提高 METADATA 表中具有位置相关性的列族的访问速度。 压缩客户程序可以控制一个局部性群组的 SSTable 是否需要压缩;如果需要压缩，那么以什么格式来压缩。 每个 SSTable 的块(块的大小由局部性群组的优化参数指定)都使用用户指定的压缩格式来压缩。虽然分块 压缩浪费了少量空间22，但是，我们在只读取 SSTable 的一小部分数据的时候就不必解压整个文件了。很多客 户程序使用了“两遍”的、可定制的压缩方式。第一遍采用 Bentley and McIlroy’s 方式[6]，这种方式在一个 很大的扫描窗口里对常见的长字符串进行压缩;第二遍是采用快速压缩算法，即在一个 16KB 的小扫描窗口 中寻找重复数据。两个压缩的算法都很快，在现在的机器上，压缩的速率达到 100-200MB/s，解压的速率达 到 400-1000MB/s。 虽然我们在选择压缩算法的时候重点考虑的是速度而不是压缩的空间，但是这种两遍的压缩方式在空间 压缩率上的表现也是令人惊叹。比如，在 Webtable 的例子里，我们使用这种压缩方式来存储网页内容。在一 次测试中，我们在一个压缩的局部性群组中存储了大量的网页。针对实验的目的，我们没有存储每个文档所 有版本的数据，我们仅仅存储了一个版本的数据。该模式的空间压缩比达到了 10:1。这比传统的 Gzip 在压缩 HTML 页面时 3:1 或者 4:1 的空间压缩比好的多;“两遍”的压缩模式如此高效的原因是由于 Webtable 的行的 存放方式:从同一个主机获取的页面都存在临近的地方。利用这个特性，Bentley-McIlroy 算法可以从来自同 一个主机的页面里找到大量的重复内容。不仅仅是 Webtable，其它的很多应用程序也通过选择合适的行名来 将相似的数据聚簇在一起，以获取较高的压缩率。当我们在 Bigtable 中存储同一份数据的多个版本的时候， 压缩效率会更高。 通过缓存提高读操作的性能为了提高读操作的性能，Tablet 服务器使用二级缓存的策略。扫描缓存是第一级缓存，主要缓存 Tablet服务器通过 SSTable 接口获取的 Key-Value 对;Block 缓存是二级缓存，缓存的是从 GFS 读取的 SSTable 的 Block。对于经常要重复读取相同数据的应用程序来说，扫描缓存非常有效;对于经常要读取刚刚读过的数据 附近的数据的应用程序来说，Block 缓存更有用(例如，顺序读，或者在一个热点的行的局部性群组中随机读取不同的列)。 Bloom 过滤器如 6.3 节所述，一个读操作必须读取构成 Tablet 状态的所有 SSTable 的数据。如果这些 SSTable 不在内存 中，那么就需要多次访问硬盘。我们通过允许客户程序对特定局部性群组的 SSTable 指定 Bloom 过滤器【7】， 来减少硬盘访问的次数。我们可以使用 Bloom 过滤器查询一个 SSTable 是否包含了特定行和列的数据。对于 某些特定应用程序，我们只付出了少量的、用于存储 Bloom 过滤器的内存的代价，就换来了读操作显著减少 的磁盘访问的次数。使用 Bloom 过滤器也隐式的达到了当应用程序访问不存在的行或列时，大多数时候我们 都不需要访问硬盘的目的。 Commit 日志的实现如果我们把对每个 Tablet 的操作的 Commit 日志都存在一个单独的文件的话，那么就会产生大量的文件， 并且这些文件会并行的写入 GFS。根据 GFS 服务器底层文件系统实现的方案，要把这些文件写入不同的磁盘 日志文件时24，会有大量的磁盘 Seek 操作。另外，由于批量提交25中操作的数目一般比较少，因此，对每个 Tablet 设置单独的日志文件也会给批量提交本应具有的优化效果带来很大的负面影响。为了避免这些问题，我 们设置每个 Tablet 服务器一个 Commit 日志文件，把修改操作的日志以追加方式写入同一个日志文件，因此 一个实际的日志文件中混合了对多个 Tablet 修改的日志记录。 使用单个日志显著提高了普通操作的性能，但是将恢复的工作复杂化了。当一个 Tablet 服务器宕机时， 它加载的 Tablet 将会被移到很多其它的 Tablet 服务器上:每个 Tablet 服务器都装载很少的几个原来的服务器 的 Tablet。当恢复一个 Tablet 的状态的时候，新的 Tablet 服务器要从原来的 Tablet 服务器写的日志中提取修改 操作的信息，并重新执行。然而，这些 Tablet 修改操作的日志记录都混合在同一个日志文件中的。一种方法 新的 Tablet 服务器读取完整的 Commit 日志文件，然后只重复执行它需要恢复的 Tablet 的相关修改操作。使 用这种方法，假如有 100 台 Tablet 服务器，每台都加载了失效的 Tablet 服务器上的一个 Tablet，那么，这个日 志文件就要被读取 100 次(每个服务器读取一次)。 为了避免多次读取日志文件，我们首先把日志按照关键字(table，row name，log sequence number)排序。 排序之后，对同一个 Tablet 的修改操作的日志记录就连续存放在了一起，因此，我们只要一次磁盘 Seek 操作、之后顺序读取就可以了。为了并行排序，我们先将日志分割成 64MB 的段，之后在不同的 Tablet 服务器对段 进行并行排序。这个排序工作由 Master 服务器来协同处理，并且在一个 Tablet 服务器表明自己需要从 Commit 日志文件恢复 Tablet 时开始执行。 在向 GFS 中写 Commit 日志的时候可能会引起系统颠簸，原因是多种多样的(比如，写操作正在进行的时候，一个 GFS 服务器宕机了;或者连接三个 GFS 副本所在的服务器的网络拥塞或者过载了)。为了确保在 GFS 负载高峰时修改操作还能顺利进行，每个 Tablet 服务器实际上有两个日志写入线程，每个线程都写自己 的日志文件，并且在任何时刻，只有一个线程是工作的。如果一个线程的在写入的时候效率很低，Tablet 服务 器就切换到另外一个线程，修改操作的日志记录就写入到这个线程对应的日志文件中。每个日志记录都有一 个序列号，因此，在恢复的时候，Tablet 服务器能够检测出并忽略掉那些由于线程切换而导致的重复的记录。 Tablet 恢复提速当 Master 服务器将一个 Tablet 从一个 Tablet 服务器移到另外一个 Tablet 服务器时，源 Tablet 服务器会对 这个 Tablet 做一次 Minor Compaction。这个 Compaction 操作减少了 Tablet 服务器的日志文件中没有归并的记 录，从而减少了恢复的时间。Compaction 完成之后，该服务器就停止为该 Tablet 提供服务。在卸载 Tablet 之 前，源 Tablet 服务器还会再做一次(通常会很快)Minor Compaction，以消除前面在一次压缩过程中又产生的 未归并的记录。第二次 Minor Compaction 完成以后，Tablet 就可以被装载到新的 Tablet 服务器上了，并且不 需要从日志中进行恢复。 利用不变性我们在使用 Bigtable 时，除了 SSTable 缓存之外的其它部分产生的 SSTable 都是不变的，我们可以利用这 一点对系统进行简化。例如，当从 SSTable 读取数据的时候，我们不必对文件系统访问操作进行同步。这样 一来，就可以非常高效的实现对行的并行操作。memtable 是唯一一个能被读和写操作同时访问的可变数据结 构。为了减少在读操作时的竞争，我们对内存表采用 COW(Copy-on-write)机制，这样就允许读写操作并行执 行。 因为 SSTable 是不变的，因此，我们可以把永久删除被标记为“删除”的数据的问题，转换成对废弃的 SSTable 进行垃圾收集的问题了。每个 Tablet 的 SSTable 都在 METADATA 表中注册了。Master 服务器采用“标 记-删除”的垃圾回收方式删除 SSTable 集合中废弃的 SSTable【25】，METADATA 表则保存了 Root SSTable 的集合。 最后，SSTable 的不变性使得分割 Tablet 的操作非常快捷。我们不必为每个分割出来的 Tablet 建立新的 SSTable 集合，而是共享原来的 Tablet 的 SSTable 集合。性能评估为了测试 Bigtable 的性能和可扩展性，我们建立了一个包括 N 台 Tablet 服务器的 Bigtable 集群，这里 N 是可变的。每台 Tablet 服务器配置了 1GB 的内存，数据写入到一个包括 1786 台机器、每台机器有 2 个 IDE 硬盘的 GFS 集群上。我们使用 N 台客户机生成工作负载测试 Bigtable。(我们使用和 Tablet 服务器相同数目的 客户机以确保客户机不会成为瓶颈。) 每台客户机配置 2GZ 双核 Opteron 处理器，配置了足以容纳所有进程 工作数据集的物理内存，以及一张 Gigabit 的以太网卡。这些机器都连入一个两层的、树状的交换网络里，在 根节点上的带宽加起来有大约 100-200Gbps。所有的机器采用相同的设备，因此，任何两台机器间网络来回一 次的时间都小于 1ms。 Tablet 服务器、Master 服务器、测试机、以及 GFS 服务器都运行在同一组机器上。每台机器都运行一个 GFS 的服务器。其它的机器要么运行 Tablet 服务器、要么运行客户程序、要么运行在测试过程中，使用这组 机器的其它的任务启动的进程。 R 是测试过程中，Bigtable 包含的不同的列关键字的数量。我们精心选择 R 的值，保证每次基准测试对每 台 Tablet 服务器读/写的数据量都在 1GB 左右。 在序列写的基准测试中，我们使用的列关键字的范围是 0 到 R-1。这个范围又被划分为 10N 个大小相同 的区间。核心调度程序把这些区间分配给 N 个客户端，分配方式是:只要客户程序处理完上一个区间的数据， 调度程序就把后续的、尚未处理的区间分配给它。这种动态分配的方式有助于减少客户机上同时运行的其它 进程对性能的影响。我们在每个列关键字下写入一个单独的字符串。每个字符串都是随机生成的、因此也没 有被压缩26。另外，不同列关键字下的字符串也是不同的，因此也就不存在跨行的压缩。随机写入基准测试采 用类似的方法，除了行关键字在写入前先做 Hash，Hash 采用按 R 取模的方式，这样就保证了在整个基准测 试持续的时间内，写入的工作负载均匀的分布在列存储空间内。 序列读的基准测试生成列关键字的方式与序列写相同，不同于序列写在列关键字下写入字符串的是，序 列读是读取列关键字下的字符串(这些字符串由之前序列写基准测试程序写入)。同样的，随机读的基准测试 和随机写是类似的。 扫描基准测试和序列读类似，但是使用的是 BigTable 提供的、从一个列范围内扫描所有的 value 值的 API。 由于一次 RPC 调用就从一个 Tablet 服务器取回了大量的 Value 值，因此，使用扫描方式的基准测试程序可以 减少 RPC 调用的次数。 随机读(内存)基准测试和随机读类似，除了包含基准测试数据的局部性群组被设置为“in-memory”， 因此，读操作直接从 Tablet 服务器的内存中读取数据，不需要从 GFS 读取数据。针对这个测试，我们把每台Tablet 服务器存储的数据从 1GB 减少到 100MB，这样就可以把数据全部加载到 Tablet 服务器的内存中了。图 6 中有两个视图，显示了我们的基准测试的性能;图中的数据和曲线是读/写 1000-byte value 值时取得 的。图中的表格显示了每个 Tablet 服务器每秒钟进行的操作的次数;图中的曲线显示了每秒种所有的 Tablet 服务器上操作次数的总和。 单个 Tablet 服务器的性能我们首先分析下单个 Tablet 服务器的性能。随机读的性能比其它操作慢一个数量级或以上27。 每个随机 读操作都要通过网络从 GFS 传输 64KB 的 SSTable 到 Tablet 服务器，而我们只使用其中大小是 1000 byte 的一 个 value 值。Tablet 服务器每秒大约执行 1200 次读操作，也就是每秒大约从 GFS 读取 75MB 的数据。这个传 输带宽足以占满 Tablet 服务器的 CPU 时间，因为其中包括了网络协议栈的消耗、SSTable 解析、以及 BigTable 代码执行;这个带宽也足以占满我们系统中网络的链接带宽。大多数采用这种访问模式 BigTable 应用程序会 减小 Block 的大小，通常会减到 8KB。 内存中的随机读操作速度快很多，原因是，所有 1000-byte 的读操作都是从 Tablet 服务器的本地内存中读 取数据，不需要从 GFS 读取 64KB 的 Block。 随机和序列写操作的性能比随机读要好些，原因是每个 Tablet 服务器直接把写入操作的内容追加到一个 Commit 日志文件的尾部，并且采用批量提交的方式，通过把数据以流的方式写入到 GFS 来提高性能。随机 写和序列写在性能上没有太大的差异，这两种方式的写操作实际上都是把操作内容记录到同一个 Tablet 服务 器的 Commit 日志文件中。 序列读的性能好于随机读，因为每取出 64KB 的 SSTable 的 Block 后，这些数据会缓存到 Block 缓存中， 后续的 64 次读操作直接从缓存读取数据。 扫描的性能更高，这是由于客户程序每一次 RPC 调用都会返回大量的 value 的数据，所以，RPC 调用的 消耗基本抵消了。 性能提升随着我们将系统中的 Tablet 服务器从 1 台增加到 500 台，系统的整体吞吐量有了梦幻般的增长，增长的 倍率超过了 100。比如，随着 Tablet 服务器的数量增加了 500 倍，内存中的随机读操作的性能增加了 300 倍。 之所以会有这样的性能提升，主要是因为这个基准测试的瓶颈是单台 Tablet 服务器的 CPU。 尽管如此，性能的提升还不是线性的。在大多数的基准测试中我们看到，当 Tablet 服务器的数量从 1 台 增加到 50 台时，每台服务器的吞吐量会有一个明显的下降。这是由于多台服务器间的负载不均衡造成的，大 多数情况下是由于其它的程序抢占了 CPU。 我们负载均衡的算法会尽量避免这种不均衡，但是基于两个主要 原因，这个算法并不能完美的工作:一个是尽量减少 Tablet 的移动导致重新负载均衡能力受限(如果 Tablet 被移动了，那么在短时间内 — 一般是 1 秒内 — 这个 Tablet 是不可用的)，另一个是我们的基准测试程序产 生的负载会有波动28。 随机读基准测试的测试结果显示，随机读的性能随 Tablet 服务器数量增加的提升幅度最小(整体吞吐量 只提升了 100 倍，而服务器的数量却增加了 500 倍)。这是因为每个 1000-byte 的读操作都会导致一个 64KB 大的 Block 在网络上传输。这样的网络传输量消耗了我们网络中各种共享的 1GB 的链路，结果导致随着我们 增加服务器的数量，每台服务器上的吞吐量急剧下降。实际应用截止到 2006 年 8 月，Google 内部一共有 388 个非测试用的 Bigtable 集群运行在各种各样的服务器集群上， 合计大约有 24500 个 Tablet 服务器。表 1 显示了每个集群上 Tablet 服务器的大致分布情况。这些集群中，许 多用于开发目的，因此会有一段时期比较空闲。通过观察一个由 14 个集群、8069 个 Tablet 服务器组成的集群 组，我们看到整体的吞吐量超过了每秒 1200000 次请求，发送到系统的 RPC 请求导致的网络负载达到了 741MB/s，系统发出的 RPC 请求网络负载大约是 16GB/s。表 2 提供了一些目前正在使用的表的相关数据。一些表存储的是用户相关的数据，另外一些存储的则是 用于批处理的数据;这些表在总的大小、 每个数据项的平均大小、从内存中读取的数据的比例、表的 Schema 的复杂程度上都有很大的差别。本节的其余部分，我们将主要描述三个产品研发团队如何使用 Bigtable 的。 Google AnalyticsGoogle Analytics 是用来帮助 Web 站点的管理员分析他们网站的流量模式的服务。它提供了整体状况的统 计数据，比如每天的独立访问的用户数量、每天每个 URL 的浏览次数;它还提供了用户使用网站的行为报告， 比如根据用户之前访问的某些页面，统计出几成的用户购买了商品。 为了使用这个服务，Web 站点的管理员只需要在他们的 Web 页面中嵌入一小段 JavaScript 脚本就可以了。 这个 Javascript 程序在页面被访问的时候调用。它记录了各种 Google Analytics 需要使用的信息，比如用户的 标识、获取的网页的相关信息。Google Analytics 汇总这些数据，之后提供给 Web 站点的管理员。 我们粗略的描述一下 Google Analytics 使用的两个表。Row Click 表(大约有 200TB 数据)的每一行存放 了一个最终用户的会话。行的名字是一个包含 Web 站点名字以及用户会话创建时间的元组。这种模式保证了 对同一个 Web 站点的访问会话是顺序的，会话按时间顺序存储。这个表可以压缩到原来尺寸的 14%。 Summary 表(大约有 20TB 的数据)包含了关于每个 Web 站点的、各种类型的预定义汇总信息。一个周 期性运行的 MapReduce 任务根据 Raw Click 表的数据生成 Summary 表的数据。每个 MapReduce 工作进程都 从 Raw Click 表中提取最新的会话数据。系统的整体吞吐量受限于 GFS 的吞吐量。这个表的能够压缩到原有 尺寸的 29%。 Google EarthGoogle 通过一组服务为用户提供了高分辨率的地球表面卫星图像，访问的方式可以使通过基于 Web 的 Google Maps 访问接口(maps.google.com)，也可以通过 Google Earth 定制的客户端软件访问。这些软件产品 允许用户浏览地球表面的图像:用户可以在不同的分辨率下平移、查看和注释这些卫星图像。这个系统使用一个表存储预处理数据，使用另外一组表存储用户数据。 数据预处理流水线使用一个表存储原始图像。在预处理过程中，图像被清除，图像数据合并到最终的服务数据中。这个表包含了大约 70TB 的数据，所以需要从磁盘读取数据。图像已经被高效压缩过了，因此存 储在 Bigtable 后不需要再压缩了。 Imagery 表的每一行都代表了一个单独的地理区域。行都有名称，以确保毗邻的区域存储在了一起。 Imagery 表中有一个列族用来记录每个区域的数据源。这个列族包含了大量的列:基本上市每个列对应一个原 始图片的数据。由于每个地理区域都是由很少的几张图片构成的，因此这个列族是非常稀疏的。 数据预处理流水线高度依赖运行在 Bigtable 上的 MapReduce 任务传输数据。在运行某些 MapReduce 任务 的时候，整个系统中每台 Tablet 服务器的数据处理速度是 1MB/s。 这个服务系统使用一个表来索引 GFS 中的数据。这个表相对较小(大约是 500GB)，但是这个表必须在 保证较低的响应延时的前提下，针对每个数据中心，每秒处理几万个查询请求。 因此，这个表必须在上百个 Tablet 服务器上存储数据，并且使用 in-memory 的列族。 个性化查询个性化查询(www.google.com/psearch)是一个双向服务;这个服务记录用户的查询和点击，涉及到各种 Google 的服务，比如 Web 查询、图像和新闻。用户可以浏览他们查询的历史，重复他们之前的查询和点击; 用户也可以定制基于 Google 历史使用习惯模式的个性化查询结果。 个性化查询使用 Bigtable 存储每个用户的数据。每个用户都有一个唯一的用户 id，每个用户 id 和一个列 名绑定。一个单独的列族被用来存储各种类型的行为(比如，有个列族可能是用来存储所有的 Web 查询的)。 每个数据项都被用作 Bigtable 的时间戳，记录了相应的用户行为发生的时间。个性化查询使用以 Bigtable 为 存储的 MapReduce 任务生成用户的数据图表。这些用户数据图表用来个性化当前的查询结果。 个性化查询的数据会复制到几个 Bigtable 的集群上，这样就增强了数据可用性，同时减少了由客户端和 Bigtable 集群间的“距离”造成的延时。个性化查询的开发团队最初建立了一个基于 Bigtable 的、“客户侧” 的复制机制为所有的复制节点提供一致性保障。现在的系统则使用了内建的复制子系统。 个性化查询存储系统的设计允许其它的团队在它们自己的列中加入新的用户数据，因此，很多 Google 服 务使用个性化查询存储系统保存用户级的配置参数和设置。在多个团队之间分享数据的结果是产生了大量的 列族。为了更好的支持数据共享，我们加入了一个简单的配额机制29限制用户在共享表中使用的空间;配额也 为使用个性化查询系统存储用户级信息的产品团体提供了隔离机制。 经验教训 在设计、实现、维护和支持 Bigtable 的过程中，我们得到了很多有用的经验和一些有趣的教训。一个教训是，我们发现，很多类型的错误都会导致大型分布式系统受损，这些错误不仅仅是通常的网络 中断、或者很多分布式协议中设想的 fail-stop 类型的错误30。比如，我们遇到过下面这些类型的错误导致的问 题:内存数据损坏、网络中断、时钟偏差、机器挂起、扩展的和非对称的网络分区31、我们使用的其它系统的 Bug(比如 Chubby)、GFS 配额溢出、计划内和计划外的硬件维护。我们在解决这些问题的过程中学到了很多 经验，我们通过修改协议来解决这些问题。比如，我们在我们的 RPC 机制中加入了 Checksum。我们在设计 系统的部分功能时，不对其它部分功能做任何的假设，这样的做法解决了其它的一些问题。比如，我们不再 假设一个特定的 Chubby 操作只返回错误码集合中的一个值。 另外一个教训是，我们明白了在彻底了解一个新特性会被如何使用之后，再决定是否添加这个新特性是 非常重要的。比如，我们开始计划在我们的 API 中支持通常方式的事务处理。但是由于我们还不会马上用到 这个功能，因此，我们并没有去实现它。现在，Bigtable 上已经有了很多的实际应用，我们可以检查它们真实 的需求;我们发现，大多是应用程序都只是需要单个行上的事务功能。有些应用需要分布式的事务功能，分 布式事务大多数情况下用于维护二级索引，因此我们增加了一个特殊的机制去满足这个需求。新的机制在通 用性上比分布式事务差很多，但是它更有效(特别是在更新操作的涉及上百行数据的时候)，而且非常符合我 们的“跨数据中心”复制方案的优化策略。 还有一个具有实践意义的经验:我们发现系统级的监控对 Bigtable 非常重要(比如，监控 Bigtable 自身 以及使用 Bigtable 的客户程序)。比如，我们扩展了我们的 RPC 系统，因此对于一个 RPC 调用的例子，它可 以详细记录代表了 RPC 调用的很多重要操作。这个特性允许我们检测和修正很多的问题，比如 Tablet 数据结 构上的锁的内容、在修改操作提交时对 GFS 的写入非常慢的问题、以及在 METADATA 表的 Tablet 不可用时， 对 METADATA 表的访问挂起的问题。关于监控的用途的另外一个例子是，每个 Bigtable 集群都在 Chubby 中 注册了。这可以帮助我们跟踪所有的集群状态、监控它们的大小、检查集群运行的我们软件的版本、监控集 群流入数据的流量，以及检查是否有引发集群高延时的潜在因素。 对我们来说，最宝贵的经验是简单设计的价值。考虑到我们系统的代码量(大约 100000 行生产代码32)， 以及随着时间的推移，新的代码以各种难以预料的方式加入系统，我们发现简洁的设计和编码给维护和调试 带来的巨大好处。这方面的一个例子是我们的 Tablet 服务器成员协议。我们第一版的协议很简单:Master 服务器周期性的和 Tablet 服务器签订租约，Tablet 服务器在租约过期的时候 Kill 掉自己的进程。不幸的是，这 个协议在遇到网络问题时会大大降低系统的可用性，也会大大增加 Master 服务器恢复的时间。我们多次重新 设计这个协议，直到它能够很好的处理上述问题。但是，更不幸的是，最终的协议过于复杂了，并且依赖一 些 Chubby 很少被用到的特性。我们发现我们浪费了大量的时间在调试一些古怪的问题33，有些是 Bigtable 代 码的问题，有些是 Chubby 代码的问题。最后，我们只好废弃了这个协议，重新制订了一个新的、更简单、只使用 Chubby 最广泛使用的特性的协议。相关工作Boxwood 项目的有些组件在某些方面和 Chubby、GFS 以及 Bigtable 类似，因为它也提供了诸如分 布式协议、锁、分布式 Chunk 存储以及分布式 B-tree 存储。Boxwood 与 Google 的某些组件尽管功能类似， 但是 Boxwood 的组件提供更底层的服务。Boxwood 项目的目的是提供创建类似文件系统、数据库等高级服务 的基础构件，而 Bigtable 的目的是直接为客户程序的数据存储需求提供支持。 现在有不少项目已经攻克了很多难题，实现了在广域网上的分布式数据存储或者高级服务，通常是 “Internet 规模”的。这其中包括了分布式的 Hash 表，这项工作由一些类似 CAN【29】、Chord【32】、Tapestry 【37】和 Pastry【30】的项目率先发起。这些系统的主要关注点和 Bigtable 不同，比如应对各种不同的传输带 宽、不可信的协作者、频繁的更改配置等;另外，去中心化和 Byzantine 灾难冗余也不是 Bigtable 的目的。 就提供给应用程序开发者的分布式数据存储模型而言，我们相信，分布式 B-Tree 或者分布式 Hash 表提 供的 Key-value pair 方式的模型有很大的局限性。Key-value pair 模型是很有用的组件，但是它们不应该是提供给开发者唯一的组件。我们选择的模型提供的组件比简单的 Key-value pair 丰富的多，它支持稀疏的、半结构 化的数据。另外，它也足够简单，能够高效的处理平面文件;它也是透明的(通过局部性群组)，允许我们的 使用者对系统的重要行为进行调整。 有些数据库厂商已经开发出了并行的数据库系统，能够存储海量的数据。Oracle 的 RAC【27】使用共享 磁盘存储数据(Bigtable 使用 GFS)，并且有一个分布式的锁管理系统(Bigtable 使用 Chubby)。IBM 并行版 本的 DB2【4】基于一种类似于 Bigtable 的、不共享任何东西的架构35【33】。每个 DB2 的服务器都负责处理 存储在一个关系型数据库中的表中的行的一个子集。这些产品都提供了一个带有事务功能的完整的关系模型。 Bigtable 采用 memtable 和 SSTable 存储对表的更新的方法与 Log-Structured Merge Tree【26】存储索引数据更新的方法类似。这两个系统中，排序的数据在写入到磁盘前都先存放在内存中，读取操作必须从内存和磁盘中合并数据产生最终的结果集。 C-Store 和 Bigtable 有很多相似点:两个系统都采用 Shared-nothing 架构，都有两种不同的数据结构，一 种用于当前的写操作，另外一种存放“长时间使用”的数据，并且提供一种机制在两个存储结构间搬运数据。 两个系统在 API 接口函数上有很大的不同:C-Store 操作更像关系型数据库，而 Bigtable 提供了低层次的读写 操作接口，并且设计的目标是能够支持每台服务器每秒数千次操作。C-Store 同时也是个“读性能优化的关系 型数据库”，而 Bigtable 对读和写密集型应用都提供了很好的性能。 Bigtable 也必须解决所有的 Shared-nothing 数据库需要面对的、类型相似的一些负载和内存均衡方面的难 题(比如，【11，35】)。我们的问题在某种程度上简单一些: 我们不需要考虑同一份数据可能有多个拷贝的问题，同一份数据可能由于视图或索引的原因以不同 的形式表现出来; 我们让用户决定哪些数据应该放在内存里、哪些放在磁盘上，而不是由系统动态的判断; 3. 我们的系统中没有复杂的查询执行或优化工作。 结论 我们已经讲述完了 Bigtable，Google 的一个分布式的结构化数据存储系统。Bigtable 的集群从 2005 年 4 月开始已经投入使用了，在此之前，我们花了大约 7 人年设计和实现这个系统。截止到 2006 年 4 月，已经有 超过 60 个项目使用 Bigtable 了。我们的用户对 Bigtable 提供的高性能和高可用性很满意，随着时间的推移， 他们可以根据自己的系统对资源的需求增加情况，通过简单的增加机器，扩展系统的承载能力。 由于 Bigtable 提供的编程接口并不常见，一个有趣的问题是:我们的用户适应新的接口有多难?新的使 用者有时不太确定使用 Bigtable 接口的最佳方法，特别是在他们已经习惯于使用支持通用事务的关系型数据 库的接口的情况下。但是，Google 内部很多产品都成功的使用了 Bigtable 的事实证明了，我们的设计在实践 中行之有效。 我们现在正在对 Bigtable 加入一些新的特性，比如支持二级索引，以及支持多 Master 节点的、跨数据中心复制的 Bigtable 的基础构件。我们现在已经开始将 Bigtable 部署为服务供其它的产品团队使用，这样不同 的产品团队就不需要维护他们自己的 Bigtable 集群了。随着服务集群的扩展，我们需要在 Bigtable 系统内部处理更多的关于资源共享的问题了【3，5】。 最后，我们发现，建设 Google 自己的存储解决方案带来了很多优势。通过为 Bigtable 设计我们自己的数据模型，是我们的系统极具灵活性。另外，由于我们全面控制着 Bigtable 的实现过程，以及 Bigtable 使用到 的其它的 Google 的基础构件，这就意味着我们在系统出现瓶颈或效率低下的情况时，能够快速的解决这些问 题。AcknowledgementsWe thank the anonymous reviewers, David Nagle, and our shepherd Brad Calder, for their feedback on this paper.The Bigtable system has benefited greatly from the feedback of our many users within Google. In addition,we thank the following people for their contributions to Bigtable: Dan Aguayo, Sameer Ajmani, Zhifeng Chen,Bill Coughran, Mike Epstein, Healfdene Goguen, Robert Griesemer, Jeremy Hylton, Josh Hyman, Alex Khesin,Joanna Kulik, Alberto Lerner, Sherry Listgarten, Mike Maloney, Eduardo Pinheiro, Kathy Polizzi, Frank Yellin,and Arthur Zwiegincew.References[1] ABADI, D. J., MADDEN, S. R., AND FERREIRA, M. C. Integrating compression and execution in columnoriented database systems. Proc. of SIGMOD (2006).[2] AILAMAKI, A., DEWITT, D. J., HILL, M. D., AND SKOUNAKIS, M. Weaving relations for cache performance.In The VLDB Journal (2001), pp. 169-180.[3] BANGA, G., DRUSCHEL, P., AND MOGUL, J. C. Resource containers: A new facility for resource management in server systems. In Proc. of the 3rd OSDI (Feb. 1999), pp. 45-58.[4] BARU, C. K., FECTEAU, G., GOYAL, A., HSIAO, H., JHINGRAN, A., PADMANABHAN, S., COPELAND,G. P., AND WILSON, W. G. DB2 parallel edition. IBM Systems Journal 34, 2 (1995), 292-322.[5] BAVIER, A., BOWMAN, M., CHUN, B., CULLER, D., KARLIN, S., PETERSON, L., ROSCOE, T., SPALINK, T., AND WAWRZONIAK, M. Operating system support for planetary-scale network services. In Proc. of the 1st NSDI(Mar. 2004), pp. 253-266.[6] BENTLEY, J. L., AND MCILROY, M. D. Data compression using long common strings. In Data Compression Conference (1999), pp. 287-295.[7] BLOOM, B. H. Space/time trade-offs in hash coding with allowable errors. CACM 13, 7 (1970), 422-426.[8] BURROWS, M. The Chubby lock service for looselycoupled distributed systems. In Proc. of the 7th OSDI (Nov. 2006).[9] CHANDRA, T., GRIESEMER, R., AND REDSTONE, J.Paxos made live ? An engineering perspective. In Proc. of PODC (2007).[10] COMER, D. Ubiquitous B-tree. Computing Surveys 11, 2 (June 1979), 121-137.[11] COPELAND, G. P., ALEXANDER, W., BOUGHTER, E. E., AND KELLER, T. W. Data placement in Bubba. In Proc. of SIGMOD (1988), pp. 99-108.[12] DEAN, J., AND GHEMAWAT, S. MapReduce: Simplified data processing on large clusters. In Proc. of the 6th OSDI (Dec. 2004), pp. 137-150.[13] DEWITT, D., KATZ, R., OLKEN, F., SHAPIRO, L., STONEBRAKER, M., AND WOOD, D. Implementation techniques for main memory database systems. In Proc. of SIGMOD (June 1984), pp. 1-8.[14] DEWITT, D. J., AND GRAY, J. Parallel database systems: The future of high performance database systems. CACM 35, 6 (June 1992), 85-98.[15] FRENCH, C. D. One size ts all database architectures do not work for DSS. In Proc. of SIGMOD (May 1995), pp. 449-450.[16] GAWLICK, D., AND KINKADE, D. Varieties of concurrency control in IMS/VS fast path. Database Engineering Bulletin 8, 2 (1985), 3-10.[17] GHEMAWAT, S., GOBIOFF, H., AND LEUNG, S.-T. The Google file system. In Proc. of the 19th ACM SOSP (Dec.2003), pp. 29-43.[18] GRAY, J. Notes on database operating systems. In Operating Systems ? An Advanced Course, vol. 60 of Lecture Notes in Computer Science. Springer-Verlag, 1978.[19] GREER, R. Daytona and the fourth-generation language Cymbal. In Proc. of SIGMOD (1999), pp. 525-526.[20] HAGMANN, R. Reimplementing the Cedar file system using logging and group commit. In Proc. of the 11th SOSP (Dec. 1987), pp. 155-162.[21] HARTMAN, J. H., AND OUSTERHOUT, J. K. The Zebra striped network file system. In Proc. of the 14th SOSP(Asheville, NC, 1993), pp. 29-43.[22] KX.COM. kx.com/products/database.php. Product page.[23] LAMPORT, L. The part-time parliament. ACM TOCS 16,2 (1998), 133-169.[24] MACCORMICK, J., MURPHY, N., NAJORK, M., THEKKATH, C. A., AND ZHOU, L.Boxwood:Abstractions as the foundation for storage infrastructure. In Proc. of the 6th OSDI (Dec. 2004), pp. 105-120.[25] MCCARTHY, J. Recursive functions of symbolic expressions and their computation by machine. CACM 3,4 (Apr. 1960), 184-195.[26] O’NEIL, P., CHENG, E., GAWLICK, D., AND O’NEIL, E. The log-structured merge-tree (LSM-tree).Acta Inf. 33, 4 (1996), 351-385.[27] ORACLE.COM. www.oracle.com/technology/products/database/clustering/index.html. Product page.[28] PIKE, R., DORWARD, S., GRIESEMER, R., AND QUINLAN, S. Interpreting the data: Parallel analysiswith Sawzall. Scientific Programming Journal 13, 4 (2005), 227-298.[29] RATNASAMY, S., FRANCIS, P., HANDLEY, M., KARP, R., AND SHENKER, S. A scalablecontent-addressable network. In Proc. of SIGCOMM (Aug. 2001), pp. 161-172.[30] ROWSTRON, A., AND DRUSCHEL, P. Pastry: Scalable, distributed object location and routing forlargescale peer-to-peer systems. In Proc. of Middleware 2001(Nov. 2001), pp. 329-350.[31] SENSAGE.COM. sensage.com/products-sensage.htm. Product page.[32] STOICA, I., MORRIS, R., KARGER, D., KAASHOEK, M. F., AND BALAKRISHNAN, H. Chord: Ascalable peer-to-peer lookup service for Internet applications. In Proc. of SIGCOMM (Aug. 2001), pp. 149-160.[33] STONEBRAKER, M. The case for shared nothing. Database Engineering Bulletin 9, 1 (Mar. 1986), 4-9. [34] STONEBRAKER,M., ABADI, D. J., BATKIN, A., CHEN, X., CHERNIACK, M., FERREIRA, M., LAU,E., LIN, A., MADDEN, S., O’NEIL, E., O’NEIL, P., RASIN, A., TRAN, N., AND ZDONIK, S. C-Store: A columnoriented DBMS. In Proc. of VLDB (Aug. 2005), pp. 553-564.[35] STONEBRAKER, M., AOKI, P. M., DEVINE, R., LITWIN, W., AND OLSON, M. A. Mariposa: A new architecture for distributed data. In Proc. of the Tenth ICDE(1994), IEEE Computer Society, pp. 54-65.[36] SYBASE.COM. www.sybase.com/products/databaseservers/sybaseiq. Product page.[37] ZHAO, B. Y., KUBIATOWICZ, J., AND JOSEPH, A. D. Tapestry: An infrastructure for fault-tolerant wide-area location and routing. Tech. Rep. UCB/CSD-01-1141, CS Division, UC Berkeley, Apr. 2001.[38] ZUKOWSKI, M., BONCZ, P. A., NES, N., AND HEMAN, S. MonetDB/X100 ?A DBMS in the CPU cache. IEEE Data Eng. Bull. 28, 2 (2005), 17-22.","raw":null,"content":null,"categories":[{"name":"paper","slug":"paper","permalink":"https://stanxia.github.io/categories/paper/"}],"tags":[{"name":"paper","slug":"paper","permalink":"https://stanxia.github.io/tags/paper/"}]},{"title":"Google MapReduce 中文版","slug":"Google-MapReduce-中文版","date":"2017-12-16T10:06:41.000Z","updated":"2019-04-17T06:08:31.918Z","comments":true,"path":"2017/12/16/Google-MapReduce-中文版/","link":"","permalink":"https://stanxia.github.io/2017/12/16/Google-MapReduce-中文版/","excerpt":"摘要\nMapReduce 是一个编程模型，也是一个处理和生成超大数据集的算法模型的相关实现。用户首先创建一 个 Map 函数处理一个基于 key/value pair 的数据集合，输出中间的基于 key/value pair 的数据集合;然后再创建 一个 Reduce 函数用来合并所有的具有相同中间 key 值的中间 value 值。现实世界中有很多满足上述处理模型 的例子，本论文将详细描述这个模型。\nMapReduce 架构的程序能够在大量的普通配置的计算机上实现并行化处理。这个系统在运行时只关心: 如何分割输入数据，在大量计算机组成的集群上的调度，集群中计算机的错误处理，管理集群中计算机之间 必要的通信。采用 MapReduce 架构可以使那些没有并行计算和分布式处理系统开发经验的程序员有效利用分 布式系统的丰富资源。\n我们的 MapReduce 实现运行在规模可以灵活调整的由普通机器组成的集群上:一个典型的 MapReduce 计算往往由几千台机器组成、处理以 TB 计算的数据。程序员发现这个系统非常好用:已经实现了数以百计 的 MapReduce 程序，在 Google 的集群上，每天都有 1000 多个 MapReduce 程序在执行。","text":"摘要 MapReduce 是一个编程模型，也是一个处理和生成超大数据集的算法模型的相关实现。用户首先创建一 个 Map 函数处理一个基于 key/value pair 的数据集合，输出中间的基于 key/value pair 的数据集合;然后再创建 一个 Reduce 函数用来合并所有的具有相同中间 key 值的中间 value 值。现实世界中有很多满足上述处理模型 的例子，本论文将详细描述这个模型。 MapReduce 架构的程序能够在大量的普通配置的计算机上实现并行化处理。这个系统在运行时只关心: 如何分割输入数据，在大量计算机组成的集群上的调度，集群中计算机的错误处理，管理集群中计算机之间 必要的通信。采用 MapReduce 架构可以使那些没有并行计算和分布式处理系统开发经验的程序员有效利用分 布式系统的丰富资源。 我们的 MapReduce 实现运行在规模可以灵活调整的由普通机器组成的集群上:一个典型的 MapReduce 计算往往由几千台机器组成、处理以 TB 计算的数据。程序员发现这个系统非常好用:已经实现了数以百计 的 MapReduce 程序，在 Google 的集群上，每天都有 1000 多个 MapReduce 程序在执行。 介绍在过去的 5 年里，包括本文作者在内的 Google 的很多程序员，为了处理海量的原始数据，已经实现了数 以百计的、专用的计算方法。这些计算方法用来处理大量的原始数据，比如，文档抓取(类似网络爬虫的程 序)、Web 请求日志等等;也为了计算处理各种类型的衍生数据，比如倒排索引、Web 文档的图结构的各种表 示形势、每台主机上网络爬虫抓取的页面数量的汇总、每天被请求的最多的查询的集合等等。大多数这样的 数据处理运算在概念上很容易理解。然而由于输入的数据量巨大，因此要想在可接受的时间内完成运算，只 有将这些计算分布在成百上千的主机上。如何处理并行计算、如何分发数据、如何处理错误?所有这些问题 综合在一起，需要大量的代码处理，因此也使得原本简单的运算变得难以处理。 为了解决上述复杂的问题，我们设计一个新的抽象模型，使用这个抽象模型，我们只要表述我们想要执 行的简单运算即可，而不必关心并行计算、容错、数据分布、负载均衡等复杂的细节，这些问题都被封装在 了一个库里面。设计这个抽象模型的灵感来自 Lisp 和许多其他函数式语言的 Map 和 Reduce 的原语。我们意 识到我们大多数的运算都包含这样的操作:在输入数据的“逻辑”记录上应用 Map 操作得出一个中间 key/value pair 集合，然后在所有具有相同 key 值的 value 值上应用 Reduce 操作，从而达到合并中间的数据，得到一个想要的结果的目的。使用 MapReduce 模型，再结合用户实现的 Map 和 Reduce 函数，我们就可以非常容易的 实现大规模并行化计算;通过 MapReduce 模型自带的“再次执行”(re-execution)功能，也提供了初级的容灾实现方案。 这个工作(实现一个 MapReduce 框架模型)的主要贡献是通过简单的接口来实现自动的并行化和大规模的分布式计算，通过使用 MapReduce 模型接口实现在大量普通的 PC 机上高性能计算。 第二部分描述基本的编程模型和一些使用案例。 第三部分描述了一个经过裁剪的、适合我们的基于集群的计算环境的 MapReduce 实现。 第四部分描述我们认为在 MapReduce 编程模型中一些实用的技巧。 第五部分对于各种不同的任务，测量我们 MapReduce 实现的性能。 第六部分揭示了在 Google 内部如何使用 MapReduce 作为基础重写我们的索引系统产品，包括其它一些 使用 MapReduce 的经验。 第七部分讨论相关的和未来的工作。 编程模型 MapReduce 编程模型的原理是:利用一个输入 key/value pair 集合来产生一个输出的 key/value pair 集合。 MapReduce 库的用户用两个函数表达这个计算:Map 和 Reduce。 用户自定义的 Map 函数接受一个输入的 key/value pair 值，然后产生一个中间 key/value pair 值的集合。 MapReduce 库把所有具有相同中间 key 值 I 的中间 value 值集合在一起后传递给 reduce 函数。 用户自定义的 Reduce 函数接受一个中间 key 的值 I 和相关的一个 value 值的集合。Reduce 函数合并这些 value 值，形成一个较小的 value 值的集合。一般的，每次 Reduce 函数调用只产生 0 或 1 个输出 value 值。通 常我们通过一个迭代器把中间 value 值提供给 Reduce 函数，这样我们就可以处理无法全部放入内存中的大量 的 value 值的集合。 例子例如，计算一个大的文档集合中每个单词出现的次数，下面是伪代码段: `map(String key, String value): // key: document name // value: document contents for each word w in value: EmitIntermediate(w, “1′′); reduce(String key, Iterator values): // key: a word // values: a list of counts int result = 0; for each v in values: result += ParseInt(v); Emit(AsString(result));12Map 函数输出文档中的每个词、以及这个词的出现次数(在这个简单的例子里就是 1)。Reduce 函数把 Map 函数产生的每一个特定的词的计数累加起来。 另外，用户编写代码，使用输入和输出文件的名字、可选的调节参数来完成一个符合 MapReduce 模型规 范的对象，然后调用 MapReduce 函数，并把这个规范对象传递给它。用户的代码和 MapReduce 库链接在一起 (用 C++实现)。附录 A 包含了这个实例的全部程序代码。 ### 类型 尽管在前面例子的伪代码中使用了以字符串表示的输入输出值，但是在概念上，用户定义的 Map 和 Reduce 函数都有相关联的类型: map(k1,v1) -&gt;list(k2,v2)reduce(k2,list(v2)) -&gt;list(v2)1234567891011121314 比如，输入的 key 和 value 值与输出的 key 和 value 值在类型上推导的域不同。此外，中间 key 和 value 值与输出 key 和 value 值在类型上推导的域相同。 我们的 C++中使用字符串类型作为用户自定义函数的输入输出，用户在自己的代码中对字符串进行适当 的类型转换。 ### 更多的例子 这里还有一些有趣的简单例子，可以很容易的使用 MapReduce 模型来表示: 分布式的 Grep:Map 函数输出匹配某个模式的一行，Reduce 函数是一个恒等函数，即把中间数据复制到 输出。 计算 URL 访问频率:Map 函数处理日志中 web 页面请求的记录，然后输出(URL,1)。Reduce 函数把相同URL 的 value 值都累加起来，产生(URL,记录总数)结果。 倒转网络链接图:Map 函数在源页面(source)中搜索所有的链接目标(target)并输出为(target,source)。Reduce 函数把给定链接目标(target)的链接组合成一个列表，输出(target,list(source))。 每个主机的检索词向量:检索词向量用一个(词,频率)列表来概述出现在文档或文档集中的最重要的一些 词。Map 函数为每一个输入文档输出(主机名,检索词向量)，其中主机名来自文档的 URL。Reduce 函数接收给 定主机的所有文档的检索词向量，并把这些检索词向量加在一起，丢弃掉低频的检索词，输出一个最终的(主 机名,检索词向量)。 倒排索引:Map 函数分析每个文档输出一个(词,文档号)的列表，Reduce 函数的输入是一个给定词的所有 (词，文档号)，排序所有的文档号，输出(词,list(文档号))。所有的输出集合形成一个简单的倒排索引，它 以一种简单的算法跟踪词在文档中的位置。 分布式排序:Map 函数从每个记录提取 key，输出(key,record)。Reduce 函数不改变任何的值。这个运算 依赖分区机制(在 4.1 描述)和排序属性(在 4.2 描述)。 &#123;% note info %&#125;## 实现 &#123;% endnote %&#125; MapReduce 模型可以有多种不同的实现方式。如何正确选择取决于具体的环境。例如，一种实现方式适 用于小型的共享内存方式的机器，另外一种实现方式则适用于大型 NUMA 架构的多处理器的主机，而有的实 现方式更适合大型的网络连接集群。 本章节描述一个适用于 Google 内部广泛使用的运算环境的实现:用以太网交换机连接、由普通 PC 机组 成的大型集群。在我们的环境里包括: 1. x86 架构、运行 Linux 操作系统、双处理器、2-4GB 内存的机器。 2. 普通的网络硬件设备，每个机器的带宽为百兆或者千兆，但是远小于网络的平均带宽的一半。 3. 集群中包含成百上千的机器，因此，机器故障是常态。 4. 存储为廉价的内置 IDE 硬盘。一个内部分布式文件系统用来管理存储在这些磁盘上的数据。文件系 统通过数据复制来在不可靠的硬件上保证数据的可靠性和有效性。 5. 用户提交工作(job)给调度系统。每个工作(job)都包含一系列的任务(task)，调度系统将这些任 务调度到集群中多台可用的机器上。 ### 执行概括 通过将 Map 调用的输入数据自动分割为 M 个数据片段的集合，Map 调用被分布到多台机器上执行。输 入的数据片段能够在不同的机器上并行处理。使用分区函数将 Map 调用产生的中间 key 值分成 R 个不同分区(例如，hash(key) mod R)，Reduce 调用也被分布到多台机器上执行。分区数量(R)和分区函数由用户来指定。![](http://oliji9s3j.bkt.clouddn.com/15133908393351.jpg) 图 1 展示了我们的 MapReduce 实现中操作的全部流程。当用户调用 MapReduce 函数时，将发生下面的一 系列动作(下面的序号和图 1 中的序号一一对应): 1. 用户程序首先调用的 MapReduce 库将输入文件分成 M 个数据片度，每个数据片段的大小一般从 16MB 到 64MB(可以通过可选的参数来控制每个数据片段的大小)。然后用户程序在机群中创建大量 的程序副本。 2. 这些程序副本中的有一个特殊的程序–master。副本中其它的程序都是 worker 程序，由 master 分配 任务。有 M 个 Map 任务和 R 个 Reduce 任务将被分配，master 将一个 Map 任务或 Reduce 任务分配 给一个空闲的 worker。 3. 被分配了 map 任务的 worker 程序读取相关的输入数据片段，从输入的数据片段中解析出 key/value pair，然后把 key/value pair 传递给用户自定义的 Map 函数，由 Map 函数生成并输出的中间 key/value pair，并缓存在内存中。 4. 缓存中的 key/value pair 通过分区函数分成 R 个区域，之后周期性的写入到本地磁盘上。缓存的 key/value pair 在本地磁盘上的存储位置将被回传给 master，由 master 负责把这些存储位置再传送给 Reduce worker。 5. 当 Reduce worker 程序接收到 master 程序发来的数据存储位置信息后，使用 RPC 从 Map worker 所在 主机的磁盘上读取这些缓存数据。当 Reduce worker 读取了所有的中间数据后，通过对 key 进行排序后使得具有相同 key 值的数据聚合在一起。由于许多不同的 key 值会映射到相同的 Reduce 任务上，因此必须进行排序。如果中间数据太大无法在内存中完成排序，那么就要在外部进行排序。 6. Reduce worker 程序遍历排序后的中间数据，对于每一个唯一的中间 key 值，Reduce worker 程序将这 个 key 值和它相关的中间 value 值的集合传递给用户自定义的 Reduce 函数。Reduce 函数的输出被追加到所属分区的输出文件。 7. 当所有的 Map 和 Reduce 任务都完成之后，master 唤醒用户程序。在这个时候，在用户程序里的对MapReduce 调用才返回。 在成功完成任务之后，MapReduce 的输出存放在 R 个输出文件中(对应每个 Reduce 任务产生一个输出 文件，文件名由用户指定)。一般情况下，用户不需要将这 R 个输出文件合并成一个文件–他们经常把这些文 件作为另外一个 MapReduce 的输入，或者在另外一个可以处理多个分割文件的分布式应用中使用。 ### Master 数据结构 Master 持有一些数据结构，它存储每一个 Map 和 Reduce 任务的状态(空闲、工作中或完成)，以及 Worker 机器(非空闲任务的机器)的标识。 Master 就像一个数据管道，中间文件存储区域的位置信息通过这个管道从 Map 传递到 Reduce。因此， 对于每个已经完成的 Map 任务，master 存储了 Map 任务产生的 R 个中间文件存储区域的大小和位置。当 Map 任务完成时，Master 接收到位置和大小的更新信息，这些信息被逐步递增的推送给那些正在工作的 Reduce 任 务。 ### 容错 因为 MapReduce 库的设计初衷是使用由成百上千的机器组成的集群来处理超大规模的数据，所以，这个 库必须要能很好的处理机器故障。 #### worker 故障 master 周期性的 ping 每个 worker。如果在一个约定的时间范围内没有收到 worker 返回的信息，master 将 把这个 worker 标记为失效。所有由这个失效的 worker 完成的 Map 任务被重设为初始的空闲状态，之后这些 任务就可以被安排给其他的 worker。同样的，worker 失效时正在运行的 Map 或 Reduce 任务也将被重新置为 空闲状态，等待重新调度。 当 worker 故障时，由于已经完成的 Map 任务的输出存储在这台机器上，Map 任务的输出已不可访问了,因此必须重新执行。而已经完成的 Reduce 任务的输出存储在全局文件系统上，因此不需要再次执行。 当一个 Map 任务首先被 worker A 执行，之后由于 worker A 失效了又被调度到 worker B 执行，这个“重 新执行”的动作会被通知给所有执行 Reduce 任务的 worker。任何还没有从 worker A 读取数据的 Reduce 任务 将从 worker B 读取数据。 MapReduce 可以处理大规模 worker 失效的情况。比如，在一个 MapReduce 操作执行期间，在正在运行 的集群上进行网络维护引起 80 台机器在几分钟内不可访问了，MapReduce master 只需要简单的再次执行那些 不可访问的 worker 完成的工作，之后继续执行未完成的任务，直到最终完成这个 MapReduce 操作。 #### master 失败 一个简单的解决办法是让 master 周期性的将上面描述的数据结构(alex 注:指 3.2 节)的写入磁盘，即 检查点(checkpoint)。如果这个 master 任务失效了，可以从最后一个检查点(checkpoint)开始启动另一个 master 进程。然而，由于只有一个 master 进程，master 失效后再恢复是比较麻烦的，因此我们现在的实现是 如果 master 失效，就中止 MapReduce 运算。客户可以检查到这个状态，并且可以根据需要重新执行 MapReduce 操作。 #### 在失效方面的处理机制 (注:原文为”semantics in the presence of failures”) 当用户提供的 Map 和 Reduce 操作是输入确定性函数(即相同的输入产生相同的输出)时，我们的分布 式实现在任何情况下的输出都和所有程序没有出现任何错误、顺序的执行产生的输出是一样的。 我们依赖对 Map 和 Reduce 任务的输出是原子提交的来完成这个特性。每个工作中的任务把它的输出写 到私有的临时文件中。每个 Reduce 任务生成一个这样的文件，而每个 Map 任务则生成 R 个这样的文件(一 个 Reduce 任务对应一个文件)。当一个 Map 任务完成的时，worker 发送一个包含 R 个临时文件名的完成消息 给 master。如果 master 从一个已经完成的 Map 任务再次接收到到一个完成消息，master 将忽略这个消息;否 则，master 将这 R 个文件的名字记录在数据结构里。 当 Reduce 任务完成时，Reduce worker 进程以原子的方式把临时文件重命名为最终的输出文件。如果同 一个 Reduce 任务在多台机器上执行，针对同一个最终的输出文件将有多个重命名操作执行。我们依赖底层文 件系统提供的重命名操作的原子性来保证最终的文件系统状态仅仅包含一个 Reduce 任务产生的数据。 使用 MapReduce 模型的程序员可以很容易的理解他们程序的行为，因为我们绝大多数的 Map 和 Reduce 操作是确定性的，而且存在这样的一个事实:我们的失效处理机制等价于一个顺序的执行的操作。当 Map 或 /和 Reduce 操作是不确定性的时候，我们提供虽然较弱但是依然合理的处理机制。当使用非确定操作的时候， 一个 Reduce 任务 R1 的输出等价于一个非确定性程序顺序执行产生时的输出。但是，另一个 Reduce 任务 R2 的输出也许符合一个不同的非确定顺序程序执行产生的 R2 的输出。 考虑 Map 任务 M 和 Reduce 任务 R1、R2 的情况。我们设定 e(Ri)是 Ri 已经提交的执行过程(有且仅有一个这样的执行过程)。当 e(R1)读取了由 M 一次执行产生的输出，而 e(R2)读取了由 M 的另一次执行产生的 输出，导致了较弱的失效处理。 ### 存储位置 在我们的计算运行环境中，网络带宽是一个相当匮乏的资源。我们通过尽量把输入数据(由 GFS 管理)存 储在集群中机器的本地磁盘上来节省网络带宽。GFS 把每个文件按 64MB 一个 Block 分隔，每个 Block 保存 在多台机器上，环境中就存放了多份拷贝(一般是 3 个拷贝)。MapReduce 的 master 在调度 Map 任务时会考虑 输入文件的位置信息，尽量将一个 Map 任务调度在包含相关输入数据拷贝的机器上执行;如果上述努力失败 了，master 将尝试在保存有输入数据拷贝的机器附近的机器上执行 Map 任务(例如，分配到一个和包含输入数 据的机器在一个 switch 里的 worker 机器上执行)。当在一个足够大的 cluster 集群上运行大型 MapReduce 操作 的时候，大部分的输入数据都能从本地机器读取，因此消耗非常少的网络带宽。 ### 任务粒度 如前所述，我们把 Map 拆分成了 M 个片段、把 Reduce 拆分成 R 个片段执行。理想情况下，M 和 R 应当 比集群中 worker 的机器数量要多得多。在每台 worker 机器都执行大量的不同任务能够提高集群的动态的负载 均衡能力，并且能够加快故障恢复的速度:失效机器上执行的大量 Map 任务都可以分布到所有其他的 worker 机器上去执行。 但是实际上，在我们的具体实现中对 M 和 R 的取值都有一定的客观限制，因为 master 必须执行 O(M+R) 次调度，并且在内存中保存 O(M*R)个状态(对影响内存使用的因素还是比较小的:O(M*R)块状态，大概每 对 Map 任务/Reduce 任务 1 个字节就可以了)。 更进一步，R 值通常是由用户指定的，因为每个 Reduce 任务最终都会生成一个独立的输出文件。实际使 用时我们也倾向于选择合适的 M 值，以使得每一个独立任务都是处理大约 16M 到 64M 的输入数据(这样， 上面描写的输入数据本地存储优化策略才最有效)，另外，我们把 R 值设置为我们想使用的 worker 机器数量 的小的倍数。我们通常会用这样的比例来执行 MapReduce:M=200000，R=5000，使用 2000 台 worker 机器。 ### 备用任务 影响一个 MapReduce 的总执行时间最通常的因素是“落伍者”:在运算过程中，如果有一台机器花了很 长的时间才完成最后几个 Map 或 Reduce 任务，导致 MapReduce 操作总的执行时间超过预期。出现“落伍者” 的原因非常多。比如:如果一个机器的硬盘出了问题，在读取的时候要经常的进行读取纠错操作，导致读取数据的速度从 30M/s 降低到 1M/s。如果 cluster 的调度系统在这台机器上又调度了其他的任务，由于 CPU、内 存、本地硬盘和网络带宽等竞争因素的存在，导致执行 MapReduce 代码的执行效率更加缓慢。我们最近遇到 的一个问题是由于机器的初始化代码有 bug，导致关闭了的处理器的缓存:在这些机器上执行任务的性能和 正常情况相差上百倍。 我们有一个通用的机制来减少“落伍者”出现的情况。当一个 MapReduce 操作接近完成的时候，master 调度备用(backup)任务进程来执行剩下的、处于处理中状态(in-progress)的任务。无论是最初的执行进程、 还是备用(backup)任务进程完成了任务，我们都把这个任务标记成为已经完成。我们调优了这个机制，通 常只会占用比正常操作多几个百分点的计算资源。我们发现采用这样的机制对于减少超大 MapReduce 操作的 总处理时间效果显著。例如，在 5.3 节描述的排序任务，在关闭掉备用任务的情况下要多花 44%的时间完成 排序任务。 &#123;% note info %&#125;## 技巧 &#123;% endnote %&#125; 虽然简单的 Map 和 Reduce 函数提供的基本功能已经能够满足大部分的计算需要，我们还是发掘出了一 些有价值的扩展功能。本节将描述这些扩展功能。 ### 分区函数 MapReduce 的使用者通常会指定 Reduce 任务和 Reduce 任务输出文件的数量(R)。我们在中间 key 上使 用分区函数来对数据进行分区，之后再输入到后续任务执行进程。一个缺省的分区函数是使用 hash 方法(比如， hash(key) mod R)进行分区。hash 方法能产生非常平衡的分区。然而，有的时候，其它的一些分区函数对 key 值进行的分区将非常有用。比如，输出的 key 值是 URLs，我们希望每个主机的所有条目保持在同一个输出文 件中。为了支持类似的情况，MapReduce 库的用户需要提供专门的分区函数。例如，使用“hash(Hostname(urlkey)) mod R”作为分区函数就可以把所有来自同一个主机的 URLs 保存在同一个输出文件中。 ### 顺序保证 我们确保在给定的分区中，中间 key/value pair 数据的处理顺序是按照 key 值增量顺序处理的。这样的顺 序保证对每个分成生成一个有序的输出文件，这对于需要对输出文件按 key 值随机存取的应用非常有意义， 对在排序输出的数据集也很有帮助。 ### Combiner 函数 在某些情况下，Map 函数产生的中间 key 值的重复数据会占很大的比重，并且，用户自定义的 Reduce 函 数满足结合律和交换律。在 2.1 节的词数统计程序是个很好的例子。由于词频率倾向于一个 zipf 分布(齐夫分布)，每个 Map 任务将产生成千上万个这样的记录&lt;the,1&gt;。所有的这些记录将通过网络被发送到一个单独的 Reduce 任务，然后由这个 Reduce 任务把所有这些记录累加起来产生一个数字。我们允许用户指定一个可选 的 combiner 函数，combiner 函数首先在本地将这些记录进行一次合并，然后将合并的结果再通过网络发送出去。 Combiner 函数在每台执行 Map 任务的机器上都会被执行一次。一般情况下，Combiner 和 Reduce 函数是一样的。Combiner 函数和 Reduce 函数之间唯一的区别是 MapReduce 库怎样控制函数的输出。Reduce 函数的 输出被保存在最终的输出文件里，而 Combiner 函数的输出被写到中间文件里，然后被发送给 Reduce 任务。 部分的合并中间结果可以显著的提高一些 MapReduce 操作的速度。附录 A 包含一个使用 combiner 函数 的例子。 ### 输入和输出的类型 MapReduce 库支持几种不同的格式的输入数据。比如，文本模式的输入数据的每一行被视为是一个 key/value pair。key 是文件的偏移量，value 是那一行的内容。另外一种常见的格式是以 key 进行排序来存储 的 key/value pair 的序列。每种输入类型的实现都必须能够把输入数据分割成数据片段，该数据片段能够由单 独的 Map 任务来进行后续处理(例如，文本模式的范围分割必须确保仅仅在每行的边界进行范围分割)。虽然 大多数 MapReduce 的使用者仅仅使用很少的预定义输入类型就满足要求了，但是使用者依然可以通过提供一 个简单的 Reader 接口实现就能够支持一个新的输入类型。 Reader 并非一定要从文件中读取数据，比如，我们可以很容易的实现一个从数据库里读记录的 Reader， 或者从内存中的数据结构读取数据的 Reader。 类似的，我们提供了一些预定义的输出数据的类型，通过这些预定义类型能够产生不同格式的数据。用 户采用类似添加新的输入数据类型的方式增加新的输出类型。 ### 副作用 在某些情况下，MapReduce 的使用者发现，如果在 Map 和/或 Reduce 操作过程中增加辅助的输出文件会 比较省事。我们依靠程序 writer 把这种“副作用”变成原子的和幂等的3。通常应用程序首先把输出结果写到 一个临时文件中，在输出全部数据之后，在使用系统级的原子操作 rename 重新命名这个临时文件。 如果一个任务产生了多个输出文件，我们没有提供类似两阶段提交的原子操作支持这种情况。因此，对 于会产生多个输出文件、并且对于跨文件有一致性要求的任务，都必须是确定性的任务。但是在实际应用过 程中，这个限制还没有给我们带来过麻烦。### 跳过损坏的记录 有时候，用户程序中的 bug 导致 Map 或者 Reduce 函数在处理某些记录的时候 crash 掉，MapReduce 操作 无法顺利完成。惯常的做法是修复 bug 后再次执行 MapReduce 操作，但是，有时候找出这些 bug 并修复它们 不是一件容易的事情;这些 bug 也许是在第三方库里边，而我们手头没有这些库的源代码。而且在很多时候， 忽略一些有问题的记录也是可以接受的，比如在一个巨大的数据集上进行统计分析的时候。我们提供了一种 执行模式，在这种模式下，为了保证保证整个处理能继续进行，MapReduce 会检测哪些记录导致确定性的 crash， 并且跳过这些记录不处理。 每个 worker 进程都设置了信号处理函数捕获内存段异常(segmentation violation)和总线错误(bus error)。 在执行 Map 或者 Reduce 操作之前，MapReduce 库通过全局变量保存记录序号。如果用户程序触发了一个系 统信号，消息处理函数将用“最后一口气”通过 UDP 包向 master 发送处理的最后一条记录的序号。当 master 看到在处理某条特定记录不止失败一次时，master 就标志着条记录需要被跳过，并且在下次重新执行相关的 Map 或者 Reduce 任务的时候跳过这条记录。 ### 本地执行 调试 Map 和 Reduce 函数的 bug 是非常困难的，因为实际执行操作时不但是分布在系统中执行的，而且 通常是在好几千台计算机上执行，具体的执行位置是由 master 进行动态调度的，这又大大增加了调试的难度。 为了简化调试、profile 和小规模测试，我们开发了一套 MapReduce 库的本地实现版本，通过使用本地版本的 MapReduce 库，MapReduce 操作在本地计算机上顺序的执行。用户可以控制 MapReduce 操作的执行，可以把 操作限制到特定的 Map 任务上。用户通过设定特别的标志来在本地执行他们的程序，之后就可以很容易的使 用本地调试和测试工具(比如 gdb)。 ### 状态信息 master 使用嵌入式的 HTTP 服务器(如 Jetty)显示一组状态信息页面，用户可以监控各种执行状态。状 态信息页面显示了包括计算执行的进度，比如已经完成了多少任务、有多少任务正在处理、输入的字节数、 中间数据的字节数、输出的字节数、处理百分比等等。页面还包含了指向每个任务的 stderr 和 stdout 文件的链 接。用户根据这些数据预测计算需要执行大约多长时间、是否需要增加额外的计算资源。这些页面也可以用 来分析什么时候计算执行的比预期的要慢。 另外，处于最顶层的状态页面显示了哪些 worker 失效了，以及他们失效的时候正在运行的 Map 和 Reduce 任务。这些信息对于调试用户代码中的 bug 很有帮助。### 计数器 MapReduce 库使用计数器统计不同事件发生次数。比如，用户可能想统计已经处理了多少个单词、已经 索引的多少篇 German 文档等等。 为了使用这个特性，用户在程序中创建一个命名的计数器对象，在 Map 和 Reduce 函数中相应的增加计 数器的值。例如: Counter* uppercase;uppercase = GetCounter(“uppercase”);map(String name, String contents): for each word w in contents: if (IsCapitalized(w)): uppercase-&gt;Increment(); EmitIntermediate(w, “1′′);1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798 这些计数器的值周期性的从各个单独的 worker 机器上传递给 maste(r 附加在 ping 的应答包中传递)。master 把执行成功的 Map 和 Reduce 任务的计数器值进行累计，当 MapReduce 操作完成之后，返回给用户代码。 计数器当前的值也会显示在 master 的状态页面上，这样用户就可以看到当前计算的进度。当累加计数器 的值的时候，master 要检查重复运行的 Map 或者 Reduce 任务，避免重复累加(之前提到的备用任务和失效 后重新执行任务这两种情况会导致相同的任务被多次执行)。 有些计数器的值是由 MapReduce 库自动维持的，比如已经处理的输入的 key/value pair 的数量、输出的 key/value pair 的数量等等。 计数器机制对于 MapReduce 操作的完整性检查非常有用。比如，在某些 MapReduce 操作中，用户需要确 保输出的 key value pair 精确的等于输入的 key value pair，或者处理的 German 文档数量在处理的整个文档数 量中属于合理范围。 &#123;% note info %&#125;## 性能&#123;% endnote %&#125; 本节我们用在一个大型集群上运行的两个计算来衡量 MapReduce 的性能。一个计算在大约 1TB 的数据中 进行特定的模式匹配，另一个计算对大约 1TB 的数据进行排序。 这两个程序在大量的使用 MapReduce 的实际应用中是非常典型的 — 一类是对数据格式进行转换，从一 种表现形式转换为另外一种表现形式;另一类是从海量数据中抽取少部分的用户感兴趣的数据。 ### 集群配置 所有这些程序都运行在一个大约由 1800 台机器构成的集群上。每台机器配置 2 个 2G 主频、支持超线程 的 Intel Xeon 处理器，4GB 的物理内存，两个 160GB 的 IDE 硬盘和一个千兆以太网卡。这些机器部署在一个 两层的树形交换网络中，在 root 节点大概有 100-200GBPS 的传输带宽。所有这些机器都采用相同的部署(对 等部署)，因此任意两点之间的网络来回时间小于 1 毫秒。 在 4GB 内存里，大概有 1-1.5G 用于运行在集群上的其他任务。测试程序在周末下午开始执行，这时主机 的 CPU、磁盘和网络基本上处于空闲状态。 ### GREP 这个分布式的 grep 程序需要扫描大概 10 的 10 次方个由 100 个字节组成的记录，查找出现概率较小的 3 个字符的模式(这个模式在 92337 个记录中出现)。输入数据被拆分成大约 64M 的 Block(M=15000)，整个 输出数据存放在一个文件中(R=1)。![](http://oliji9s3j.bkt.clouddn.com/15133914679471.jpg) 图 2 显示了这个运算随时间的处理过程。其中 Y 轴表示输入数据的处理速度。处理速度随着参与 MapReduce 计算的机器数量的增加而增加，当 1764 台 worker 参与计算的时，处理速度达到了 30GB/s。当 Map 任务结束的时候，即在计算开始后 80 秒，输入的处理速度降到 0。整个计算过程从开始到结束一共花了 大概 150 秒。这包括了大约一分钟的初始启动阶段。初始启动阶段消耗的时间包括了是把这个程序传送到各 个 worker 机器上的时间、等待 GFS 文件系统打开 1000 个输入文件集合的时间、获取相关的文件本地位置优 化信息的时间。 ### 排序 排序程序处理 10 的 10 次方个 100 个字节组成的记录(大概 1TB 的数据)。这个程序模仿 TeraSort benchmark[10]。 排序程序由不到 50 行代码组成。只有三行的 Map 函数从文本行中解析出 10 个字节的 key 值作为排序的 key，并且把这个 key 和原始文本行作为中间的 key/value pair 值输出。我们使用了一个内置的恒等函数作为 Reduce 操作函数。这个函数把中间的 key/value pair 值不作任何改变输出。最终排序结果输出到两路复制的GFS 文件系统(也就是说，程序输出 2TB 的数据)。 如前所述，输入数据被分成 64MB 的 Block(M=15000)。我们把排序后的输出结果分区后存储到 4000 个文件(R=4000)。分区函数使用 key 的原始字节来把数据分区到 R 个片段中。 在这个 benchmark 测试中，我们使用的分区函数知道 key 的分区情况。通常对于排序程序来说，我们会 增加一个预处理的 MapReduce 操作用于采样 key 值的分布情况，通过采样的数据来计算对最终排序处理的分 区点。![](http://oliji9s3j.bkt.clouddn.com/15133915176963.jpg) 图三(a)显示了这个排序程序的正常执行过程。左上的图显示了输入数据读取的速度。数据读取速度峰 值会达到 13GB/s，并且所有 Map 任务完成之后，即大约 200 秒之后迅速滑落到 0。值得注意的是，排序程序 输入数据读取速度小于分布式 grep 程序。这是因为排序程序的 Map 任务花了大约一半的处理时间和 I/O 带宽 把中间输出结果写到本地硬盘。相应的分布式 grep 程序的中间结果输出几乎可以忽略不计。 左边中间的图显示了中间数据从 Map 任务发送到 Reduce 任务的网络速度。这个过程从第一个 Map 任务 完成之后就开始缓慢启动了。图示的第一个高峰是启动了第一批大概 1700 个 Reduce 任务(整个 MapReduce 分布到大概 1700 台机器上，每台机器 1 次最多执行 1 个 Reduce 任务)。排序程序运行大约 300 秒后，第一批 启动的 Reduce 任务有些完成了，我们开始执行剩下的 Reduce 任务。所有的处理在大约 600 秒后结束。左下图表示 Reduce 任务把排序后的数据写到最终的输出文件的速度。在第一个排序阶段结束和数据开始 写入磁盘之间有一个小的延时，这是因为 worker 机器正在忙于排序中间数据。磁盘写入速度在 2-4GB/s 持续 一段时间。输出数据写入磁盘大约持续 850 秒。计入初始启动部分的时间，整个运算消耗了 891 秒。这个速 度和 TeraSort benchmark[18]的最高纪录 1057 秒相差不多。 还有一些值得注意的现象:输入数据的读取速度比排序速度和输出数据写入磁盘速度要高不少，这是因 为我们的输入数据本地化优化策略起了作用 — 绝大部分数据都是从本地硬盘读取的，从而节省了网络带宽。 排序速度比输出数据写入到磁盘的速度快，这是因为输出数据写了两份(我们使用了 2 路的 GFS 文件系统， 写入复制节点的原因是为了保证数据可靠性和可用性)。我们把输出数据写入到两个复制节点的原因是因为这 是底层文件系统的保证数据可靠性和可用性的实现机制。如果底层文件系统使用类似容错编码[14](erasure coding)的方式而不是复制的方式保证数据的可靠性和可用性，那么在输出数据写入磁盘的时候，就可以降低 网络带宽的使用。 ### 高效的 backup 任务 图三(b)显示了关闭了备用任务后排序程序执行情况。执行的过程和图 3(a)很相似，除了输出数据写 磁盘的动作在时间上拖了一个很长的尾巴，而且在这段时间里，几乎没有什么写入动作。在 960 秒后，只有 5 个 Reduce 任务没有完成。这些拖后腿的任务又执行了 300 秒才完成。整个计算消耗了 1283 秒，多了 44% 的执行时间。 ### 失效的机器 在图三(c)中演示的排序程序执行的过程中，我们在程序开始后几分钟有意的 kill 了 1746 个 worker 中 的 200 个。集群底层的调度立刻在这些机器上重新开始新的 worker 处理进程(因为只是 worker 机器上的处理 进程被 kill 了，机器本身还在工作)。 图三(c)显示出了一个“负”的输入数据读取速度，这是因为一些已经完成的 Map 任务丢失了(由于 相应的执行 Map 任务的 worker 进程被 kill 了)，需要重新执行这些任务。相关 Map 任务很快就被重新执行了。 整个运算在 933 秒内完成，包括了初始启动时间(只比正常执行多消耗了 5%的时间)。 &#123;% note info %&#125;## 经验 &#123;% endnote %&#125; 我们在 2003 年 1 月完成了第一个版本的 MapReduce 库，在 2003 年 8 月的版本有了显著的增强，这包括 了输入数据本地优化、worker 机器之间的动态负载均衡等等。从那以后，我们惊喜的发现，MapReduce 库能 广泛应用于我们日常工作中遇到的各类问题。它现在在 Google 内部各个领域得到广泛应用，包括: 1. 大规模机器学习问题2. Google News 和 Froogle 产品的集群问题 3. 从公众查询产品(比如 Google 的 Zeitgeist)的报告中抽取数据。 4. 从大量的新应用和新产品的网页中提取有用信息(比如，从大量的位置搜索网页中抽取地理位置信息)。 5. 大规模的图形计算。![](http://oliji9s3j.bkt.clouddn.com/15133916089336.jpg) 图四显示了在我们的源代码管理系统中，随着时间推移，独立的 MapReduce 程序数量的显著增加。从 2003 年早些时候的 0 个增长到 2004 年 9 月份的差不多 900 个不同的程序。MapReduce 的成功取决于采用 MapReduce 库能够在不到半个小时时间内写出一个简单的程序，这个简单的程序能够在上千台机器的组成的集群上做大 规模并发处理，这极大的加快了开发和原形设计的周期。另外，采用 MapReduce 库，可以让完全没有分布式 和/或并行系统开发经验的程序员很容易的利用大量的资源，开发出分布式和/或并行处理的应用。![](http://oliji9s3j.bkt.clouddn.com/15133916531743.jpg) 在每个任务结束的时候，MapReduce 库统计计算资源的使用状况。在表 1，我们列出了 2004 年 8 月份 MapReduce 运行的任务所占用的相关资源。 ### 大规模索引 到目前为止，MapReduce 最成功的应用就是重写了 Google 网络搜索服务所使用到的 index 系统。索引系 统的输入数据是网络爬虫抓取回来的海量的文档，这些文档数据都保存在 GFS 文件系统里。这些文档原始内 容4的大小超过了 20TB。索引程序是通过一系列的 MapReduce 操作(大约 5 到 10 次)来建立索引。使用 MapReduce(替换上一个特别设计的、分布式处理的索引程序)带来这些好处: 实现索引部分的代码简单、小巧、容易理解，因为对于容错、分布式以及并行计算的处理都是 MapReduce 库提供的。比如，使用 MapReduce 库，计算的代码行数从原来的 3800 行 C++代码减少到大概 700 行代码。 MapReduce 库的性能已经足够好了，因此我们可以把在概念上不相关的计算步骤分开处理，而不是混在 一起以期减少数据传递的额外消耗。概念上不相关的计算步骤的隔离也使得我们可以很容易改变索引处理方 式。比如，对之前的索引系统的一个小更改可能要耗费好几个月的时间，但是在使用 MapReduce 的新系统上， 这样的更改只需要花几天时间就可以了。 索引系统的操作管理更容易了。因为由机器失效、机器处理速度缓慢、以及网络的瞬间阻塞等引起的绝 大部分问题都已经由 MapReduce 库解决了，不再需要操作人员的介入了。另外，我们可以通过在索引系统集 群中增加机器的简单方法提高整体处理性能。 &#123;% note info %&#125;## 相关工作 &#123;% endnote %&#125;很多系统都提供了严格的编程模式，并且通过对编程的严格限制来实现并行计算。例如，一个结合函数可以通过把 N 个元素的数组的前缀在 N 个处理器上使用并行前缀算法，在 log N 的时间内计算完[6，9，13]5。 MapReduce 可以看作是我们结合在真实环境下处理海量数据的经验，对这些经典模型进行简化和萃取的成果。 更加值得骄傲的是，我们还实现了基于上千台处理器的集群的容错处理。相比而言，大部分并发处理系统都 只在小规模的集群上实现，并且把容错处理交给了程序员。 Bulk Synchronous Programming[17]和一些 MPI 原语[11]提供了更高级别的并行处理抽象，可以更容易写 出并行处理的程序。MapReduce 和这些系统的关键不同之处在于，MapReduce 利用限制性编程模式实现了用 户程序的自动并发处理，并且提供了透明的容错处理。 我们数据本地优化策略的灵感来源于 active disks[12,15]等技术，在 active disks 中，计算任务是尽量推送 到数据存储的节点处理6，这样就减少了网络和 IO 子系统的吞吐量。我们在挂载几个硬盘的普通机器上执行 我们的运算，而不是在磁盘处理器上执行我们的工作，但是达到的目的一样的。 我们的备用任务机制和 Charlotte System[3]提出的 eager 调度机制比较类似。Eager 调度机制的一个缺点是 如果一个任务反复失效，那么整个计算就不能完成。我们通过忽略引起故障的记录的方式在某种程度上解决 了这个问题。 MapReduce 的实现依赖于一个内部的集群管理系统，这个集群管理系统负责在一个超大的、共享机器的 集群上分布和运行用户任务。虽然这个不是本论文的重点，但是有必要提一下，这个集群管理系统在理念上 和其它系统，如 Condor[16]是一样。 MapReduce 库的排序机制和 NOW-Sort[1]的操作上很类似。读取输入源的机器(map workers)把待排序 的数据进行分区后，发送到 R 个 Reduce worker 中的一个进行处理。每个 Reduce worker 在本地对数据进行排 序(尽可能在内存中排序)。当然，NOW-Sort 没有给用户自定义的 Map 和 Reduce 函数的机会，因此不具备 MapReduce 库广泛的实用性。 River[2]提供了一个编程模型:处理进程通过分布式队列传送数据的方式进行互相通讯。和 MapReduce 类似，River 系统尝试在不对等的硬件环境下，或者在系统颠簸的情况下也能提供近似平均的性能。River 是 通过精心调度硬盘和网络的通讯来平衡任务的完成时间。MapReduce 库采用了其它的方法。通过对编程模型 进行限制，MapReduce 框架把问题分解成为大量的“小”任务。这些任务在可用的 worker 集群上动态的调度， 这样快速的 worker 就可以执行更多的任务。通过对编程模型进行限制，我们可用在工作接近完成的时候调度 备用任务，缩短在硬件配置不均衡的情况下缩小整个操作完成的时间(比如有的机器性能差、或者机器被某 些操作阻塞了)。 BAD-FS[5]采用了和 MapReduce 完全不同的编程模式，它是面向广域网(alex 注:wide-area network)的。不过，这两个系统有两个基础功能很类似。1. 两个系统采用重新执行的方式来防止由于失效导致的数据丢 失。2. 两个都使用数据本地化调度策略，减少网络通讯的数据量。 TACC[7]是一个用于简化构造高可用性网络服务的系统。和 MapReduce 一样，它也依靠重新执行机制来 实现的容错处理。 &#123;% note info %&#125;## 结束语 &#123;% endnote %&#125; MapReduce 编程模型在 Google 内部成功应用于多个领域。我们把这种成功归结为几个方面:首先，由于 MapReduce 封装了并行处理、容错处理、数据本地化优化、负载均衡等等技术难点的细节，这使得 MapReduce 库易于使用。即便对于完全没有并行或者分布式系统开发经验的程序员而言;其次，大量不同类型的问题都 可以通过 MapReduce 简单的解决。比如，MapReduce 用于生成 Google 的网络搜索服务所需要的数据、用来 排序、用来数据挖掘、用于机器学习，以及很多其它的系统;第三，我们实现了一个在数千台计算机组成的 大型集群上灵活部署运行的 MapReduce。这个实现使得有效利用这些丰富的计算资源变得非常简单，因此也 适合用来解决 Google 遇到的其他很多需要大量计算的问题。 我们也从 MapReduce 开发过程中学到了不少东西。首先，约束编程模式使得并行和分布式计算非常容易， 也易于构造容错的计算环境;其次，网络带宽是稀有资源。大量的系统优化是针对减少网络传输量为目的的: 本地优化策略使大量的数据从本地磁盘读取，中间文件写入本地磁盘、并且只写一份中间文件也节约了网络 带宽;第三，多次执行相同的任务可以减少性能缓慢的机器带来的负面影响(alex 注:即硬件配置的不平衡)， 同时解决了由于机器失效导致的数据丢失问题。 &#123;% note info %&#125;## 感谢 &#123;% endnote %&#125; Josh Levenberg has been instrumental in revising and extending the user-level MapReduce API with a number of new features based on his experience with using MapReduce and other people’s suggestions for enhancements. MapReduce reads its input from and writes its output to the Google File System [8]. We would like to thank Mohit Aron, Howard Gobioff, Markus Gutschke, David Kramer, Shun-Tak Leung, and Josh Redstone for their work in developing GFS. We would also like to thank Percy Liang and Olcan Sercinoglu for their work in developing the cluster management system used by MapReduce. Mike Burrows, Wilson Hsieh, Josh Levenberg, Sharon Perl, Rob Pike, and Debby Wallach provided helpful comments on earlier drafts of this paper.The anonymous OSDI reviewers, and our shepherd, Eric Brewer, provided many useful suggestions of areas where the paper could be improved. Finally, we thank all the users of MapReduce within Google’s engineering organization for providing helpful feedback, suggestions, and bug reports. &#123;% note info %&#125;## 参考资料 &#123;% endnote %&#125; [1] Andrea C. Arpaci-Dusseau, Remzi H. Arpaci-Dusseau,David E. Culler, Joseph M. Hellerstein, and David A. Patterson.High-performance sorting on networks of workstations.In Proceedings of the 1997 ACM SIGMOD InternationalConference on Management of Data, Tucson,Arizona, May 1997. [2] Remzi H. Arpaci-Dusseau, Eric Anderson, NoahTreuhaft, David E. Culler, Joseph M. Hellerstein, David Patterson, and Kathy Yelick. Cluster I/O with River:Making the fast case common. In Proceedings of the Sixth Workshop on Input/Output in Parallel and Distributed Systems (IOPADS ’99), pages 10.22, Atlanta, Georgia, May 1999. [3] Arash Baratloo, Mehmet Karaul, Zvi Kedem, and Peter Wyckoff. Charlotte: Metacomputing on the web. In Proceedings of the 9th International Conference on Parallel and Distributed Computing Systems, 1996. [4] Luiz A. Barroso, Jeffrey Dean, and Urs H ̈olzle. Web search for a planet: The Google cluster architecture. IEEE Micro, 23(2):22.28, April 2003. [5] John Bent, Douglas Thain, Andrea C.Arpaci-Dusseau, Remzi H. Arpaci-Dusseau, and Miron Livny. Explicit control in a batch-aware distributed file system. In Proceedings of the 1st USENIX Symposium on Networked Systems Design and Implementation NSDI, March 2004. [6] Guy E. Blelloch. Scans as primitive parallel operations.IEEE Transactions on Computers, C-38(11), November 1989. [7] Armando Fox, Steven D. Gribble, Yatin Chawathe, Eric A. Brewer, and Paul Gauthier. Cluster-based scalable network services. In Proceedings of the 16th ACM Symposium on Operating System Principles, pages 78. 91, Saint-Malo, France, 1997. [8] Sanjay Ghemawat, Howard Gobioff, and Shun-Tak Leung. The Google file system. In 19th Symposium on Operating Systems Principles, pages 29.43, Lake George, New York, 2003. To appear in OSDI 2004 12 [9] S. Gorlatch. Systematic efficient parallelization of scan and other list homomorphisms. In L. Bouge, P. Fraigniaud, A. Mignotte, and Y. Robert, editors, Euro-Par’96. Parallel Processing, Lecture Notes in Computer Science 1124, pages 401.408. Springer-Verlag, 1996. [10] Jim Gray. Sort benchmark home page. http://research.microsoft.com/barc/SortBenchmark/. [11] William Gropp, Ewing Lusk, and Anthony Skjellum. Using MPI: Portable Parallel Programming with the Message-Passing Interface. MIT Press, Cambridge, MA, 1999. [12] L. Huston, R. Sukthankar, R.Wickremesinghe, M. Satyanarayanan, G. R. Ganger, E. Riedel, and A. Ailamaki. Diamond: A storage architecture for early discard in interactive search. In Proceedings of the 2004USENIX File and Storage Technologies FAST Conference, April 2004. [13] Richard E. Ladner and Michael J. Fischer. Parallel prefix computation. Journal of the ACM, 27(4):831.838, 1980. [14] Michael O. Rabin. Efficient dispersal of information for security, load balancing and fault tolerance. Journal of the ACM, 36(2):335.348, 1989. [15] Erik Riedel, Christos Faloutsos, Garth A. Gibson, and David Nagle. Active disks for large-scale data processing. IEEE Computer, pages 68.74, June 2001. [16] Douglas Thain, Todd Tannenbaum, and Miron Livny. Distributed computing in practice: The Condor experience. Concurrency and Computation: Practice and Experience, 2004. [17] L. G. Valiant. A bridging model for parallel computation. Communications of the ACM, 33(8):103.111, 1997. [18] Jim Wyllie. Spsort: How to sort a terabyte quickly. http://alme1.almaden.ibm.com/cs/spsort.pdf.&#123;% note info %&#125;## 附录 A-单词频率统计 &#123;% endnote %&#125;本节包含了一个完整的程序，用于统计在一组命令行指定的输入文件中，每一个不同的单词出现频率。```python#include “mapreduce/mapreduce.h” // User’s map functionclass WordCounter :public Mapper&#123;public: virtual void Map(const MapInput&amp;input)&#123; const string&amp;text=input.value(); const int n=text.size(); for(int i=0;i&lt;n; )&#123;// Skip past leading whitespace while((i&lt;n)&amp;&amp;isspace(text[i]))i++;// Find word end int start=i; while((i&lt;n)&amp;&amp;!isspace(text[i]))i++; if(start&lt;i)Emit(text.substr(start,i-start),”1′′); &#125;&#125; &#125;; REGISTER_MAPPER(WordCounter);// User’s reduce functionclass Adder :public Reducer&#123; virtual void Reduce(ReduceInput*input)&#123; // Iterate over all entries with the// same key and add the values int64 value=0; while(!input-&gt;done())&#123; value+=StringToInt(input-&gt;value());input-&gt;NextValue(); &#125;// Emit sum for input-&gt;key() Emit(IntToString(value));&#125; &#125;; REGISTER_REDUCER(Adder); int main(int argc,char**argv)&#123;ParseCommandLineFlags(argc,argv); MapReduceSpecification spec;// Store list of input files into “spec” for(int i=1;i&lt;argc; i++)&#123; MapReduceInput*input=spec.add_input(); input-&gt;set_format(“text”); input-&gt;set_filepattern(argv[i]); input-&gt;set_mapper_class(“WordCounter”); &#125;// Specify the output files:// /gfs/test/freq-00000-of-00100// /gfs/test/freq-00001-of-00100// ... MapReduceOutput*out=spec.output(); out-&gt;set_filebase(“/gfs/test/freq”); out-&gt;set_num_tasks(100); out-&gt;set_format(“text”); out-&gt;set_reducer_class(“Adder”);// Optional: do partial sums within map tasks to save network bandwidth out-&gt;set_combiner_class(“Adder”);// Tuning parameters: use at most 2000// machines and 100 MB of memory per task spec.set_machines(2000); spec.set_map_megabytes(100); spec.set_reduce_megabytes(100);// Now run it MapReduceResult result; if(!MapReduce(spec,&amp;result))abort();// Done: ‘result’ structure contains info about counters, time taken, number of machines used, etc. return 0; &#125;","raw":null,"content":null,"categories":[{"name":"paper","slug":"paper","permalink":"https://stanxia.github.io/categories/paper/"}],"tags":[{"name":"paper","slug":"paper","permalink":"https://stanxia.github.io/tags/paper/"}]},{"title":"Google File System 中文版","slug":"Google-File-System-中文版","date":"2017-12-14T12:38:00.000Z","updated":"2019-04-17T06:08:31.918Z","comments":true,"path":"2017/12/14/Google-File-System-中文版/","link":"","permalink":"https://stanxia.github.io/2017/12/14/Google-File-System-中文版/","excerpt":"摘要\n我们设计并实现了 Google GFS 文件系统，一个面向大规模数据密集型应用的、可伸缩的分布式文件系统。GFS 虽然运行在廉价的普遍硬件设备上，但是它依然了提供灾难冗余的能力，为大量客户机提供了高性能的服务。\n虽然 GFS 的设计目标与许多传统的分布式文件系统有很多相同之处，但是，我们的设计还是以我们对自己的应用的负载情况和技术环境的分析为基础的，不管现在还是将来，GFS 和早期的分布式文件系统的设想都有明显的不同。所以我们重新审视了传统文件系统在设计上的折衷选择，衍生出了完全不同的设计思路。\nGFS 完全满足了我们对存储的需求。GFS 作为存储平台已经被广泛的部署在 Google 内部，存储我们的服务产生和处理的数据，同时还用于那些需要大规模数据集的研究和开发工作。目前为止，最大的一个集群利用数千台机器的数千个硬盘，提供了数百 TB 的存储空间，同时为数百个客户机服务。在本论文中，我们展示了能够支持分布式应用的文件系统接口的扩展，讨论我们设计的许多方面，最后列出了小规模性能测试以及真实生产系统中性能相关数据。","text":"摘要 我们设计并实现了 Google GFS 文件系统，一个面向大规模数据密集型应用的、可伸缩的分布式文件系统。GFS 虽然运行在廉价的普遍硬件设备上，但是它依然了提供灾难冗余的能力，为大量客户机提供了高性能的服务。 虽然 GFS 的设计目标与许多传统的分布式文件系统有很多相同之处，但是，我们的设计还是以我们对自己的应用的负载情况和技术环境的分析为基础的，不管现在还是将来，GFS 和早期的分布式文件系统的设想都有明显的不同。所以我们重新审视了传统文件系统在设计上的折衷选择，衍生出了完全不同的设计思路。 GFS 完全满足了我们对存储的需求。GFS 作为存储平台已经被广泛的部署在 Google 内部，存储我们的服务产生和处理的数据，同时还用于那些需要大规模数据集的研究和开发工作。目前为止，最大的一个集群利用数千台机器的数千个硬盘，提供了数百 TB 的存储空间，同时为数百个客户机服务。在本论文中，我们展示了能够支持分布式应用的文件系统接口的扩展，讨论我们设计的许多方面，最后列出了小规模性能测试以及真实生产系统中性能相关数据。简介 为了满足 Google 迅速增长的数据处理需求，我们设计并实现了 Google 文件系统(Google File System –GFS)。GFS 与传统的分布式文件系统有着很多相同的设计目标，比如，性能、可伸缩性、可靠性以及可用性。但是，我们的设计还基于我们对我们自己的应用的负载情况和技术环境的观察的影响，不管现在还是将来，GFS 和早期文件系统的假设都有明显的不同。所以我们重新审视了传统文件系统在设计上的折衷选择，衍生出了完全不同的设计思路。 首先，组件失效被认为是常态事件，而不是意外事件。GFS 包括几百甚至几千台普通的廉价设备组装的存储机器，同时被相当数量的客户机访问。GFS 组件的数量和质量导致在事实上，任何给定时间内都有可能发生某些组件无法工作，某些组件无法从它们目前的失效状态中恢复。我们遇到过各种各样的问题，比如应用程序 bug、操作系统的 bug、人为失误，甚至还有硬盘、内存、连接器、网络以及电源失效等造成的问题。所以，持续的监控、错误侦测、灾难冗余以及自动恢复的机制必须集成在 GFS 中。 其次，以通常的标准衡量，我们的文件非常巨大。数 GB 的文件非常普遍。每个文件通常都包含许多应用程序对象，比如 web 文档。当我们经常需要处理快速增长的、并且由数亿个对象构成的、数以 TB 的数据集时，采用管理数亿个 KB 大小的小文件的方式是非常不明智的，尽管有些文件系统支持这样的管理方式。因此，设计的假设条件和参数，比如 I/O 操作和 Block 的尺寸都需要重新考虑。 第三，绝大部分文件的修改是采用在文件尾部追加数据，而不是覆盖原有数据的方式。对文件的随机写入操作在实际中几乎不存在。一旦写完之后，对文件的操作就只有读，而且通常是按顺序读。大量的数据符合这些特性，比如：数据分析程序扫描的超大的数据集；正在运行的应用程序生成的连续的数据流；存档的数据；由一台机器生成、另外一台机器处理的中间数据，这些中间数据的处理可能是同时进行的、也可能是后续才处理的。对于这种针对海量文件的访问模式，客户端对数据块缓存是没有意义的，数据的追加操作是性能优化和原子性保证的主要考量因素。 第四，应用程序和文件系统 API 的协同设计提高了整个系统的灵活性。比如，我们放松了对 GFS 一致性模型的要求，这样就减轻了文件系统对应用程序的苛刻要求，大大简化了 GFS 的设计。我们引入了原子性的记录追加操作，从而保证多个客户端能够同时进行追加操作，不需要额外的同步操作来保证数据的一致性。本文后面还有对这些问题的细节的详细讨论。 Google 已经针对不同的应用部署了多套 GFS 集群。最大的一个集群拥有超过 1000 个存储节点，超过300TB 的硬盘空间，被不同机器上的数百个客户端连续不断的频繁访问。 设计概述 设计预期在设计满足我们需求的文件系统时候，我们的设计目标既有机会、又有挑战。之前我们已经提到了一些需要关注的关键点，这里我们将设计的预期目标的细节展开讨论。 系统由许多廉价的普通组件组成，组件失效是一种常态。系统必须持续监控自身的状态，它必须将组件失效作为一种常态，能够迅速地侦测、冗余并恢复失效的组件。 系统存储一定数量的大文件。我们预期会有几百万文件，文件的大小通常在 100MB 或者以上。数个 GB大小的文件也是普遍存在，并且要能够被有效的管理。系统也必须支持小文件，但是不需要针对小文件做专门的优化。 系统的工作负载主要由两种读操作组成：大规模的流式读取和小规模的随机读取。大规模的流式读取通常一次读取数百 KB 的数据，更常见的是一次读取 1MB 甚至更多的数据。来自同一个客户机的连续操作通常是读取同一个文件中连续的一个区域。小规模的随机读取通常是在文件某个随机的位置读取几个 KB 数据。如果应用程序对性能非常关注，通常的做法是把小规模的随机读取操作合并并排序，之后按顺序批量读取，这样就避免了在文件中前后来回的移动读取位置。 系统的工作负载还包括许多大规模的、顺序的、数据追加方式的写操作。一般情况下，每次写入的数据的大小和大规模读类似。数据一旦被写入后，文件就很少会被修改了。系统支持小规模的随机位置写入操作，但是可能效率不彰。 系统必须高效的、行为定义明确的（原文：well-defined）实现多客户端并行追加数据到同一个文件里的语意。我们的文件通常被用于“生产者-消费者”队列，或者其它多路文件合并操作。通常会有数百个生产者，每个生产者进程运行在一台机器上，同时对一个文件进行追加操作。使用最小的同步开销来实现的原子的多路追加数据操作是必不可少的。文件可以在稍后读取，或者是消费者在追加的操作的同时读取文件。 高性能的稳定网络带宽远比低延迟重要。我们的目标程序绝大部分要求能够高速率的、大批量的处理数据，极少有程序对单一的读写操作有严格的响应时间要求。 接口GFS 提供了一套类似传统文件系统的 API 接口函数，虽然并不是严格按照 POSIX 等标准 API 的形式实现的。文件以分层目录的形式组织，用路径名来标识。我们支持常用的操作，如创建新文件、删除文件、打开文件、关闭文件、读和写文件。 另外，GFS 提供了快照和记录追加操作。快照以很低的成本创建一个文件或者目录树的拷贝。记录追加操作允许多个客户端同时对一个文件进行数据追加操作，同时保证每个客户端的追加操作都是原子性的。这对于实现多路结果合并，以及“生产者-消费者”队列非常有用，多个客户端可以在不需要额外的同步锁定的情况下，同时对一个文件追加数据。我们发现这些类型的文件对于构建大型分布应用是非常重要的。快照和记录追加操作将在 3.4 和 3.3 节分别讨论。 架构一个 GFS 集群包含一个单独的 Master 节点（这里的一个单独的 Master 节点的含义是 GFS 系统中只存在一个逻辑上的 Master 组件。后面我们还会提到 Master 节点复制，因此，为了理解方便，我们把 Master 节点视为一个逻辑上的概念，一个逻辑的 Master 节点包括两台物理主机）、多台 Chunk 服务器，并且同时被多个客户端访问，如图 1所示。所有的这些机器通常都是普通的 Linux 机器，运行着用户级别(user-level)的服务进程。我们可以很容易的把 Chunk 服务器和客户端都放在同一台机器上，前提是机器资源允许，并且我们能够接受不可靠的应用程序代码带来的稳定性降低的风险。GFS 存储的文件都被分割成固定大小的 Chunk。在 Chunk 创建的时候，Master 服务器会给每个 Chunk 分配一个不变的、全球唯一的 64 位的 Chunk 标识。Chunk 服务器把 Chunk 以 Linux 文件的形式保存在本地硬盘上，并且根据指定的 Chunk 标识和字节范围来读写块数据。出于可靠性的考虑，每个块都会复制到多个块服务器上。缺省情况下，我们使用 3 个存储复制节点，不过用户可以为不同的文件命名空间设定不同的复制级别。 Master 节点管理所有的文件系统元数据。这些元数据包括名字空间、访问控制信息、文件和 Chunk 的映射信息、以及当前 Chunk 的位置信息。Master 节点还管理着系统范围内的活动，比如，Chunk 租用管理（BDB 也有关于 lease 的描述，不知道是否相同）、孤儿 Chunk（原文：orphaned chunks）的回收、以及 Chunk 在 Chunk 服务器之间的迁移。Master 节点使用心跳信息周期地和每个 Chunk服务器通讯，发送指令到各个 Chunk 服务器并接收 Chunk 服务器的状态信息。 GFS 客户端代码以库的形式被链接到客户程序里。客户端代码实现了 GFS 文件系统的 API 接口函数、应用程序与 Master 节点和 Chunk 服务器通讯、以及对数据进行读写操作。客户端和 Master 节点的通信只获取元数据，所有的数据操作都是由客户端直接和 Chunk 服务器进行交互的。我们不提供 POSIX 标准的 API 的功能，因此，GFS API 调用不需要深入到 Linux vnode 级别。 无论是客户端还是 Chunk 服务器都不需要缓存文件数据。客户端缓存数据几乎没有什么用处，因为大部分程序要么以流的方式读取一个巨大文件，要么工作集太大根本无法被缓存。无需考虑缓存相关的问题也简化了客户端和整个系统的设计和实现（注：不过，客户端会缓存元数据。）。Chunk 服务器不需要缓存文件数据的原因是，Chunk 以本地文件的方式保存，Linux 操作系统的文件系统缓存会把经常访问的数据缓存在内存中。 单一 Master 节点单一的 Master 节点的策略大大简化了我们的设计。单一的 Master 节点可以通过全局的信息精确定位Chunk 的位置以及进行复制决策。另外，我们必须减少对 Master 节点的读写，避免 Master 节点成为系统的瓶颈。客户端并不通过 Master 节点读写文件数据。反之，客户端向 Master 节点询问它应该联系的 Chunk 服务器。客户端将这些元数据信息缓存一段时间，后续的操作将直接和 Chunk 服务器进行数据读写操作。 我们利用图 1 解释一下一次简单读取的流程。首先，客户端把文件名和程序指定的字节偏移，根据固定的 Chunk 大小，转换成文件的 Chunk 索引。然后，它把文件名和 Chunk 索引发送给 Master 节点。Master 节点将相应的 Chunk 标识和副本的位置信息发还给客户端。客户端用文件名和 Chunk 索引作为 key 缓存这些信息。 之后客户端发送请求到其中的一个副本处，一般会选择最近的。请求信息包含了 Chunk 的标识和字节范围。在对这个 Chunk 的后续读取操作中，客户端不必再和 Master 节点通讯了，除非缓存的元数据信息过期或者文件被重新打开。实际上，客户端通常会在一次请求中查询多个 Chunk 信息，Master 节点的回应也可能包含了紧跟着这些被请求的 Chunk 后面的 Chunk 的信息。在实际应用中，这些额外的信息在没有任何代价的情况下，避免了客户端和 Master 节点未来可能会发生的几次通讯。 Chunk 尺寸Chunk 的大小是关键的设计参数之一。我们选择了 64MB，这个尺寸远远大于一般文件系统的 Block size。每个 Chunk 的副本都以普通 Linux 文件的形式保存在 Chunk 服务器上，只有在需要的时候才扩大。惰性空间分配策略避免了因内部碎片造成的空间浪费，内部碎片或许是对选择这么大的 Chunk 尺寸最具争议一点。 选择较大的 Chunk 尺寸有几个重要的优点。首先，它减少了客户端和 Master 节点通讯的需求，因为只需要一次和 Mater 节点的通信就可以获取 Chunk 的位置信息，之后就可以对同一个 Chunk 进行多次的读写操作。这种方式对降低我们的工作负载来说效果显著，因为我们的应用程序通常是连续读写大文件。即使是小规模的随机读取，采用较大的 Chunk 尺寸也带来明显的好处，客户端可以轻松的缓存一个数 TB 的工作数据集所有的 Chunk 位置信息。其次，采用较大的 Chunk 尺寸，客户端能够对一个块进行多次操作，这样就可以通过与 Chunk 服务器保持较长时间的 TCP 连接来减少网络负载。第三，选用较大的 Chunk 尺寸减少了 Master节点需要保存的元数据的数量。这就允许我们把元数据全部放在内存中，在 2.6.1 节我们会讨论元数据全部放在内存中带来的额外的好处。 另一方面，即使配合惰性空间分配，采用较大的 Chunk 尺寸也有其缺陷。小文件包含较少的 Chunk，甚至只有一个 Chunk。当有许多的客户端对同一个小文件进行多次的访问时，存储这些 Chunk 的 Chunk 服务器就会变成热点。在实际应用中，由于我们的程序通常是连续的读取包含多个 Chunk 的大文件，热点还不是主要的问题。 然而，当我们第一次把 GFS 用于批处理队列系统的时候，热点的问题还是产生了：一个可执行文件在GFS 上保存为 single-chunk 文件，之后这个可执行文件在数百台机器上同时启动。存放这个可执行文件的几个 Chunk 服务器被数百个客户端的并发请求访问导致系统局部过载。我们通过使用更大的复制参数来保存可执行文件，以及错开批处理队列系统程序的启动时间的方法解决了这个问题。一个可能的长效解决方案是，在这种的情况下，允许客户端从其它客户端读取数据。 元数据Master 服务器（注意逻辑的 Master 节点和物理的 Master 服务器的区别。后续我们谈的是每个 Master 服务器的行为，如存储、内存等等，因此我们将全部使用物理名称）存储 3 种主要类型的元数据，包括：文件和 Chunk 的命名空间、文件和 Chunk 的对应关系、每个 Chunk 副本的存放地点。所有的元数据都保存在 Master 服务器的内存中。前两种类型的 元数据（元数据：命名空间、文件和 Chunk 的对应关系）同时也会以记录变更日志的方式记录在操作系统的系统日志文件中，日志文件存储在本地磁盘上，同时日志会被复制到其它的远程Master服务器上。采用保存变更日志的方式，我们能够简单可靠的更新 Master 服务器的状态，并且不用担心 Master 服务器崩溃导致数据不一致的风险。Master 服务器不会持久保存 Chunk 位置信息。Master服务器在启动时，或者有新的 Chunk 服务器加入时，向各个 Chunk 服务器轮询它们所存储的 Chunk 的信息。 内存中的数据结构因为元数据保存在内存中，所以 Master 服务器的操作速度非常快。并且，Master 服务器可以在后台简单而高效的周期性扫描自己保存的全部状态信息。这种周期性的状态扫描也用于实现 Chunk 垃圾收集、在 Chunk服务器失效的时重新复制数据、通过 Chunk 的迁移实现跨 Chunk 服务器的负载均衡以及磁盘使用状况统计等功能。4.3 和 4.4 章节将深入讨论这些行为。 将元数据全部保存在内存中的方法有潜在问题：Chunk 的数量以及整个系统的承载能力都受限于 Master服务器所拥有的内存大小。但是在实际应用中，这并不是一个严重的问题。Master 服务器只需要不到 64 个字节的元数据就能够管理一个 64MB 的 Chunk。由于大多数文件都包含多个 Chunk，因此绝大多数 Chunk 都是满的，除了文件的最后一个 Chunk 是部分填充的。同样的，每个文件的在命名空间中的数据大小通常在 64字节以下，因为保存的文件名是用前缀压缩算法压缩过的。 即便是需要支持更大的文件系统，为 Master 服务器增加额外内存的费用是很少的，而通过增加有限的费用，我们就能够把元数据全部保存在内存里，增强了系统的简洁性、可靠性、高性能和灵活性。 Chunk 位置信息Master 服务器并不保存持久化保存哪个 Chunk 服务器存有指定 Chunk 的副本的信息。Master 服务器只是在启动的时候轮询 Chunk 服务器以获取这些信息。Master 服务器能够保证它持有的信息始终是最新的，因为它控制了所有的 Chunk 位置的分配，而且通过周期性的心跳信息监控 Chunk 服务器的状态。 最初设计时，我们试图把 Chunk 的位置信息持久的保存在 Master 服务器上，但是后来我们发现在启动的时候轮询 Chunk 服务器，之后定期轮询更新的方式更简单。这种设计简化了在有 Chunk 服务器加入集群、离开集群、更名、失效、以及重启的时候，Master 服务器和 Chunk 服务器数据同步的问题。在一个拥有数百台服务器的集群中，这类事件会频繁的发生。 可以从另外一个角度去理解这个设计决策：只有 Chunk 服务器才能最终确定一个 Chunk 是否在它的硬盘上。我们从没有考虑过在 Master 服务器上维护一个这些信息的全局视图，因为 Chunk 服务器的错误可能会导致 Chunk 自动消失(比如，硬盘损坏了或者无法访问了)，亦或者操作人员可能会重命名一个 Chunk 服务器。 操作日志操作日志包含了关键的元数据变更历史记录。这对 GFS 非常重要。这不仅仅是因为操作日志是元数据唯一的持久化存储记录，它也作为判断同步操作顺序的逻辑时间基线(也就是通过逻辑日志的序号作为操作发生的逻辑时间，类似于事务系统中的 LSN)。文件和 Chunk，连同它们的版本(参考4.5 节)，都由它们创建的逻辑时间唯一的、永久的标识。 操作日志非常重要，我们必须确保日志文件的完整，确保只有在元数据的变化被持久化后，日志才对客户端是可见的。否则，即使 Chunk 本身没有出现任何问题，我们仍有可能丢失整个文件系统，或者丢失客户端最近的操作。所以，我们会把日志复制到多台远程机器，并且只有把相应的日志记录写入到本地以及远程机器的硬盘后，才会响应客户端的操作请求。Master 服务器会收集多个日志记录后批量处理，以减少写入磁盘和复制对系统整体性能的影响。 Master 服务器在灾难恢复时，通过重演操作日志把文件系统恢复到最近的状态。为了缩短 Master 启动的时间，我们必须使日志足够小(即重演系统操作的日志量尽量的少)。Master 服务器在日志增长到一定量时对系统状态做一次 Checkpoint(Checkpoint 是一种行为，一种对数据库状态作一次快照的行为)，将所有的状态数据写入一个 Checkpoint 文件(注：并删除之前的日志文件)。在灾难恢复的时候，Master 服务器就通过从磁盘上读取这个Checkpoint 文件，以及重演 Checkpoint 之后的有限个日志文件就能够恢复系统。Checkpoint 文件以压缩 B-树形势的数据结构存储，可以直接映射到内存，在用于命名空间查询时无需额外的解析。这大大提高了恢复速度，增强了可用性。 由于创建一个 Checkpoint 文件需要一定的时间，所以 Master 服务器的内部状态被组织为一种格式，这种格式要确保在 Checkpoint 过程中不会阻塞正在进行的修改操作。Master 服务器使用独立的线程切换到新的日志文件和创建新的 Checkpoint 文件。新的 Checkpoint 文件包括切换前所有的修改。对于一个包含数百万个文件的集群，创建一个 Checkpoint 文件需要 1 分钟左右的时间。创建完成后，Checkpoint 文件会被写入在本地和远程的硬盘里。 Master 服务器恢复只需要最新的 Checkpoint 文件和后续的日志文件。旧的 Checkpoint 文件和日志文件可以被删除，但是为了应对灾难性的故障(catastrophes，数据备份相关文档中经常会遇到这个词，表示一种超出预期范围的灾难性事件)，我们通常会多保存一些历史文件。Checkpoint 失败不会对正确性产生任何影响，因为恢复功能的代码可以检测并跳过没有完成的 Checkpoint 文件。 一致性模型GFS 支持一个宽松的一致性模型，这个模型能够很好的支撑我们的高度分布的应用，同时还保持了相对简单且容易实现的优点。本节我们讨论 GFS 的一致性的保障机制，以及对应用程序的意义。我们也着重描述了 GFS 如何管理这些一致性保障机制，但是实现的细节将在本论文的其它部分讨论。 GFS 一致性保障机制文件命名空间的修改（例如，文件创建）是原子性的。它们仅由 Master 节点的控制：命名空间锁提供了原子性和正确性（4.1 章）的保障；Master 节点的操作日志定义了这些操作在全局的顺序（2.6.3 章）。数据修改后文件 region的状态取决于操作的类型、成功与否、以及是否同步修改。表 1 总结了各种操作的结果。 如果所有客户端，无论从哪个副本读取，读到的数据都一样，那么我们认为文件 region 是“一致的”；如果对文件的数据修改之后，region 是一致的，并且客户端能够看到写入操作全部的内容，那么这个 region是“已定义的”。 当一个数据修改操作成功执行，并且没有受到同时执行的其它写入操作的干扰，那么影响的 region 就是已定义的（隐含了一致性）：所有的客户端都可以看到写入的内容。并行修改操作成功完成之后，region 处于一致的、未定义的状态：所有的客户端看到同样的数据，但是无法读到任何一次写入操作写入的数据。通常情况下，文件 region 内包含了来自多个修改操作的、混杂的数据片段。失败的修改操作导致一个 region 处于不一致状态（同时也是未定义的）：不同的客户在不同的时间会看到不同的数据。后面我们将描述应用如何区分已定义和未定义的 region。应用程序没有必要再去细分未定义 region 的不同类型。 数据修改操作分为写入或者记录追加两种。写入操作把数据写在应用程序指定的文件偏移位置上。即使有多个修改操作并行执行时，记录追加操作至少可以把数据原子性的追加到文件中一次，但是偏移位置是由GFS 选择的（3.3 章）(这句话有点费解，其含义是所有的追加写入都会成功，但是有可能被执行了多次，而且每次追加的文件偏移量由 GFS 自己计算。相比而言，通常说的追加操作写的偏移位置是文件的尾部)。GFS 返回给客户端一个偏移量，表示了包含了写入记录的、已定义的 region 的起点。另外，GFS 可能会在文件中间插入填充数据或者重复记录。这些数据占据的文件 region 被认定是不一致的，这些数据通常比用户数据小的多。 经过了一系列的成功的修改操作之后，GFS 确保被修改的文件 region 是已定义的，并且包含最后一次修改操作写入的数据。GFS 通过以下措施确保上述行为：（a） 对 Chunk 的所有副本的修改操作顺序一致（3.1章），（b）使用 Chunk 的版本号来检测副本是否因为它所在的 Chunk 服务器宕机（4.5 章）而错过了修改操作而导致其失效。失效的副本不会再进行任何修改操作，Master 服务器也不再返回这个 Chunk 副本的位置信息给客户端。它们会被垃圾收集系统尽快回收。 由于 Chunk 位置信息会被客户端缓存，所以在信息刷新前，客户端有可能从一个失效的副本读取了数据。在缓存的超时时间和文件下一次被打开的时间之间存在一个时间窗，文件再次被打开后会清除缓存中与该文件有关的所有 Chunk 位置信息。而且，由于我们的文件大多数都是只进行追加操作的，所以，一个失效的副本通常返回一个提前结束的 Chunk 而不是过期的数据。当一个 Reader(本文中将用到两个专有名词，Reader 和 Writer，分别表示执行 GFS 读取和写入操作的程序)重新尝试并联络 Master 服务器时，它就会立刻得到最新的 Chunk 位置信息。 即使在修改操作成功执行很长时间之后，组件的失效也可能损坏或者删除数据。GFS 通过 Master 服务器和所有 Chunk 服务器的定期“握手”来找到失效的 Chunk 服务器，并且使用 Checksum 来校验数据是否损坏（5.2 章）。一旦发现问题，数据要尽快利用有效的副本进行恢复（4.3 章）。只有当一个 Chunk 的所有副本在 GFS 检测到错误并采取应对措施之前全部丢失，这个 Chunk 才会不可逆转的丢失。在一般情况下 GFS 的反应时间(指 Master 节点检测到错误并采取应对措施)是几分钟。即使在这种情况下，Chunk 也只是不可用了，而不是损坏了：应用程序会收到明确的错误信息而不是损坏的数据。 程序的实现使用 GFS 的应用程序可以利用一些简单技术实现这个宽松的一致性模型，这些技术也用来实现一些其它的目标功能，包括：尽量采用追加写入而不是覆盖，Checkpoint，自验证的写入操作，自标识的记录。 在实际应用中，我们所有的应用程序对文件的写入操作都是尽量采用数据追加方式，而不是覆盖方式。一种典型的应用，应用程序从头到尾写入数据，生成了一个文件。写入所有数据之后，应用程序自动将文件改名为一个永久保存的文件名，或者周期性的作 Checkpoint，记录成功写入了多少数据。Checkpoint 文件可以包含程序级别的校验和。Readers 仅校验并处理上个 Checkpoint 之后产生的文件 region，这些文件 region 的状态一定是已定义的。这个方法满足了我们一致性和并发处理的要求。追加写入比随机位置写入更加有效率，对应用程序的失败处理更具有弹性。Checkpoint 可以让 Writer 以渐进的方式重新开始，并且可以防止 Reader处理已经被成功写入，但是从应用程序的角度来看还并未完成的数据。 我们再来分析另一种典型的应用。许多应用程序并行的追加数据到同一个文件，比如进行结果的合并或者是一个生产者-消费者队列。记录追加方式的“至少一次追加”的特性保证了 Writer 的输出。Readers 使用下面的方法来处理偶然性的填充数据和重复内容。Writers 在每条写入的记录中都包含了额外的信息，例如Checksum，用来验证它的有效性。Reader 可以利用 Checksum 识别和抛弃额外的填充数据和记录片段。如果应用不能容忍偶尔的重复内容(比如，如果这些重复数据触发了非幂等操作)，可以用记录的唯一标识符来过滤它们，这些唯一标识符通常用于命名程序中处理的实体对象，例如 web 文档。这些记录 I/O 功能(These functionalities for record I/O，除了剔除重复数据的功能)都包含在我们的程序共享的库中，并且适用于 Google 内部的其它的文件接口实现。所以，相同序列的记录，加上一些偶尔出现的重复数据，都被分发到 Reader 了。 系统交互我们在设计这个系统时，一个重要的原则是最小化所有操作和 Master 节点的交互。带着这样的设计理念，我们现在描述一下客户机、Master 服务器和 Chunk 服务器如何进行交互，以实现数据修改操作、原子的记录追加操作以及快照功能。 租约（lease）和变更顺序变更是一个会改变 Chunk 内容或者元数据的操作，比如写入操作或者记录追加操作。变更操作会在 Chunk的所有副本上执行。我们使用租约（lease）机制来保持多个副本间变更顺序的一致性。Master 节点为 Chunk的一个副本建立一个租约，我们把这个副本叫做主 Chunk。主 Chunk 对 Chunk 的所有更改操作进行序列化。所有的副本都遵从这个序列进行修改操作。因此，修改操作全局的顺序首先由 Master 节点选择的租约的顺序决定，然后由租约中主 Chunk 分配的序列号决定。 设计租约机制的目的是为了最小化 Master 节点的管理负担。租约的初始超时设置为 60 秒。不过，只要Chunk 被修改了，主 Chunk 就可以申请更长的租期，通常会得到 Master 节点的确认并收到租约延长的时间。这些租约延长请求和批准的信息通常都是附加在 Master 节点和 Chunk 服务器之间的心跳消息中来传递。有时Master 节点会试图提前取消租约（例如，Master 节点想取消在一个已经被改名的文件上的修改操作）。即使Master节点和主Chunk失去联系，它仍然可以安全地在旧的租约到期后和另外一个Chunk副本签订新的租约。 在图 2 中，我们依据步骤编号，展现写入操作的控制流程。 客户机向 Master 节点询问哪一个 Chunk 服务器持有当前的租约，以及其它副本的位置。如果没有一个 Chunk 持有租约，Master 节点就选择其中一个副本建立一个租约(这个步骤在图上没有显示)。 Master 节点将主 Chunk 的标识符以及其它副本(又称为 secondary 副本、二级副本)的位置返回给客户 机。客户机缓存这些数据以便后续的操作。只有在主 Chunk 不可用，或者主 Chunk 回复信息表明它已不再持 有租约的时候，客户机才需要重新跟 Master 节点联系。 客户机把数据推送到所有的副本上。客户机可以以任意的顺序推送数据。Chunk 服务器接收到数据并保 存在它的内部 LRU 缓存中，一直到数据被使用或者过期交换出去。由于数据流的网络传输负载非常高，通过 分离数据流和控制流，我们可以基于网络拓扑情况对数据流进行规划，提高系统性能，而不用去理会哪个 Chunk 服务器保存了主 Chunk。3.2 章节会进一步讨论这点。 当所有的副本都确认接收到了数据，客户机发送写请求到主 Chunk 服务器。这个请求标识了早前推送到 所有副本的数据。主 Chunk 为接收到的所有操作分配连续的序列号，这些操作可能来自不同的客户机，序列 号保证了操作顺序执行。它以序列号的顺序把操作应用到它自己的本地状态中(alex 注:也就是在本地执行这些操作，这句话按字面翻译有点费解，也许应该翻译为“它顺序执行这些操作，并更新自己的状态”)。 主 Chunk 把写请求传递到所有的二级副本。每个二级副本依照主 Chunk 分配的序列号以相同的顺序执行 这些操作。所有的二级副本回复主 Chunk，它们已经完成了操作。 主 Chunk 服务器20回复客户机。任何副本产生的任何错误都会返回给客户机。在出现错误的情况下，写 入操作可能在主 Chunk 和一些二级副本执行成功。(如果操作在主 Chunk 上失败了，操作就不会被分配序列 号，也不会被传递。)客户端的请求被确认为失败，被修改的 region 处于不一致的状态。我们的客户机代码通 过重复执行失败的操作来处理这样的错误。在从头开始重复执行之前，客户机会先从步骤(3)到步骤(7) 做几次尝试。 如果应用程序一次写入的数据量很大，或者数据跨越了多个 Chunk，GFS 客户机代码会把它们分成多个 写操作。这些操作都遵循前面描述的控制流程，但是可能会被其它客户机上同时进行的操作打断或者覆盖。 因此，共享的文件 region 的尾部可能包含来自不同客户机的数据片段，尽管如此，由于这些分解后的写入操 作在所有的副本上都以相同的顺序执行完成，Chunk 的所有副本都是一致的。这使文件 region 处于 2.7 节描述 的一致的、但是未定义的状态。 数据流为了提高网络效率，我们采取了把数据流和控制流分开的措施。在控制流从客户机到主 Chunk、然后再 到所有二级副本的同时，数据以管道的方式，顺序的沿着一个精心选择的 Chunk 服务器链推送。我们的目标 是充分利用每台机器的带宽，避免网络瓶颈和高延时的连接，最小化推送所有数据的延时。 为了充分利用每台机器的带宽，数据沿着一个 Chunk 服务器链顺序的推送，而不是以其它拓扑形式分散 推送(例如，树型拓扑结构)。线性推送模式下，每台机器所有的出口带宽都用于以最快的速度传输数据，而 不是在多个接受者之间分配带宽。 为了尽可能的避免出现网络瓶颈和高延迟的链接(eg，inter-switch 最有可能出现类似问题)，每台机器 都尽量的在网络拓扑中选择一台还没有接收到数据的、离自己最近的机器作为目标推送数据。假设客户机把 数据从 Chunk 服务器 S1 推送到 S4。它把数据推送到最近的 Chunk 服务器 S1。S1 把数据推送到 S2，因为 S2 和 S4 中最接近的机器是 S2。同样的，S2 把数据传递给 S3 和 S4 之间更近的机器，依次类推推送下去。我们 的网络拓扑非常简单，通过 IP 地址就可以计算出节点的“距离”。 最后，我们利用基于 TCP 连接的、管道式数据推送方式来最小化延迟。Chunk 服务器接收到数据后， 马上开始向前推送。管道方式的数据推送对我们帮助很大，因为我们采用全双工的交换网络。接收到数据后(即主 Chunk 所在的 Chunk 服务器)立刻向前推送不会降低接收的速度。在没有网络拥塞的情况下，传送 B 字节的数据到 R 个副本的理想时间是 B/T+RL ，T 是网络的吞吐量，L 是在两台机器数据传输的延迟。通常情况下，我们的网络连接速度是 100Mbps(T)，L 将远小于 1ms。因此，1MB 的数据在理想情况下 80ms 左右就能分发出去。 原子的记录追加GFS 提供了一种原子的数据追加操作–记录追加。传统方式的写入操作，客户程序会指定数据写入的偏 移量。对同一个 region 的并行写入操作不是串行的:region 尾部可能会包含多个不同客户机写入的数据片段。 使用记录追加，客户机只需要指定要写入的数据。GFS 保证至少有一次原子的写入操作成功执行(即写入一 个顺序的 byte 流)，写入的数据追加到 GFS 指定的偏移位置上，之后 GFS 返回这个偏移量给客户机。这类似 于在 Unix 操作系统编程环境中，对以 O_APPEND 模式打开的文件，多个并发写操作在没有竞态条件时的行 为。 记录追加在我们的分布应用中非常频繁的使用，在这些分布式应用中，通常有很多的客户机并行地对同 一个文件追加写入数据。如果我们采用传统方式的文件写入操作，客户机需要额外的复杂、昂贵的同步机制， 例如使用一个分布式的锁管理器。在我们的工作中，这样的文件通常用于多个生产者/单一消费者的队列系统， 或者是合并了来自多个客户机的数据的结果文件。 记录追加是一种修改操作，它也遵循 3.1 节描述的控制流程，除了在主 Chunk 有些额外的控制逻辑。客 户机把数据推送给文件最后一个 Chunk 的所有副本，之后发送请求给主 Chunk。主 Chunk 会检查这次记录追 加操作是否会使 Chunk 超过最大尺寸(64MB)。如果超过了最大尺寸，主 Chunk 首先将当前 Chunk 填充到最 大尺寸，之后通知所有二级副本做同样的操作，然后回复客户机要求其对下一个 Chunk 重新进行记录追加操 作。(记录追加的数据大小严格控制在 Chunk 最大尺寸的 1/4，这样即使在最坏情况下，数据碎片的数量仍然 在可控的范围。)通常情况下追加的记录不超过 Chunk 的最大尺寸，主 Chunk 把数据追加到自己的副本内， 然后通知二级副本把数据写在跟主 Chunk 一样的位置上，最后回复客户机操作成功。 如果记录追加操作在任何一个副本上失败了，客户端就需要重新进行操作。重新进行记录追加的结果是， 同一个 Chunk 的不同副本可能包含不同的数据–重复包含一个记录全部或者部分的数据。GFS 并不保证 Chunk 的所有副本在字节级别是完全一致的。它只保证数据作为一个整体原子的被至少写入一次。这个特性可以通 过简单观察推导出来:如果操作成功执行，数据一定已经写入到 Chunk 的所有副本的相同偏移位置上。这之 后，所有的副本至少都到了记录尾部的长度，任何后续的记录都会追加到更大的偏移地址，或者是不同的 Chunk 上，即使其它的 Chunk 副本被 Master 节点选为了主 Chunk。就我们的一致性保障模型而言，记录追加 操作成功写入数据的 region 是已定义的(因此也是一致的)，反之则是不一致的(因此也就是未定义的)。正如我们在 2.7.2 节讨论的，我们的程序可以处理不一致的区域。 快照快照操作几乎可以瞬间完成对一个文件或者目录树(“源”)做一个拷贝，并且几乎不会对正在进行的其 它操作造成任何干扰。我们的用户可以使用快照迅速的创建一个巨大的数据集的分支拷贝(而且经常是递归 的拷贝拷贝)，或者是在做实验性的数据操作之前，使用快照操作备份当前状态，这样之后就可以轻松的提交 或者回滚到备份时的状态。 就像 AFS(alex 注:AFS，即 Andrew File System，一种分布式文件系统)，我们用标准的 copy-on-write 技术实现快照。当 Master 节点收到一个快照请求，它首先取消作快照的文件的所有 Chunk 的租约。这个措施 保证了后续对这些 Chunk 的写操作都必须与 Master 交互以找到租约持有者。这就给 Master 节点一个率先创建 Chunk 的新拷贝的机会。 租约取消或者过期之后，Master 节点把这个操作以日志的方式记录到硬盘上。然后，Master 节点通过复 制源文件或者目录的元数据的方式，把这条日志记录的变化反映到保存在内存的状态中。新创建的快照文件 和源文件指向完全相同的 Chunk 地址。 在快照操作之后，当客户机第一次想写入数据到 Chunk C，它首先会发送一个请求到 Master 节点查询当 前的租约持有者。Master 节点注意到 Chunk C 的引用计数超过了 1。Master 节点不会马上回复客户机的请求， 而是选择一个新的 Chunk 句柄 C。之后，Master 节点要求每个拥有 Chunk C 当前副本的 Chunk 服务器创建一 个叫做 C的新 Chunk。通过在源 Chunk 所在 Chunk 服务器上创建新的 Chunk，我们确保数据在本地而不是通 过网络复制(我们的硬盘比我们的 100Mb 以太网大约快 3 倍)。从这点来讲，请求的处理方式和任何其它 Chunk 没什么不同:Master 节点确保新 Chunk C`的一个副本拥有租约，之后回复客户机，客户机得到回复后就可以 正常的写这个 Chunk，而不必理会它是从一个已存在的 Chunk 克隆出来的。 Master 节点的操作Master 节点执行所有的名称空间操作。此外，它还管理着整个系统里所有 Chunk 的副本:它决定 Chunk 的存储位置，创建新 Chunk 和它的副本，协调各种各样的系统活动以保证 Chunk 被完全复制，在所有的 Chunk 服务器之间的进行负载均衡，回收不再使用的存储空间。本节我们讨论上述的主题。 名称空间管理和锁Master 节点的很多操作会花费很长的时间:比如，快照操作必须取消 Chunk 服务器上快照所涉及的所有 的 Chunk 的租约。我们不希望在这些操作的运行时，延缓了其它的 Master 节点的操作。因此，我们允许多个 操作同时进行，使用名称空间的 region 上的锁来保证执行的正确顺序。 不同于许多传统文件系统，GFS 没有针对每个目录实现能够列出目录下所有文件的数据结构。GFS 也不 支持文件或者目录的链接(即 Unix 术语中的硬链接或者符号链接)。在逻辑上，GFS 的名称空间就是一个全 路径和元数据映射关系的查找表。利用前缀压缩，这个表可以高效的存储在内存中。在存储名称空间的树型 结构上，每个节点(绝对路径的文件名或绝对路径的目录名)都有一个关联的读写锁。 每个 Master 节点的操作在开始之前都要获得一系列的锁。通常情况下，如果一个操作涉及/d1/d2/… /dn/leaf，那么操作首先要获得目录/d1，/d1/d2，…，/d1/d2/…/dn 的读锁，以及/d1/d2/…/dn/leaf 的读写锁。注 意，根据操作的不同，leaf 可以是一个文件，也可以是一个目录。 现在，我们演示一下在/home/user 被快照到/save/user 的时候，锁机制如何防止创建文件/home/user/foo。 快照操作获取/home 和/save 的读取锁，以及/home/user 和/save/user 的写入锁。文件创建操作获得/home 和 /home/user 的读取锁，以及/home/user/foo 的写入锁。这两个操作要顺序执行，因为它们试图获取的/home/user 的锁是相互冲突。文件创建操作不需要获取父目录的写入锁，因为这里没有“目录”，或者类似 inode 等用来 禁止修改的数据结构。文件名的读取锁足以防止父目录被删除。 采用这种锁方案的优点是支持对同一目录的并行操作。比如，可以再同一个目录下同时创建多个文件: 每一个操作都获取一个目录名的上的读取锁和文件名上的写入锁。目录名的读取锁足以的防止目录被删除、 改名以及被快照。文件名的写入锁序列化文件创建操作，确保不会多次创建同名的文件。 因为名称空间可能有很多节点，读写锁采用惰性分配策略，在不再使用的时候立刻被删除。同样，锁的 获取也要依据一个全局一致的顺序来避免死锁:首先按名称空间的层次排序，在同一个层次内按字典顺序排序。 副本的位置GFS 集群是高度分布的多层布局结构，而不是平面结构。典型的拓扑结构是有数百个 Chunk 服务器安装 在许多机架上。Chunk 服务器被来自同一或者不同机架上的数百个客户机轮流访问。不同机架上的两台机器 间的通讯可能跨越一个或多个网络交换机。另外，机架的出入带宽可能比机架内所有机器加和在一起的带宽 要小。多层分布架构对数据的灵活性、可靠性以及可用性方面提出特有的挑战。 Chunk 副本位置选择的策略服务两大目标:最大化数据可靠性和可用性，最大化网络带宽利用率。为了 实现这两个目的，仅仅是在多台机器上分别存储这些副本是不够的，这只能预防硬盘损坏或者机器失效带来的影响，以及最大化每台机器的网络带宽利用率。我们必须在多个机架间分布储存 Chunk 的副本。这保证 Chunk 的一些副本在整个机架被破坏或掉线(比如，共享资源，如电源或者网络交换机造成的问题)的情况下依然 存在且保持可用状态。这还意味着在网络流量方面，尤其是针对 Chunk 的读操作，能够有效利用多个机架的整合带宽。另一方面，写操作必须和多个机架上的设备进行网络通信，但是这个代价是我们愿意付出的。 创建，重新复制，重新负载均衡Chunk 的副本有三个用途:Chunk 创建，重新复制和重新负载均衡。当 Master 节点创建一个 Chunk 时，它会选择在哪里放置初始的空的副本。Master 节点会考虑几个因素 :(1)我们希望在低于平均硬盘使用率的 Chunk 服务器上存储新的副本。这样的做法最终能够平衡Chunk服务器之间的硬盘使用率。 (2)我们希望限制在每个 Chunk 服务器上“最近”的 Chunk 创建操作的次数。虽然创建操作本身是廉价的，但是创建操作也意味着随之会有大量的写入数据的操作，因为 Chunk 在 Writer 真正写入数据的时候才 被创建，而在我们的“追加一次，读取多次”的工作模式下，Chunk 一旦写入成功之后就会变为只读的了。 (3)如上所述，我们希望把 Chunk 的副本分布在多个机架之间。 当 Chunk 的有效副本数量少于用户指定的复制因数的时候，Master 节点会重新复制它。这可能是由几个 原因引起的:一个 Chunk 服务器不可用了，Chunk 服务器报告它所存储的一个副本损坏了，Chunk 服务器的 一个磁盘因为错误不可用了，或者 Chunk 副本的复制因数提高了。每个需要被重新复制的 Chunk 都会根据几 个因素进行排序。一个因素是 Chunk 现有副本数量和复制因数相差多少。例如，丢失两个副本的 Chunk 比丢 失一个副本的 Chunk 有更高的优先级。另外，我们优先重新复制活跃(live)文件的 Chunk 而不是最近刚被 删除的文件的 Chunk(查看 4.4 节)。最后，为了最小化失效的 Chunk 对正在运行的应用程序的影响，我们提 高会阻塞客户机程序处理流程的 Chunk 的优先级。 Master 节点选择优先级最高的 Chunk，然后命令某个 Chunk 服务器直接从可用的副本”克隆”一个副本 出来。选择新副本的位置的策略和创建时类似:平衡硬盘使用率、限制同一台 Chunk 服务器上的正在进行的 克隆操作的数量、在机架间分布副本。为了防止克隆产生的网络流量大大超过客户机的流量，Master 节点对 整个集群和每个 Chunk 服务器上的同时进行的克隆操作的数量都进行了限制。另外，Chunk 服务器通过调节 它对源 Chunk 服务器读请求的频率来限制它用于克隆操作的带宽。 最后，Master 服务器周期性地对副本进行重新负载均衡:它检查当前的副本分布情况，然后移动副本以 便更好的利用硬盘空间、更有效的进行负载均衡。而且在这个过程中，Master 服务器逐渐的填满一个新的 Chunk 服务器，而不是在短时间内用新的 Chunk 填满它，以至于过载。新副本的存储位置选择策略和上面讨论的相 同。另外，Master 节点必须选择哪个副本要被移走。通常情况，Master 节点移走那些剩余空间低于平均值的Chunk 服务器上的副本，从而平衡系统整体的硬盘使用率。 垃圾回收GFS 在文件删除后不会立刻回收可用的物理空间。GFS 空间回收采用惰性的策略，只在文件和 Chunk 级 的常规垃圾收集时进行。我们发现这个方法使系统更简单、更可靠。 机制当一个文件被应用程序删除时，Master 节点象对待其它修改操作一样，立刻把删除操作以日志的方式记 录下来。但是，Master 节点并不马上回收资源，而是把文件名改为一个包含删除时间戳的、隐藏的名字。当 Master 节点对文件系统命名空间做常规扫描的时候，它会删除所有三天前的隐藏文件(这个时间间隔是可以 设置的)。直到文件被真正删除，它们仍旧可以用新的特殊的名字读取，也可以通过把隐藏文件改名为正常显 示的文件名的方式“反删除”。当隐藏文件被从名称空间中删除，Master 服务器内存中保存的这个文件的相关 元数据才会被删除。这也有效的切断了文件和它包含的所有 Chunk 的连接。 在对 Chunk 名字空间做类似的常规扫描时，Master 节点找到孤儿 Chunk(不被任何文件包含的 Chunk) 并删除它们的元数据。Chunk 服务器在和 Master 节点交互的心跳信息中，报告它拥有的 Chunk 子集的信息， Master 节点回复 Chunk 服务器哪些 Chunk 在 Master 节点保存的元数据中已经不存在了。Chunk 服务器可以任 意删除这些 Chunk 的副本。 讨论虽然分布式垃圾回收在编程语言领域是一个需要复杂的方案才能解决的难题，但是在 GFS 系统中是非常 简单的。我们可以轻易的得到 Chunk 的所有引用:它们都只存储在 Master 服务器上的文件到块的映射表中。 我们也可以很轻易的得到所有 Chunk 的副本:它们都以 Linux 文件的形式存储在 Chunk 服务器的指定目录下。 所有 Master 节点不能识别的副本都是“垃圾”。 垃圾回收在空间回收方面相比直接删除有几个优势。首先，对于组件失效是常态的大规模分布式系统， 垃圾回收方式简单可靠。Chunk 可能在某些 Chunk 服务器创建成功，某些 Chunk 服务器上创建失败，失败的 副本处于无法被 Master 节点识别的状态。副本删除消息可能丢失，Master 节点必须重新发送失败的删除消息， 包括自身的和 Chunk 服务器的(自身的指删除 metadata 的消息)。垃圾回收提供了一致的、可靠的清除无用副本的方法。第二，垃圾回收把 存储空间的回收操作合并到 Master 节点规律性的后台活动中，比如，例行扫描和与 Chunk 服务器握手等。因 此，操作被批量的执行，开销会被分散。另外，垃圾回收在 Master 节点相对空闲的时候完成。这样 Master节点就可以给那些需要快速反应的客户机请求提供更快捷的响应。第三，延缓存储空间回收为意外的、不可逆转的删除操作提供了安全保障。 根据我们的使用经验，延迟回收空间的主要问题是，延迟回收会阻碍用户调优存储空间的使用，特别是当存储空间比较紧缺的时候。当应用程序重复创建和删除临时文件时，释放的存储空间不能马上重用。我们 通过显式的再次删除一个已经被删除的文件的方式加速空间回收的速度。我们允许用户为命名空间的不同部 分设定不同的复制和回收策略。例如，用户可以指定某些目录树下面的文件不做复制，删除的文件被即时的、 不可恢复的从文件系统移除。 过期失效的副本检测当 Chunk 服务器失效时，Chunk 的副本有可能因错失了一些修改操作而过期失效。Master 节点保存了每 个 Chunk 的版本号，用来区分当前的副本和过期副本。 无论何时，只要 Master 节点和 Chunk 签订一个新的租约，它就增加 Chunk 的版本号，然后通知最新的 副本。Master 节点和这些副本都把新的版本号记录在它们持久化存储的状态信息中。这个动作发生在任何客 户机得到通知以前，因此也是对这个 Chunk 开始写之前。如果某个副本所在的 Chunk 服务器正好处于失效状 态，那么副本的版本号就不会被增加。Master 节点在这个 Chunk 服务器重新启动，并且向 Master 节点报告它 拥有的 Chunk 的集合以及相应的版本号的时候，就会检测出它包含过期的 Chunk。如果 Master 节点看到一个 比它记录的版本号更高的版本号，Master 节点会认为它和 Chunk 服务器签订租约的操作失败了，因此会选择 更高的版本号作为当前的版本号。 Master 节点在例行的垃圾回收过程中移除所有的过期失效副本。在此之前，Master 节点在回复客户机的 Chunk 信息请求的时候，简单的认为那些过期的块根本就不存在。另外一重保障措施是，Master 节点在通知 客户机哪个 Chunk 服务器持有租约、或者指示 Chunk 服务器从哪个 Chunk 服务器进行克隆时，消息中都附带 了 Chunk 的版本号。客户机或者 Chunk 服务器在执行操作时都会验证版本号以确保总是访问当前版本的数据。 容错和诊断我们在设计 GFS 时遇到的最大挑战之一是如何处理频繁发生的组件失效。组件的数量和质量让这些问题 出现的频率远远超过一般系统意外发生的频率:我们不能完全依赖机器的稳定性，也不能完全相信硬盘的可 靠性。组件的失效可能造成系统不可用，更糟糕的是，还可能产生不完整的数据。我们讨论我们如何面对这 些挑战，以及当组件失效不可避免的发生时，用 GFS 自带工具诊断系统故障。 高可用性在 GFS 集群的数百个服务器之中，在任何给定的时间必定会有些服务器是不可用的。我们使用两条简单但是有效的策略保证整个系统的高可用性:快速恢复和复制。 快速恢复不管 Master 服务器和 Chunk 服务器是如何关闭的，它们都被设计为可以在数秒钟内恢复它们的状态并重 新启动。事实上，我们并不区分正常关闭和异常关闭;通常，我们通过直接 kill 掉进程来关闭服务器。客户 机和其它的服务器会感觉到系统有点颠簸(a minor hiccup)，正在发出的请求会超时，需要重新连接到重启后的服务器，然后 重试这个请求。6.6.2 章节记录了实测的启动时间。 Chunk 复制正如之前讨论的，每个 Chunk 都被复制到不同机架上的不同的 Chunk 服务器上。用户可以为文件命名空 间的不同部分设定不同的复制级别。缺省是 3。当有 Chunk 服务器离线了，或者通过 Chksum 校验(参考 5.2 节)发现了已经损坏的数据，Master 节点通过克隆已有的副本保证每个 Chunk 都被完整复制(即每个 Chunk 都有复制因子制定的个数个副本，缺省是 3)。虽然 Chunk 复制策略对我们非常有效，但是我们也在寻找其它形式的跨服务器的冗余解决方案，比如使用奇偶校验、或 者 Erasure codes(Erasure codes 用来解决链接层中不相关的错误，以及网络拥塞和 buffer 限制造成的丢包错误)来解决我们日益增长的只读存储需求。我们的系统主要的工作负载是追加方式的写入和读取 操作，很少有随机的写入操作，因此，我们认为在我们这个高度解耦合的系统架构下实现这些复杂的冗余方 案很有挑战性，但并非不可实现。 Master 服务器的复制为了保证 Master 服务器的可靠性，Master 服务器的状态也要复制。Master 服务器所有的操作日志和 checkpoint 文件都被复制到多台机器上。对 Master 服务器状态的修改操作能够提交成功的前提是，操作日志 写入到 Master 服务器的备节点和本机的磁盘。简单说来，一个 Master 服务进程负责所有的修改操作，包括后 台的服务，比如垃圾回收等改变系统内部状态活动。当它失效的时，几乎可以立刻重新启动。如果 Master 进 程所在的机器或者磁盘失效了，处于 GFS 系统外部的监控进程会在其它的存有完整操作日志的机器上启动一 个新的 Master 进程。客户端使用规范的名字访问 Master(比如 gfs-test)节点，这个名字类似 DNS 别名，因 此也就可以在 Master 进程转到别的机器上执行时，通过更改别名的实际指向访问新的 Master 节点。 此外，GFS 中还有些“影子”Master 服务器，这些“影子”服务器在“主”Master 服务器宕机的时候提 供文件系统的只读访问。它们是影子，而不是镜像，所以它们的数据可能比“主”Master 服务器更新要慢， 通常是不到 1 秒。对于那些不经常改变的文件、或者那些允许获取的数据有少量过期的应用程序，“影子”Master 服务器能够提高读取的效率。事实上，因为文件内容是从 Chunk 服务器上读取的，因此，应用程序不 会发现过期的文件内容。在这个短暂的时间窗内，过期的可能是文件的元数据，比如目录的内容或者访问控制信息。 “影子”Master 服务器为了保持自身状态是最新的，它会读取一份当前正在进行的操作的日志副本，并且依照和主 Master 服务器完全相同的顺序来更改内部的数据结构。和主 Master 服务器一样，“影子”Master 服务器在启动的时候也会从 Chunk 服务器轮询数据(之后定期拉数据)，数据中包括了 Chunk 副本的位置信 息;“影子”Master 服务器也会定期和 Chunk 服务器“握手”来确定它们的状态。在主 Master 服务器因创建 和删除副本导致副本位置信息更新时，“影子”Master 服务器才和主 Master 服务器通信来更新自身状态。 数据完整性每个 Chunk 服务器都使用 Checksum 来检查保存的数据是否损坏。考虑到一个 GFS 集群通常都有好几百 台机器、几千块硬盘，磁盘损坏导致数据在读写过程中损坏或者丢失是非常常见的(第 7 节讲了一个原因)。 我们可以通过别的 Chunk 副本来解决数据损坏问题，但是跨越 Chunk 服务器比较副本来检查数据是否损坏很 不实际。另外，GFS 允许有歧义的副本存在:GFS 修改操作的语义，特别是早先讨论过的原子纪录追加的操 作，并不保证副本完全相同(alex 注:副本不是 byte-wise 完全一致的)。因此，每个 Chunk 服务器必须独立维 护 Checksum 来校验自己的副本的完整性。 我们把每个 Chunk 都分成 64KB 大小的块。每个块都对应一个 32 位的 Checksum。和其它元数据一样， Checksum 与其它的用户数据是分开的，并且保存在内存和硬盘上，同时也记录操作日志。对于读操作来说，在把数据返回给客户端或者其它的 Chunk 服务器之前，Chunk 服务器会校验读取操作 涉及的范围内的块的 Checksum。因此 Chunk 服务器不会把错误数据传递到其它的机器上。如果发生某个块的 Checksum 不正确，Chunk 服务器返回给请求者一个错误信息，并且通知 Master 服务器这个错误。作为回应， 请求者应当从其它副本读取数据，Master 服务器也会从其它副本克隆数据进行恢复。当一个新的副本就绪后， Master 服务器通知副本错误的 Chunk 服务器删掉错误的副本。 Checksum 对读操作的性能影响很小，可以基于几个原因来分析一下。因为大部分的读操作都至少要读取 几个块，而我们只需要读取一小部分额外的相关数据进行校验。GFS 客户端代码通过每次把读取操作都对齐 在 Checksum block 的边界上，进一步减少了这些额外的读取操作的负面影响。另外，在 Chunk 服务器上， Checksum 的查找和比较不需要 I/O 操作，Checksum 的计算可以和 I/O 操作同时进行。 Checksum 的计算针对在 Chunk 尾部的追加写入操作做了高度优化(与之对应的是覆盖现有数据的写入操 作)，因为这类操作在我们的工作中占了很大比例。我们只增量更新最后一个不完整的块的 Checksum，并且 用所有的追加来的新 Checksum 块来计算新的 Checksum。即使是最后一个不完整的 Checksum 块已经损坏了，且我们不能够马上检查出来，由于新的 Checksum 和已有数据不吻合，在下次对这个块进行读取操作的时候，会检查出数据已经损坏了。 相比之下，如果写操作覆盖已经存在的一个范围内的 Chunk，我们必须读取和校验被覆盖的第一个和最后一个块，然后再执行写操作;操作完成之后再重新计算和写入新的 Checksum。如果我们不校验第一个和最 后一个被写的块，那么新的 Checksum 可能会隐藏没有被覆盖区域内的数据错误。 在 Chunk 服务器空闲的时候，它会扫描和校验每个不活动的 Chunk 的内容。这使得我们能够发现很少被 读取的 Chunk 是否完整。一旦发现有 Chunk 的数据损坏，Master 可以创建一个新的、正确的副本，然后把损 坏的副本删除掉。这个机制也避免了非活动的、已损坏的 Chunk 欺骗 Master 节点，使 Master 节点认为它们已 经有了足够多的副本了。 诊断工具详尽的、深入细节的诊断日志，在问题隔离、调试、以及性能分析等方面给我们带来无法估量的帮助， 同时也只需要很小的开销。没有日志的帮助，我们很难理解短暂的、不重复的机器之间的消息交互。GFS 的 服务器会产生大量的日志，记录了大量关键的事件(比如，Chunk 服务器启动和关闭)以及所有的 RPC 的请 求和回复。这些诊断日志可以随意删除，对系统的正确运行不造成任何影响。然而，我们在存储空间允许的 情况下会尽量的保存这些日志。 RPC 日志包含了网络上发生的所有请求和响应的详细记录，但是不包括读写的文件数据。通过匹配请求 与回应，以及收集不同机器上的 RPC 日志记录，我们可以重演所有的消息交互来诊断问题。日志还用来跟踪 负载测试和性能分析。 日志对性能的影响很小(远小于它带来的好处)，因为这些日志的写入方式是顺序的、异步的。最近发生 的事件日志保存在内存中，可用于持续不断的在线监控。 度量本节中，我们将使用一些小规模基准测试来展现 GFS 系统架构和实现上的一些固有瓶颈，还有些来自Google 内部使用的真实的 GFS 集群的基准数据。 小规模基准测试我们在一个包含 1 台 Master 服务器，2 台 Master 服务器复制节点，16 台 Chunk 服务器和 16 个客户机组 成的 GFS 集群上测量性能。注意，采用这样的集群配置方案只是为了易于测试。典型的 GFS 集群有数百个 Chunk 服务器和数百个客户机。 所有机器的配置都一样:两个 PIII 1.4GHz 处理器，2GB 内存，两个 80G/5400rpm 的硬盘，以及 100Mbps 全双工以太网连接到一个 HP2524 交换机。GFS 集群中所有的 19 台服务器都连接在一个交换机，所有 16 台客户机连接到另一个交换机上。两个交换机之间使用 1Gbps 的线路连接。 读取N 个客户机从 GFS 文件系统同步读取数据。每个客户机从 320GB 的文件集合中随机读取 4MB region 的 内容。读取操作重复执行 256 次，因此，每个客户机最终都读取 1GB 的数据。所有的 Chunk 服务器加起来总 共只有 32GB 的内存，因此，我们预期只有最多 10%的读取请求命中 Linux 的文件系统缓冲。我们的测试结 果应该和一个在没有文件系统缓存的情况下读取测试的结果接近。上边的曲线显示了我们网络拓扑下的合计理论吞吐量上限。下边的曲线显示了观测到的吞吐量。这个曲线有着 95%的可靠性，因为有时候测量会不够精确。 图 3(a)显示了 N 个客户机整体的读取速度以及这个速度的理论极限。当连接两个交换机的 1Gbps 的链路饱和时，整体读取速度达到理论的极限值是 125MB/S，或者说每个客户机配置的 100Mbps 网卡达到饱和时， 每个客户机读取速度的理论极限值是 12.5MB/s。实测结果是，当一个客户机读取的时候，读取的速度是 10MB/s， 也就是说达到客户机理论读取速度极限值的 80%。对于 16 个客户机，整体的读取速度达到了 94MB/s，大约 是理论整体读取速度极限值的 75%，也就是说每个客户机的读取速度是 6MB/s。读取效率从 80%降低到了 75%， 主要的原因是当读取的客户机增加时，多个客户机同时读取一个 Chunk 服务器的几率也增加了，导致整体的 读取效率下降。 写入N 个客户机同时向 N 个不同的文件中写入数据。每个客户机以每次 1MB 的速度连续写入 1GB 的数据。 图 3(b)显示了整体的写入速度和它们理论上的极限值。理论上的极限值是 67MB/s，因为我们需要把每一 byte 写入到 16 个 Chunk 服务器中的 3 个上，而每个 Chunk 服务器的输入连接速度是 12.5MB/s。 一个客户机的写入速度是 6.3MB，大概是理论极限值的一半。导致这个结果的主要原因是我们的网络协 议栈。它与我们推送数据到 Chunk 服务器时采用的管道模式不相适应。从一个副本到另一个副本的数据传输延迟降低了整个的写入速度。 16 个客户机整体的写入速度达到了 35MB/s(即每个客户机 2.2MB/s)，大约只是理论极限值的一半。和多个客户机读取的情形很类型，随着客户机数量的增加，多个客户机同时写入同一个 Chunk 服务器的几率也 增加了。而且，16 个客户机并行写入可能引起的冲突比 16 个客户机并行读取要大得多，因为每个写入都会 涉及三个不同的副本。 写入的速度比我们想象的要慢。在实际应用中，这没有成为我们的主要问题，因为即使在单个客户机上 能够感受到延时，它也不会在有大量客户机的时候对整体的写入带宽造成显著的影响。 记录追加图 3(c)显示了记录追加操作的性能。N 个客户机同时追加数据到一个文件。记录追加操作的性能受限 于保存文件最后一个 Chunk 的 Chunk 服务器的带宽，而与客户机的数量无关。记录追加的速度由一个客户机 的 6.0MB/s 开始，下降到 16 个客户机的 4.8MB/s 为止，速度的下降主要是由于不同客户端的网络拥塞以及网 络传输速度的不同而导致的。 我们的程序倾向于同时处理多个这样的文件。换句话说，即 N 个客户机同时追加数据到 M 个共享文件中， 这里 N 和 M 都是数十或者数百以上。所以，在我们的实际应用中，Chunk 服务器的网络拥塞并没有成为一个 严重问题，如果 Chunk 服务器的某个文件正在写入，客户机会去写另外一个文件。 实际应用中的集群我们现在来仔细评估一下 Google 内部正在使用的两个集群，它们具有一定的代表性。集群 A 通常被上百 个工程师用于研究和开发。典型的任务是被人工初始化后连续运行数个小时。它通常读取数 MB 到数 TB 的 数据，之后进行转化或者分析，最后把结果写回到集群中。集群 B 主要用于处理当前的生产数据。集群 B 的 任务持续的时间更长，在很少人工干预的情况下，持续的生成和处理数 TB 的数据集。在这两个案例中，一 个单独的“任务”都是指运行在多个机器上的多个进程，它们同时读取和写入多个文件。 存储如上表前五行所描述的，两个集群都由上百台 Chunk 服务器组成，支持数 TB 的硬盘空间;两个集群虽 然都存储了大量的数据，但是还有剩余的空间。“已用空间”包含了所有的 Chunk 副本。实际上所有的文件都 复制了三份。因此，集群实际上各存储了 18TB 和 52TB 的文件数据。 两个集群存储的文件数量都差不多，但是集群 B 上有大量的死文件。所谓“死文件”是指文件被删除了 或者是被新版本的文件替换了，但是存储空间还没有来得及被回收。由于集群 B 存储的文件较大，因此它的 Chunk 数量也比较多。 元数据Chunk 服务器总共保存了十几 GB 的元数据，大多数是来自用户数据的、64KB 大小的块的 Checksum。 保存在 Chunk 服务器上其它的元数据是 Chunk 的版本号信息，我们在 4.5 节描述过。 在 Master 服务器上保存的元数据就小的多了，大约只有数十 MB，或者说平均每个文件 100 字节的元数 据。这和我们设想的是一样的，Master 服务器的内存大小在实际应用中并不会成为 GFS 系统容量的瓶颈。大 多数文件的元数据都是以前缀压缩模式存放的文件名。Master 服务器上存放的其它元数据包括了文件的所有 者和权限、文件到 Chunk 的映射关系，以及每一个 Chunk 的当前版本号。此外，针对每一个 Chunk，我们都 保存了当前的副本位置以及对它的引用计数，这个引用计数用于实现写时拷贝(即 COW，copy-on-write)。 对于每一个单独的服务器，无论是 Chunk 服务器还是 Master 服务器，都只保存了 50MB 到 100MB 的元 数据。因此，恢复服务器是非常快速的:在服务器响应客户请求之前，只需要花几秒钟时间从磁盘上读取这 些数据就可以了。不过，Master 服务器会持续颠簸一段时间–通常是 30 到 60 秒–直到它完成轮询所有的 Chunk服务器，并获取到所有 Chunk 的位置信息。 读写速率表三显示了不同时段的读写速率。在测试的时候，这两个集群都运行了一周左右的时间。(这两个集群最 近都因为升级新版本的 GFS 重新启动过了)。 集群重新启动后，平均写入速率小于 30MB/s。当我们提取性能数据的时候，集群 B 正进行大量的写入操 作，写入速度达到了 100MB/s，并且因为每个 Chunk 都有三个副本的原因，网络负载达到了 300MB/s。 读取速率要比写入速率高的多。正如我们设想的那样，总的工作负载中，读取的比例远远高于写入的比 例。两个集群都进行着繁重的读取操作。特别是，集群 A 在一周时间内都维持了 580MB/s 的读取速度。集群 A 的网络配置可以支持 750MB/s 的速度，显然，它有效的利用了资源。集群 B 支持的峰值读取速度是 1300MB/s， 但是它的应用只用到了 380MB/s。 Master 服务器的负载表 3 的数据显示了发送到 Master 服务器的操作请求大概是每秒钟 200 到 500 个。Master 服务器可以轻松 的应付这个请求速度，所以 Master 服务器的处理能力不是系统的瓶颈。 在早期版本的 GFS 中，Master 服务器偶尔会成为瓶颈。它大多数时间里都在顺序扫描某个很大的目录 (包含数万个文件)去查找某个特定的文件。因此我们修改了 Master 服务器的数据结构，通过对名字空间进 行二分查找来提高效率。现在 Master 服务器可以轻松的每秒钟进行数千次文件访问。如果有需要的话，我们 可以通过在名称空间数据结构之前设置名称查询缓冲的方式进一步提高速度。 恢复时间当某个 Chunk 服务器失效了，一些 Chunk 副本的数量可能会低于复制因子指定的数量，我们必须通过克 隆副本使 Chunk 副本数量达到复制因子指定的数量。恢复所有 Chunk 副本所花费的时间取决于资源的数量。 在我们的试验中，我们把集群 B 上的一个 Chunk 服务器 Kill 掉。这个 Chunk 服务器上大约有 15000 个 Chunk， 共计 600GB 的数据。为了减小克隆操作对正在运行的应用程序的影响，以及为 GFS 调度决策提供修正空间， 我们缺省的把集群中并发克隆操作的数量设置为 91 个(Chunk 服务器的数量的 40%)，每个克隆操作最多允 许使用的带宽是 6.25MB/s(50mbps)。所有的 Chunk 在 23.2 分钟内恢复了，复制的速度高达 440MB/s。 在另外一个测试中，我们 Kill 掉了两个 Chunk 服务器，每个 Chunk 服务器大约有 16000 个 Chunk，共 计 660GB 的数据。这两个故障导致了 266 个 Chunk 只有单个副本。这 266 个 Chunk 被 GFS 优先调度进行复 制，在 2 分钟内恢复到至少有两个副本;现在集群被带入到另外一个状态，在这个状态下，系统可以容忍另 外一个 Chunk 服务器失效而不丢失数据。 工作负荷分析(Workload Breakdown)本节中，我们展示了对两个 GFS 集群工作负载情况的详细分析，这两个集群和 6.2 节中的类似，但是不完全相同。集群 X 用于研究和开发，集群 Y 用于生产数据处理。 方法论和注意事项本章节列出的这些结果数据只包括客户机发起的原始请求，因此，这些结果能够反映我们的应用程序对 GFS 文件系统产生的全部工作负载。它们不包含那些为了实现客户端请求而在服务器间交互的请求，也不包 含 GFS 内部的后台活动相关的请求，比如前向转发的写操作，或者重新负载均衡等操作。 我们从 GFS 服务器记录的真实的 RPC 请求日志中推导重建出关于 IO 操作的统计信息。例如，GFS 客 户程序可能会把一个读操作分成几个 RPC 请求来提高并行度，我们可以通过这些 RPC 请求推导出原始的读 操作。因为我们的访问模式是高度程式化，所以我们认为任何不符合的数据都是误差。应用程序如果能够记 录更详尽的日志，就有可能提供更准确的诊断数据;但是为了这个目的去重新编译和重新启动数千个正在运 行的客户机是不现实的，而且从那么多客户机上收集结果也是个繁重的工作。 应该避免从我们的工作负荷数据中过度的归纳出普遍的结论(即不要把本节的数据作为基础的指导性数据)。因为 Google 完全控制着 GFS 和使用 GFS 的应用程序，所以，应用程序都针对 GFS 做了优化，同时，GFS 也是为了这些应用程序而设计的。这样的相 互作用也可能存在于一般程序和文件系统中，但是在我们的案例中这样的作用影响可能更显著。 Chunk 服务器工作负荷表 4 显示了操作按涉及的数据量大小的分布情况。读取操作按操作涉及的数据量大小呈现了双峰分布。 小的读取操作(小于 64KB)一般是由查找操作的客户端发起的，目的在于从巨大的文件中查找小块的数据。 大的读取操作(大于 512KB)一般是从头到尾顺序的读取整个文件。 在集群 Y 上，有相当数量的读操作没有返回任何的数据。在我们的应用中，尤其是在生产系统中，经常 使用文件作为生产者-消费者队列。生产者并行的向文件中追加数据，同时，消费者从文件的尾部读取数据。某些情况下，消费者读取的速度超过了生产者写入的速度，这就会导致没有读到任何数据的情况。集群 X 通 常用于短暂的数据分析任务，而不是长时间运行的分布式应用，因此，集群 X 很少出现这种情况。 写操作按数据量大小也同样呈现为双峰分布。大的写操作(超过 256KB)通常是由于 Writer 使用了缓存 机制导致的。Writer 缓存较小的数据，通过频繁的 Checkpoint 或者同步操作，或者只是简单的统计小的写入 (小于 64KB)的数据量(alex 注:即汇集多次小的写入操作，当数据量达到一个阈值，一次写入)，之后批量 写入。 再来观察一下记录追加操作。我们可以看到集群 Y 中大的记录追加操作所占比例比集群 X 多的多，这是 因为集群 Y 用于我们的生产系统，针对 GFS 做了更全面的调优。表 5 显示了按操作涉及的数据量的大小统计出来的总数据传输量。在所有的操作中，大的操作(超过 256KB)占据了主要的传输量。小的读取(小于 64KB)虽然传输的数据量比较少，但是在读取的数据量中仍 占了相当的比例，这是因为在文件中随机 Seek 的工作负荷而导致的。 记录追加 vs. 写操作记录追加操作在我们的生产系统中大量使用。对于集群 X，记录追加操作和普通写操作的比例按照字节 比是 108:1，按照操作次数比是 8:1。对于作为我们的生产系统的集群 Y 来说，这两个比例分别是 3.7:1 和 2.5:1。 更进一步，这一组数据说明在我们的两个集群上，记录追加操作所占比例都要比写操作要大。对于集群 X， 在整个测量过程中，记录追加操作所占比率都比较低，因此结果会受到一两个使用某些特定大小的 buffer 的 应用程序的影响。 如同我们所预期的，我们的数据修改操作主要是记录追加操作而不是覆盖方式的写操作。我们测量了第 一个副本的数据覆盖写的情况。这近似于一个客户机故意覆盖刚刚写入的数据，而不是增加新的数据。对于 集群 X，覆盖写操作在写操作所占据字节上的比例小于 0.0001%，在所占据操作数量上的比例小于 0.0003%。 对于集群 Y，这两个比率都是 0.05%。虽然这只是某一片断的情况，但是仍然高于我们的预期。这是由于这 些覆盖写的操作，大部分是由于客户端在发生错误或者超时以后重试的情况。这在本质上应该不算作工作负 荷的一部分，而是重试机制产生的结果。 Master 的工作负荷表 6 显示了 Master 服务器上的请求按类型区分的明细表。大部分的请求都是读取操作查询 Chunk 位置信 息(FindLocation)、以及修改操作查询 lease 持有者的信息(FindLease-Locker)。 集群 X 和 Y 在删除请求的数量上有着明显的不同，因为集群 Y 存储了生产数据，一般会重新生成数据 以及用新版本的数据替换旧有的数据。数量上的差异也被隐藏在了 Open 请求中，因为旧版本的文件可能在以 重新写入的模式打开时，隐式的被删除了(类似 UNIX 的 open 函数中的“w”模式)。 FindMatchingFiles 是一个模式匹配请求，支持“ls”以及其它类似的文件系统操作。不同于 Master 服务 器的其它请求，它可能会检索 namespace 的大部分内容，因此是非常昂贵的操作。集群 Y 的这类请求要多一 些，因为自动化数据处理的任务进程需要检查文件系统的各个部分，以便从全局上了解应用程序的状态。与 之不同的是，集群 X 的应用程序更加倾向于由单独的用户控制，通常预先知道自己所需要使用的全部文件的 名称。 经验在建造和部署 GFS 的过程中，我们经历了各种各样的问题，有些是操作上的，有些是技术上的。起初，GFS 被设想为我们的生产系统的后端文件系统。随着时间推移，在 GFS 的使用中逐步的增加了对 研究和开发任务的支持。我们开始增加一些小的功能，比如权限和配额，到了现在，GFS 已经初步支持了这 些功能。虽然我们生产系统是严格受控的，但是用户层却不总是这样的。需要更多的基础架构来防止用户间 的相互干扰。 我们最大的问题是磁盘以及和 Linux 相关的问题。很多磁盘都声称它们支持某个范围内的 Linux IDE 硬盘 驱动程序，但是实际应用中反映出来的情况却不是这样，它们只支持最新的驱动。因为协议版本很接近，所 以大部分磁盘都可以用，但是偶尔也会有由于协议不匹配，导致驱动和内核对于驱动器的状态判断失误。这会导致数据因为内核中的问题意外的被破坏了。这个问题促使我们使用 Checksum 来校验数据，同时我们也修改内核来处理这些因为协议不匹配带来的问题。 较早的时候，我们在使用 Linux 2.2 内核时遇到了些问题，主要是 fsync()的效率问题。它的效率与文件的大小而不是文件修改部分的大小有关。这在我们的操作日志文件过大时给出了难题，尤其是在我们尚未实 现 Checkpoint 的时候。我们费了很大的力气用同步写来解决这个问题，但是最后还是移植到了 Linux2.4 内核 上。 另一个和 Linux 相关的问题是单个读写锁的问题，也就是说，在某一个地址空间的任意一个线程都必须 在从磁盘 page in(读锁)的时候先 hold 住，或者在 mmap()调用(写锁)的时候改写地址空间。我们发现即 使我们的系统负载很轻的情况下也会有偶尔的超时，我们花费了很多的精力去查找资源的瓶颈或者硬件的问 题。最后我们终于发现这个单个锁在磁盘线程交换以前映射的数据到磁盘的时候，锁住了当前的网络线程， 阻止它把新数据映射到内存。由于我们的性能主要受限于网络接口，而不是内存 copy 的带宽，因此，我们用 pread()替代 mmap()，用了一个额外的 copy 动作来解决这个问题。 尽管偶尔还是有其它的问题，Linux 的开放源代码还是使我们能够快速探究和理解系统的行为。在适当的 时候，我们会改进内核并且和公开源码组织共享这些改动。 相关工作和其它的大型分布式文件系统，比如 AFS[5]类似，GFS 提供了一个与位置无关的名字空间，这使得数据 可以为了负载均衡或者灾难冗余等目的在不同位置透明的迁移。不同于 AFS 的是，GFS 把文件分布存储到不 同的服务器上，这种方式更类似 Xfs[1]和 Swift[3]，这是为了提高整体性能以及灾难冗余的能力。 由于磁盘相对来说比较便宜，并且复制的方式比 RAID[9]方法简单的多，GFS 目前只使用复制的方式来 进行冗余，因此要比 xFS 或者 Swift 占用更多的裸存储空间(alex 注:Raw storage，裸盘的空间)。 与 AFS、xFS、Frangipani[12]以及 Intermezzo[6]等文件系统不同的是，GFS 并没有在文件系统层面提供 任何 Cache 机制。我们主要的工作在单个应用程序执行的时候几乎不会重复读取数据，因为它们的工作方式 要么是流式的读取一个大型的数据集，要么是在大型的数据集中随机 Seek 到某个位置，之后每次读取少量的 数据。 某些分布式文件系统，比如 Frangipani、xFS、Minnesota’s GFS[11]、GPFS[10]，去掉了中心服务器，只 依赖于分布式算法来保证一致性和可管理性。我们选择了中心服务器的方法，目的是为了简化设计，增加可 靠性，能够灵活扩展。特别值得一提的是，由于处于中心位置的 Master 服务器保存有几乎所有的 Chunk 相关 信息，并且控制着 Chunk 的所有变更，因此，它极大地简化了原本非常复杂的 Chunk 分配和复制策略的实现 方法。我们通过减少 Master 服务器保存的状态信息的数量，以及将 Master 服务器的状态复制到其它节点来保证系统的灾难冗余能力。扩展能力和高可用性(对于读取)目前是通过我们的影子 Master 服务器机制来保证 的。对 Master 服务器状态更改是通过预写日志的方式实现持久化。为此，我们可以调整为使用类似 Harp[7]中的 primary-copy 方案，从而提供比我们现在的方案更严格的一致性保证。 我们解决了一个难题，这个难题类似 Lustre[8]在如何在有大量客户端时保障系统整体性能遇到的问题。不过，我们通过只关注我们的应用程序的需求，而不是提供一个兼容 POSIX 的文件系统，从而达到了简化问 题的目的。此外，GFS 设计预期是使用大量的不可靠节点组建集群，因此，灾难冗余方案是我们设计的核心。 GFS 很类似 NASD 架构[4]。NASD 架构是基于网络磁盘的，而 GFS 使用的是普通计算机作为 Chunk 服 务器，就像 NASD 原形中方案一样。所不同的是，我们的 Chunk 服务器采用惰性分配固定大小的 Chunk 的方 式，而不是分配变长的对象存储空间。此外，GFS 实现了诸如重新负载均衡、复制、恢复机制等等在生产环境中需要的特性。 不同于与 Minnesota’s GFS 和 NASD，我们并不改变存储设备的 Model。我们只关注用普通的设备来解决非常复杂的分布式系统日常的数据处理。 我们通过原子的记录追加操作实现了生产者-消费者队列，这个问题类似 River[2]中的分布式队列。River使用的是跨主机的、基于内存的分布式队列，为了实现这个队列，必须仔细控制数据流;而 GFS 采用可以被 生产者并发追加记录的持久化的文件的方式实现。River 模式支持 m-到-n 的分布式队列，但是缺少由持久化 存储提供的容错机制，GFS 只支持 m-到-1 的队列。多个消费者可以同时读取一个文件，但是它们输入流的区 间必须是对齐的。 结束语Google 文件系统展示了一个使用普通硬件支持大规模数据处理的系统的特质。虽然一些设计要点都是针 对我们的特殊的需要定制的，但是还是有很多特性适用于类似规模的和成本的数据处理任务。 首先，我们根据我们当前的和可预期的将来的应用规模和技术环境来评估传统的文件系统的特性。我们 的评估结果将我们引导到一个使用完全不同于传统的设计思路上。根据我们的设计思路，我们认为组件失效 是常态而不是异常，针对采用追加方式(有可能是并发追加)写入、然后再读取(通常序列化读取)的大文 件进行优化，以及扩展标准文件系统接口、放松接口限制来改进整个系统。 我们系统通过持续监控，复制关键数据，快速和自动恢复提供灾难冗余。Chunk 复制使得我们可以对 Chunk 服务器的失效进行容错。高频率的组件失效要求系统具备在线修复机制，能够周期性的、透明的修复 损坏的数据，也能够第一时间重新建立丢失的副本。此外，我们使用 Checksum 在磁盘或者 IDE 子系统级别 检测数据损坏，在这样磁盘数量惊人的大系统中，损坏率是相当高的。 我们的设计保证了在有大量的并发读写操作时能够提供很高的合计吞吐量。我们通过分离控制流和数据 流来实现这个目标，控制流在 Master 服务器处理，而数据流在 Chunk 服务器和客户端处理。当一般的操作涉 及到 Master 服务器时，由于 GFS 选择的 Chunk 尺寸较大(alex 注:从而减小了元数据的大小)，以及通过 Chunk Lease 将控制权限移交给主副本，这些措施将 Master 服务器的负担降到最低。这使得一个简单、中心的 Master不会成为成为瓶颈。我们相信我们对网络协议栈的优化可以提升当前对于每客户端的写入吞吐量限制。 GFS 成功的实现了我们对存储的需求，在 Google 内部，无论是作为研究和开发的存储平台，还是作为 生产系统的数据处理平台，都得到了广泛的应用。它是我们持续创新和处理整个 WEB 范围内的难题的一个重要工具。","raw":null,"content":null,"categories":[{"name":"paper","slug":"paper","permalink":"https://stanxia.github.io/categories/paper/"}],"tags":[{"name":"paper","slug":"paper","permalink":"https://stanxia.github.io/tags/paper/"}]},{"title":"Hive事务-翻译自官方文档","slug":"Hive事务-翻译自官方文档","date":"2017-12-13T16:34:17.000Z","updated":"2019-04-17T06:08:31.918Z","comments":true,"path":"2017/12/13/Hive事务-翻译自官方文档/","link":"","permalink":"https://stanxia.github.io/2017/12/13/Hive事务-翻译自官方文档/","excerpt":"ACID简介\nACID代表数据库事务的四个特性:\n\n原子性（Atomicity）:一个事务是一个不可再分割的工作单位，事务中的所有操作要么都发生，要么都不发生。\n一致性（Consistency）:事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。这是说数据库事务不能破坏关系数据的完整性以及业务逻辑上的一致性。\n隔离性（Isolation）:多个事务并发访问，事务之间是隔离的，一个事务不影响其它事务运行效果。这指的是在并发环境中，当不同的事务同时操作相同的数据时，每个事务都有各自完整的数据空间。事务查看数据更新时，数据所处的状态要么是另一事务修改它之前的状态，要么是另一事务修改后的状态，事务不会查看到中间状态的数据。事务之间的相应影响，分别为：脏读、不可重复读、幻读、丢失更新。\n持久性（Durability）:意味着在事务完成以后，该事务锁对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。\n\n在Hive0.13中添加事务之后，在分区级别上提供了原子性、一致性和持久性。可以通过打开可用的锁定机制(ZooKeeper或内存)来提供隔离。现在可以在行级别上提供完整的ACID语义，这样一个应用程序可以添加行，而另一个应用程序可以在相同的分区上读取，而不会相互干扰。","text":"ACID简介 ACID代表数据库事务的四个特性: 原子性（Atomicity）:一个事务是一个不可再分割的工作单位，事务中的所有操作要么都发生，要么都不发生。 一致性（Consistency）:事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。这是说数据库事务不能破坏关系数据的完整性以及业务逻辑上的一致性。 隔离性（Isolation）:多个事务并发访问，事务之间是隔离的，一个事务不影响其它事务运行效果。这指的是在并发环境中，当不同的事务同时操作相同的数据时，每个事务都有各自完整的数据空间。事务查看数据更新时，数据所处的状态要么是另一事务修改它之前的状态，要么是另一事务修改后的状态，事务不会查看到中间状态的数据。事务之间的相应影响，分别为：脏读、不可重复读、幻读、丢失更新。 持久性（Durability）:意味着在事务完成以后，该事务锁对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。 在Hive0.13中添加事务之后，在分区级别上提供了原子性、一致性和持久性。可以通过打开可用的锁定机制(ZooKeeper或内存)来提供隔离。现在可以在行级别上提供完整的ACID语义，这样一个应用程序可以添加行，而另一个应用程序可以在相同的分区上读取，而不会相互干扰。使用ACID语义的事务被添加到Hive中，以解决以下用例: 流数据的接入。许多用户都使用 Apache Flume, Apache Storm, or Apache Kafka 将流式数据导入Hadoop集群。 这些工具都是每秒百万行级的数据写入，而Hive只能每十五分钟到一个小时添加一次分区。快速的增加分区会对表中的分区数量形成压力。当然可以事先创建好分区再将数据导入，但这样会引起脏读，而且目录下生成的小文件会对namenode造成很大的压力。而新特性可以很好的解决上述问题 维度表的缓慢变化：在典型的星型架构数据仓库中，维度表随时间慢慢变化。例如，零售商将会打开新的商店，这些商店需要被添加到商店的表中，或者现有的商店可能会改变它的平方英尺或其他一些被跟踪的特性。这些更改会导致插入单个记录或更新记录(取决于所选择的策略)。Hive从0.14开始支持。 数据更新。从Hive 0.14开始，可以 INSERT, UPDATE, 和 DELETE。 使用SQL MERGE语句进行批量更新。 事务限制 BEGIN, COMMIT, and ROLLBACK还不支持。所有操作都是自动提交的。该计划将在未来的版本中提供支持。 现目前只支持ORC文件格式。已经构建了这样的功能，可以通过任何存储格式来使用事务，以确定更新或删除如何应用于基本记录(基本上，具有显式或隐式行id)，但到目前为止，集成工作还只是用于ORC。 事务默认为关闭的。 表必须要分桶才能支持事务。因为外部表不受分桶的控制，因而外部表并不支持事务。 从一个 non_ACID 表读写 ACID 表 是不允许的。事务管理器必须设置为：org.apache.hadoop.hive.ql.lockmgr.DbTxnManager 。 目前只支持快照级别的隔离。 现有的ZooKeeper和内存中的锁管理器与事务不兼容。 ACID表不支持使用ALTER TABLE的模式更改。 使用 ORACLE 作为元数据库，”datanucleus.connectionPoolingType=BONECP” 可能会出现：”No such lock..” 和 “No such transaction…”等错误。请设置为：”datanucleus.connectionPoolingType=DBCP” 。 事务表不支持 ：LOAD DATA… 语法。 流 APIs Hive 提供数据 流式插入和流式更新的 APIs: Hive HCatalog Streaming API HCatalog Streaming Mutation API (Hive 2.0.0 及以上可用) 语法修改 从Hive 0.14. 开始，INSERT…VALUES, UPDATE, and DELETE 已经添加进 SQL 语法。几个新命令已经添加进 Hive 的 DDL 支持 ACID 和 事务, 并修改一些已经存在的 DDL 。 新命令： SHOW TRANSACTIONS SHOW COMPACTIONS ABORT TRANSACTIONS 修改的命令： SHOW LOCKS :提供与事务相关的新锁的信息。如果正在使用 ZooKeeper 或者内存锁管理，命令的输出将有不同。 ALTER TABLE :添加新功能，请求表或分区的压缩。 一般来说，用户不需要请求压缩，因为系统将检测到对它们的需求并启动压缩。 然而，如果对一个表关闭了压缩，或者用户希望在系统不选择的时候压缩表, ALTER TABLE 可用于启动压缩。为了观察压缩的进度，用户可以使用 SHOW COMPACTIONS 。 基础设计 HDFS 不支持对文件进行就地修改。也不提供读的一致性，并且当有数据追加到文件，HDFS 不对读数据的用户提供一致性的。为了在 HDFS 上提供这些特性，我们遵循了其他数据仓库工具中使用的标准方法。 表或分区的数据存储在一组 base 文件中。 新的记录、更新和删除存储在 delta 文件中。每个改变表或分区的事务产生一组新的 delta 文件 。读的时候，合并 base 和 delta 文件, 应用所有的更新和删除。 Base 和 Delta 目录一个分区或一个非分区表的所有文件都在同一个目录下。有更新的时候，任何 ACID 的分区（或非分区表）都有一个 base 文件目录，和一个 delta 文件目录。 1234567hive&gt; dfs -ls -R /user/hive/warehouse/t;drwxr-xr-x - ekoifman staff 0 2016-06-09 17:03 /user/hive/warehouse/t/base_0000022-rw-r--r-- 1 ekoifman staff 602 2016-06-09 17:03 /user/hive/warehouse/t/base_0000022/bucket_00000drwxr-xr-x - ekoifman staff 0 2016-06-09 17:06 /user/hive/warehouse/t/delta_0000023_0000023_0000-rw-r--r-- 1 ekoifman staff 611 2016-06-09 17:06 /user/hive/warehouse/t/delta_0000023_0000023_0000/bucket_00000drwxr-xr-x - ekoifman staff 0 2016-06-09 17:07 /user/hive/warehouse/t/delta_0000024_0000024_0000-rw-r--r-- 1 ekoifman staff 610 2016-06-09 17:07 /user/hive/warehouse/t/delta_0000024_0000024_0000/bucket_00000 合并合并是一组运行在 Metastore中支持 ACID 系统的后台程序。包含 Initiator, Worker, Cleaner, AcidHouseKeeperServiceis 和一些其他的。 Delta 文件合并随着修改的操作，越来越多的delta文件被创建，需要合并以保持足够的性能。有两种类型的合并，minor和major。 Minor 合并 ：在每一个 bucket ，将一组已经存在的 delta 文件合并重写到一个单独的 delta 文件中。 Major 合并 ：在每一个 bucket ，将一个或多个 delta 文件和 bucket 的 base 文件合并重写到一个新的 base 文件中. Major 合并效率高但花销大。 所有的合并都在后台完成，并且不妨碍对数据当前的读和写。 合并完所有的旧文件之后，就删除掉这些旧文件。 Initiator 初始化器这个模块负责发现哪些表或分区应该被合并。 通过设置：hive.compactor.initiator.on 开启。每个合并任务处理一个分区 (或一个非分区表). 如果连续合并失败次数超过 hive.compactor.initiator.failed.compacts.threshold 设定的值，该分区的自动合并调度将会被停止。 Worker 工作执行器每个 worker 处理一个单独的合并任务. 合并是 MapReduce job，名字是: -compactor-... 每一个worker 提交 job 到集群上 (通过定义的 hive.compactor.job.queue) 并等着任务完成。hive.compactor.worker.threads 决定了每个 Metastore 中 Workers 的数量。Hive 仓库中的 Workers 的总数决定了当前合并任务的最大值。 Cleaner 清除器该程序的职责：删除合并后不再需要的 delta 文件. AcidHouseKeeperService ACID管家服务寻找在 hive.txn.timeout 时间内没有心跳的事务，并将其终止。该系统假定发起事务的客户机停止了心跳，而锁定的资源应该被释放。 SHOW COMPACTIONS 查看合并这个命令显示目前正在运行的合并信息，和最近的合并历史 (配置的时间范围内)。 从 HIV-12353 开始支持历史显示。 事务／锁 管理器添加了一个名为“事务管理器”的新逻辑实体，它包含了以前的“数据库/表/分区锁管理器”概念。(hive.lock.manager with default of org.apache.hadoop.hive.ql.lockmgr.zookeeper.ZooKeeperHiveLockManager). 事务管理器现在还负责管理事务锁。默认的 DummyTxnManager 模拟了老版本 Hive 的行为: 没有事务和使用 hive.lock.manager 属性用来为表，分区，数据库创建锁管理器。在 Hive metastore 中新添加的 DbTxnManager 管理所有的锁/事务和 DbLockManager (在服务器出现故障时，事务和锁是持久的). 这意味着在启用事务时，以前锁定ZooKeeper的行为不再存在。 从 lock 持有者和事务 initiators 到 metastore 的心跳连接，如果心跳超时，则这个锁或事务将被舍弃。 从hive 1.30起，DbLockManger 持续获取锁的周期可以通过 hive.lock.numretires 和 hive.lock.sleep.between.retries. 两个属性设置。如果DbLockManger 获取锁失败，过一段时间之后会进行重试。为了支持短查询同时不对metastore造成负担，DbLockManger 在每次重试后加倍等待时长。 注意：DbTxnManager 可以获取所有的表的锁，即便那些没有设置transactional=true属性的表。默认对一个非事务表的插入操会获取一个排他锁从而阻止其他的插入和读取。技术上正确的，但是这背离了hive之前的工作方式。为了向后兼容，可以设置hive.txn.strict.locking.mode 属性来使锁管理器在对非事务表的插入操作时，获取共享锁。保留之前的语义，还有一个好处就是能防止表在读取是被删除。而对于事务表，插入总是获取的共享锁。是因为这些表实现了MVCC的架构，在存储的底层实现了很强的读一致性（快照隔离的方式），甚至能应对并发的修改操作。 共享锁【S锁】:又称读锁，若事务T对数据对象A加上S锁，则事务T可以读A但不能修改A，其他事务只能再对A加S锁，而不能加X锁，直到T释放A上的S锁。这保证了其他事务可以读A，但在T释放A上的S锁之前不能对A做任何修改。 排他锁【X锁】:又称写锁。若事务T对数据对象A加上X锁，事务T可以读A也可以修改A，其他事务不能再对A加任何锁，直到T释放A上的锁。这保证了其他事务在T释放A上的锁之前不能再读取和修改A。） 配置信息 为了开启hive的事务支持，以下是需要开启的最少的hive配置： 客户端： 1234hive.support.concurrency – truehive.enforce.bucketing – true (Not required as of Hive 2.0)hive.exec.dynamic.partition.mode – nonstricthive.txn.manager – org.apache.hadoop.hive.ql.lockmgr.DbTxnManager 服务端： (Metastore) 12hive.compactor.initiator.on – true (See table below for more details)hive.compactor.worker.threads – a positive number on at least one instance of the Thrift metastore service 详细配置信息请看：hive事务配置信息 表属性 如果表要使用 ACID ，则必须指定： &quot;transactional=true&quot; 。如果该表被设置为 ACID 表，则不能转换为非 ACID 表，设置 &quot;transactional&quot;=&quot;false&quot; 也是不行的。在 hive-site.xml 中必须设置：hive.txn.manager = org.apache.hadoop.hive.ql.lockmgr.DbTxnManager 如果需希望系统自动进行合并，则可以设置： &quot;NO_AUTO_COMPACTION&quot; ,也可以通过Alter Table/Partition Compact 语法来设置。 Example: Set compaction options in TBLPROPERTIES at table level1234567891011CREATE TABLE table_name ( id int, name string)CLUSTERED BY (id) INTO 2 BUCKETS STORED AS ORCTBLPROPERTIES (\"transactional\"=\"true\", \"compactor.mapreduce.map.memory.mb\"=\"2048\", -- specify compaction map job properties \"compactorthreshold.hive.compactor.delta.num.threshold\"=\"4\", -- trigger minor compaction if there are more than 4 delta directories \"compactorthreshold.hive.compactor.delta.pct.threshold\"=\"0.5\" -- trigger major compaction if the ratio of size of delta files to -- size of base files is greater than 50%); Example: Set compaction options in TBLPROPERTIES at request level1234ALTER TABLE table_name COMPACT 'minor' WITH OVERWRITE TBLPROPERTIES (\"compactor.mapreduce.map.memory.mb\"=\"3072\"); -- specify compaction map job propertiesALTER TABLE table_name COMPACT 'major' WITH OVERWRITE TBLPROPERTIES (\"tblprops.orc.compress.size\"=\"8192\"); -- change any other Hive table properties","raw":null,"content":null,"categories":[{"name":"hive","slug":"hive","permalink":"https://stanxia.github.io/categories/hive/"}],"tags":[{"name":"hive","slug":"hive","permalink":"https://stanxia.github.io/tags/hive/"}]},{"title":"GitHub使用指南","slug":"GitHub使用指南","date":"2017-12-13T10:38:05.000Z","updated":"2019-04-17T06:08:31.918Z","comments":true,"path":"2017/12/13/GitHub使用指南/","link":"","permalink":"https://stanxia.github.io/2017/12/13/GitHub使用指南/","excerpt":"前言\n学习 GitHub 的使用规则，记录遇到的问题。watch , star , fork 的含义刚使用 GitHub 的时候，看到每一个项目页面右上角都有如下图所示的字样：","text":"前言 学习 GitHub 的使用规则，记录遇到的问题。watch , star , fork 的含义刚使用 GitHub 的时候，看到每一个项目页面右上角都有如下图所示的字样：点击 watch 按钮 会出现如下所示： watch watch 的功能是观察跟踪这个项目，如果项目有任何更新，如果选择了 watching 该项目，都会在邮箱中接收到相关的更新信息。 not watching 表示不关注这个项目的更新情况，但你被提及的时候也会发邮件通知。 ignoring 表示不接收任何通知。 如果你想持续跟进该项目的任何更新情况，则可以选择 watching 。 starstar 类似于社交软件中的关注。如果选择了 star ， 则可以在自己的 star 页面查看到曾经 star 过的项目。点击右上角自己的头像，选择 your stars ：然后就会看到曾经所有 star 过的项目：如果你只想关注这个项目，但不需要接收任何更新通知，也不需要对该项目进行操作，则可以选择 star ，在需要的时候可以快捷查看该项目。 forkfork 的目的是将该项目克隆到自己的 GitHub 中，自己可以对该项目进行编辑修改，在 fork 的时候会在该项目中新添一个分支，可以选择 pull-requests 对该项目进行修改后并提交。 如果你想参与维护这个项目，可以使用 fork 功能，并提交自己的代码（当然用自己的分支提交项目的时候，需要项目其他分支的人员审核）。刚开始不知道 fork 的功能，导致我将很多项目都 fork 下来，其实很没有必要。根据自己的实际需求选择就好。 查看都有哪些人进行了操作如果想要知道都有哪些人进行了这些操作呢？比如我想知道都有谁对这个项目进行了 star 操作，可以看见每个功能旁边都有一个数字，该数字表示对这个项目进行该操作的人数，点击该数字，就可以知道具体是哪些人进行了操作：","raw":null,"content":null,"categories":[{"name":"GitHub","slug":"GitHub","permalink":"https://stanxia.github.io/categories/GitHub/"}],"tags":[{"name":"GitHub","slug":"GitHub","permalink":"https://stanxia.github.io/tags/GitHub/"}]},{"title":"spark取样函数分析","slug":"Spark sample 取样函数","date":"2017-12-12T17:30:25.000Z","updated":"2019-04-17T06:08:31.936Z","comments":true,"path":"2017/12/12/Spark sample 取样函数/","link":"","permalink":"https://stanxia.github.io/2017/12/12/Spark sample 取样函数/","excerpt":"\n背景\nSpark取样操作，无法获取随机样本的解决方案。Dataset中sample函数源码如下：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445/**  * Returns a new [[Dataset]] by sampling a fraction of rows, using a user-supplied seed.  *  * 通过使用用户提供的种子，通过抽样的方式返回一个新的[[Dataset]]。  *  * @param withReplacement Sample with replacement or not.  *                        如果withReplacement=true的话表示有放回的抽样，采用泊松抽样算法实现.  *                        如果withReplacement=false的话表示无放回的抽样，采用伯努利抽样算法实现.  * @param fraction        Fraction of rows to generate.  *                        每一行数据被取样的概率.服从二项分布.当withReplacement=true的时候fraction&gt;=0,当withReplacement=false的时候 0 &lt; fraction &lt; 1.  * @param seed            Seed for sampling.  *                        取样种子（与随机数生成有关）  * @note This is NOT guaranteed to provide exactly the fraction of the count  *       of the given [[Dataset]].  *       不能保证准确的按照给定的分数取样。（一般结果会在概率值*总数左右）  * @group typedrel  * @since 1.6.0  */def sample(withReplacement: Boolean, fraction: Double, seed: Long): Dataset[T] = &#123;  require(fraction &gt;= 0,    s\"Fraction must be nonnegative, but got $&#123;fraction&#125;\")  withTypedPlan &#123;    Sample(0.0, fraction, withReplacement, seed, logicalPlan)()  &#125;&#125;/**  * Returns a new [[Dataset]] by sampling a fraction of rows, using a random seed.  *  * 通过程序随机的种子，抽样返回新的DataSet  *  * @param withReplacement Sample with replacement or not.  *                        取样结果是否放回  * @param fraction        Fraction of rows to generate.  *                        每行数据被取样的概率  * @note This is NOT guaranteed to provide exactly the fraction of the total count  *       of the given [[Dataset]].  *       不能保证准确的按照给定的分数取样。（一般结果会在概率值*总数左右）  * @group typedrel  * @since 1.6.0  */def sample(withReplacement: Boolean, fraction: Double): Dataset[T] = &#123;  sample(withReplacement, fraction, Utils.random.nextLong)&#125;","text":"背景 Spark取样操作，无法获取随机样本的解决方案。Dataset中sample函数源码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * Returns a new [[Dataset]] by sampling a fraction of rows, using a user-supplied seed. * * 通过使用用户提供的种子，通过抽样的方式返回一个新的[[Dataset]]。 * * @param withReplacement Sample with replacement or not. * 如果withReplacement=true的话表示有放回的抽样，采用泊松抽样算法实现. * 如果withReplacement=false的话表示无放回的抽样，采用伯努利抽样算法实现. * @param fraction Fraction of rows to generate. * 每一行数据被取样的概率.服从二项分布.当withReplacement=true的时候fraction&gt;=0,当withReplacement=false的时候 0 &lt; fraction &lt; 1. * @param seed Seed for sampling. * 取样种子（与随机数生成有关） * @note This is NOT guaranteed to provide exactly the fraction of the count * of the given [[Dataset]]. * 不能保证准确的按照给定的分数取样。（一般结果会在概率值*总数左右） * @group typedrel * @since 1.6.0 */def sample(withReplacement: Boolean, fraction: Double, seed: Long): Dataset[T] = &#123; require(fraction &gt;= 0, s\"Fraction must be nonnegative, but got $&#123;fraction&#125;\") withTypedPlan &#123; Sample(0.0, fraction, withReplacement, seed, logicalPlan)() &#125;&#125;/** * Returns a new [[Dataset]] by sampling a fraction of rows, using a random seed. * * 通过程序随机的种子，抽样返回新的DataSet * * @param withReplacement Sample with replacement or not. * 取样结果是否放回 * @param fraction Fraction of rows to generate. * 每行数据被取样的概率 * @note This is NOT guaranteed to provide exactly the fraction of the total count * of the given [[Dataset]]. * 不能保证准确的按照给定的分数取样。（一般结果会在概率值*总数左右） * @group typedrel * @since 1.6.0 */def sample(withReplacement: Boolean, fraction: Double): Dataset[T] = &#123; sample(withReplacement, fraction, Utils.random.nextLong)&#125; 问题 结果数据的行数一般在（fraction*总数）左右。没有一个固定的值，如果需要得到固定行数的随机数据的话不建议采用该方法。办法获取随机取样的替代方法： 123456df.createOrReplaceTempView(\"test_sample\"); // 生成临时表df.sqlContext() // 添加随机数列，并根据其进行排序 .sql(\"select * ,rand() as random from test_sample order by random\") .limit(2) // 根据参数的fraction计算需要获取的取样结果 .drop(\"random\") // 删除掉添加的随机列 .show();","raw":null,"content":null,"categories":[{"name":"spark","slug":"spark","permalink":"https://stanxia.github.io/categories/spark/"}],"tags":[{"name":"spark","slug":"spark","permalink":"https://stanxia.github.io/tags/spark/"}]},{"title":"Hive报错集","slug":"Hive报错集","date":"2017-12-11T13:58:58.000Z","updated":"2019-04-17T06:08:31.918Z","comments":true,"path":"2017/12/11/Hive报错集/","link":"","permalink":"https://stanxia.github.io/2017/12/11/Hive报错集/","excerpt":"前言\n针对一个老毛病：有些错误屡犯屡改，屡改屡犯，没有引起根本上的注意，或者没有从源头理解错误发生的底层原理，导致做很多无用功。\n总结历史，并从中吸取教训，减少无用功造成的时间浪费。特此将从目前遇到的 hive 问题全部记录在这里，搞清楚问题，自信向前。","text":"前言 针对一个老毛病：有些错误屡犯屡改，屡改屡犯，没有引起根本上的注意，或者没有从源头理解错误发生的底层原理，导致做很多无用功。 总结历史，并从中吸取教训，减少无用功造成的时间浪费。特此将从目前遇到的 hive 问题全部记录在这里，搞清楚问题，自信向前。报错集 问题1：Error rolling back详情：Error rolling back: Can&#39;t call rollback when autocommit=true 解决方案：vim conf/hive-site.xml 不要加这个配置！！！！ 1234&lt;property&gt;&lt;name&gt;hive.in.test&lt;/name&gt;&lt;value&gt;true&lt;/value&gt;&lt;/property&gt;","raw":null,"content":null,"categories":[{"name":"hive","slug":"hive","permalink":"https://stanxia.github.io/categories/hive/"}],"tags":[{"name":"hive","slug":"hive","permalink":"https://stanxia.github.io/tags/hive/"}]},{"title":"Hive锁介绍-翻译自官方文档","slug":"Hive锁介绍-翻译自官方文档","date":"2017-12-11T09:58:58.000Z","updated":"2019-04-17T06:08:31.936Z","comments":true,"path":"2017/12/11/Hive锁介绍-翻译自官方文档/","link":"","permalink":"https://stanxia.github.io/2017/12/11/Hive锁介绍-翻译自官方文档/","excerpt":"在数据库中，并发性支持是必须的，而且它们的用例也很容易理解。至少，我们希望尽可能支持并发的读和写。添加一个机制来发现已获得的当前锁是很有用的。没有立即添加API来显式获取任何锁的需求，因此所有锁都是隐式获得的。以下锁定模式将在hive中定义(注意，不需要意图锁)。\n12共享(S)独占(X)\n顾名思义，可以同时获得多个共享锁，而X锁可以阻止所有其他锁。兼容性矩阵如下:对于某些操作，锁在本质上是分层的——例如，对于某些分区操作，表也被锁定(以确保在创建新分区时不能删除表)。","text":"在数据库中，并发性支持是必须的，而且它们的用例也很容易理解。至少，我们希望尽可能支持并发的读和写。添加一个机制来发现已获得的当前锁是很有用的。没有立即添加API来显式获取任何锁的需求，因此所有锁都是隐式获得的。以下锁定模式将在hive中定义(注意，不需要意图锁)。 12共享(S)独占(X) 顾名思义，可以同时获得多个共享锁，而X锁可以阻止所有其他锁。兼容性矩阵如下:对于某些操作，锁在本质上是分层的——例如，对于某些分区操作，表也被锁定(以确保在创建新分区时不能删除表)。锁定模式下获取的合理性如下: 对于非分区表，锁模式非常直观。读取表时，获取一个S锁，而所有其他操作(插入表、alter table等其他操作)获得一个X锁。 对于分区表，其思想如下: 在执行读操作时，获取表和相关分区的 ‘S’ 锁。对于所有其他操作，在分区上执行“X”锁。但是，如果更改只适用于较新的分区，则在表上获得“S”锁，而如果更改适用于所有分区，则在表上获得“X”锁。因此，旧分区可以被读取和写入，而新的分区则被转换为RCFile。每当一个分区被锁定在任何模式时，它的所有父级都被锁在“S”模式中。 基于此，为操作获得的锁如下: 为了避免死锁，这里提出了一个非常简单的方案。所有要锁定的对象都是按字母顺序排序的，然后获取所需的模式锁。请注意，在某些情况下，可能不知道对象列表——例如，在动态分区的情况下，正在修改的分区列表在编译时是未知的——因此，列表的生成是保守的。由于分区的数量可能不知道，所以应该将一个专用锁(但目前不是由于hive -3509 bug)放在表上，或者是已知的前缀。 将添加两个新的可配置参数来决定锁的重试次数和每次重试之间的等待时间。如果重试的次数真的很高，它会导致一个活锁。看看ZooKeeper，看看如何使用ZooKeeper api实现读写锁。请注意，锁请求将被拒绝，而不是等待。现有的锁将被释放，所有的锁将在重试间隔后重试。 上面列出的不会按照指定的方式工作，因为锁的等级性。 表T的“S”锁指定如下: 调用create()创建具有路径名的节点“/ warehouse/T/ read—”。这是协议后面使用的锁节点。确保设置顺序和临时标志。 在锁定节点上调用getChildren()，而无需设置观察标志。 如果有一个以“write -”开头的路径名的孩子，以及一个较低的序列数，那么这个锁就不能被获取。删除第一步中创建的节点并返回。 否则，锁就被授予了。 表T的“X”锁定如下: 调用create()创建具有路径名的节点“/ warehouse/T/ write—”。这是协议后面使用的锁节点。确保设置顺序和临时标志。 在锁定节点上调用getChildren()，而无需设置观察标志。 如果有一个以“读-”或“写-”开头的路径名的孩子，并以较低的序列号开始，就不能获得锁。删除第一步中创建的节点并返回。 否则，锁就被授予了。 默认的Hive行为不会更改，并发也不受支持。您可以通过将以下变量设置为false来关闭并发性: hive.support.concurrency. 您可以通过发出以下命令查看表中的锁: 1234SHOW LOCKS &lt;TABLE_NAME&gt;;SHOW LOCKS &lt;TABLE_NAME&gt; EXTENDED;SHOW LOCKS &lt;TABLE_NAME&gt; PARTITION (&lt;PARTITION_DESC&gt;);SHOW LOCKS &lt;TABLE_NAME&gt; PARTITION (&lt;PARTITION_DESC&gt;) EXTENDED; 点我了解Hive锁定的配置属性","raw":null,"content":null,"categories":[{"name":"hive","slug":"hive","permalink":"https://stanxia.github.io/categories/hive/"}],"tags":[{"name":"hive","slug":"hive","permalink":"https://stanxia.github.io/tags/hive/"}]},{"title":"Hexo + AppVeyor 持续集成","slug":"Hexo 优化-使用 AppVeyor 进行部署","date":"2017-12-07T11:30:06.000Z","updated":"2019-04-17T06:08:31.918Z","comments":true,"path":"2017/12/07/Hexo 优化-使用 AppVeyor 进行部署/","link":"","permalink":"https://stanxia.github.io/2017/12/07/Hexo 优化-使用 AppVeyor 进行部署/","excerpt":"前言\n今天查看 Spark 源码的时候，无意发现了 AppVeyor ，才知道 持续集成（Continuous Integration，简称CI）,简单理解为可以自动化构建项目的工具。在 Spark 中，SparkR 的项目使用了 AppVeyor 持续集成工具。\n看到网络上一些大佬用 AppVeyor 联合 Hexo，作为博客代码的部署工具，一方面可以使部署代码更加简单（全自动化，虽然之前也只有 hexo -clean ,hexo -g ,hexo -d 三步，但现在完全在后台自动部署），另一方面也可以解决博客源码多电脑书写的局限性（之前只能在一台电脑上进行博客的创作，面临着项目备份的问题），现在将项目完全托管在 GitHub上，无需担心电脑换了，或是磁盘损坏造成的数据丢失，也无需使用云备份工具费时费力的维护项目。核心步骤\n新建代码仓库首先我们先确定，将项目托管在 GitHub 上，这里有两种方案，一种是在存放博客静态代码的仓库（如：xxx.github.io）中新添加分支;另一种则是新建一个仓库用于存放项目。我这里使用的第二种方式，新建了一个仓库：hexo-github-source 。","text":"前言 今天查看 Spark 源码的时候，无意发现了 AppVeyor ，才知道 持续集成（Continuous Integration，简称CI）,简单理解为可以自动化构建项目的工具。在 Spark 中，SparkR 的项目使用了 AppVeyor 持续集成工具。 看到网络上一些大佬用 AppVeyor 联合 Hexo，作为博客代码的部署工具，一方面可以使部署代码更加简单（全自动化，虽然之前也只有 hexo -clean ,hexo -g ,hexo -d 三步，但现在完全在后台自动部署），另一方面也可以解决博客源码多电脑书写的局限性（之前只能在一台电脑上进行博客的创作，面临着项目备份的问题），现在将项目完全托管在 GitHub上，无需担心电脑换了，或是磁盘损坏造成的数据丢失，也无需使用云备份工具费时费力的维护项目。核心步骤 新建代码仓库首先我们先确定，将项目托管在 GitHub 上，这里有两种方案，一种是在存放博客静态代码的仓库（如：xxx.github.io）中新添加分支;另一种则是新建一个仓库用于存放项目。我这里使用的第二种方式，新建了一个仓库：hexo-github-source 。 配置 AppVeyor点我进入AppVeyor官网添加你的GitHub项目，这里要注意添加的是你的Source Repo（hexo-github-source），而不是Content Repo（xxx.github.io.git）。 配置 appveyor.yml回到 GitHub 页面，在新建的 hexo-github-source 仓库的根目录下面新建 appveyor.yml 文件。配置如下： 1234567891011121314151617181920212223242526272829303132clone_depth: 5 environment: nodejs_version: &quot;6&quot; access_token: secure: [这里需要改为自己的密匙，获取方法见下] install: - ps: Install-Product node $env:nodejs_version - node --version - npm --version - npm install - npm install hexo-cli -g build_script: - hexo generate artifacts: - path: public on_success: - git config --global credential.helper store - ps: Add-Content &quot;$env:USERPROFILE\\.git-credentials&quot; &quot;https://$($env:access_token):x-oauth-basic@github.com`n&quot; - git config --global user.email &quot;%GIT_USER_EMAIL%&quot; - git config --global user.name &quot;%GIT_USER_NAME%&quot; - git clone --depth 5 -q --branch=%TARGET_BRANCH% %STATIC_SITE_REPO% %TEMP%\\static-site - cd %TEMP%\\static-site - del * /f /q - for /d %%p IN (*) do rmdir &quot;%%p&quot; /s /q - SETLOCAL EnableDelayedExpansion &amp; robocopy &quot;%APPVEYOR_BUILD_FOLDER%\\public&quot; &quot;%TEMP%\\static-site&quot; /e &amp; IF !ERRORLEVEL! EQU 1 (exit 0) ELSE (IF !ERRORLEVEL! EQU 3 (exit 0) ELSE (exit 1)) - git add -A - if &quot;%APPVEYOR_REPO_BRANCH%&quot;==&quot;master&quot; if not defined APPVEYOR_PULL_REQUEST_NUMBER (git diff --quiet --exit-code --cached || git commit -m &quot;Update Static Site&quot; &amp;&amp; git push origin %TARGET_BRANCH% &amp;&amp; appveyor AddMessage &quot;Static Site Updated&quot;) 以上配置，只有 access_token 不一样（其余的都可以直接用），这个需要去 GitHub 生成，戳我了解怎么获取。在 GitHub 拿到 access_token 之后，还需要到 AppVeyor 加密页面 进行加密，最终得到类似这样一串东西MvjDPMTBE+hD5iZPRY2mIUuTl8quMhcEfhYe1rOti5g2GaTPQSDU/Mliff7NainM ，将该密匙 写入 appveyor.yml 中。 配置 Appveyor 环境变量回到 刚才的 Appveyor 页面，进入 settings 页面，选择 Environment ，点击 Add variable 添加环境变量，配置如下四个变量： GIT_USER_EMAIL ：GitHub邮箱 GIT_USER_NAME ：GitHub用户名 STATIC_SITE_REPO ：Content Repo地址（https://github.com/xxx/xxx.github.io.git） TARGET_BRANCH ：保留默认的 master如下图所示：测试与问题 经过一番折腾，终于越过无数的坑之后，完美的运行成功。坑一：push 到仓库时提示空文件夹提示 themes/next 为空文件夹，提交失败（ GitHub 无法提交空文件夹），可问题是明明不是空文件啊，为什么会判定为空的？原来我这是 next 主题直接 git clone 下来的，因而在 next 文件夹的根目录下面有一个 .git 的隐藏文件，就是这导致的无法提交。既然找到了原因，那就好整了，直接删掉，完美解决问题。坑二： AppVeyor 提示 Bug将项目 push 到新建的仓库中，查看 AppVeyor 的运行日志，看是否提示 Bug ，我在测试的过程中很不幸，就出现过问题，原因是 hexo 的一个插件目录过长，导致程序失败，解决方法是不用把 hexo 文件夹备份到仓库中，因而完美的解决（避开）问题。备份到仓库的项目结构如下：（多余的都可去掉，仅保留核心）","raw":null,"content":null,"categories":[{"name":"hexo","slug":"hexo","permalink":"https://stanxia.github.io/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://stanxia.github.io/tags/hexo/"},{"name":"appveyor","slug":"appveyor","permalink":"https://stanxia.github.io/tags/appveyor/"}]},{"title":"Hive事务管理","slug":"Hive事务管理","date":"2017-12-01T11:30:06.000Z","updated":"2019-04-17T06:08:31.918Z","comments":true,"path":"2017/12/01/Hive事务管理/","link":"","permalink":"https://stanxia.github.io/2017/12/01/Hive事务管理/","excerpt":"简介\nHive作为Hadoop家族历史最悠久的组件之一，一直以其优秀的兼容性支持和稳定性而著称，越来越多的企业将业务数据从传统数据库迁移至Hadoop平台，并通过Hive来进行数据分析。但是我们在迁移的过程中难免会碰到如何将传统数据库的功能也迁移到Hadoop的问题，比如说事务。事务作为传统数据库很重要的一个功能，在Hive中是如何实现的呢？Hive的实现有什么不一样的地方呢？我们将传统数据库的应用迁移到Hive如果有事务相关的场景我们该如何去转换并要注意什么问题呢？\n本文会通过很多真实测试案例来比较Hive与传统数据库事务的区别，并在文末给出一些在Hive平台上使用事务相关的功能时的指导和建议。ACID与实现原理为了方便解释和说明后面的一些问题，这里重提传统数据库事务相关的概念，以下内容来源于网络。","text":"简介 Hive作为Hadoop家族历史最悠久的组件之一，一直以其优秀的兼容性支持和稳定性而著称，越来越多的企业将业务数据从传统数据库迁移至Hadoop平台，并通过Hive来进行数据分析。但是我们在迁移的过程中难免会碰到如何将传统数据库的功能也迁移到Hadoop的问题，比如说事务。事务作为传统数据库很重要的一个功能，在Hive中是如何实现的呢？Hive的实现有什么不一样的地方呢？我们将传统数据库的应用迁移到Hive如果有事务相关的场景我们该如何去转换并要注意什么问题呢？ 本文会通过很多真实测试案例来比较Hive与传统数据库事务的区别，并在文末给出一些在Hive平台上使用事务相关的功能时的指导和建议。ACID与实现原理为了方便解释和说明后面的一些问题，这里重提传统数据库事务相关的概念，以下内容来源于网络。 ACID说明何为事务？就是一组单元化操作，这些操作要么都执行，要么都不执行，是一个不可分割的工作单位。 事务（transaction）所应该具有的四个要素：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）。这四个基本要素通常称为ACID特性。 原子性（Atomicity）:一个事务是一个不可再分割的工作单位，事务中的所有操作要么都发生，要么都不发生。 一致性（Consistency）:事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。这是说数据库事务不能破坏关系数据的完整性以及业务逻辑上的一致性。 隔离性（Isolation）:多个事务并发访问，事务之间是隔离的，一个事务不影响其它事务运行效果。这指的是在并发环境中，当不同的事务同时操作相同的数据时，每个事务都有各自完整的数据空间。事务查看数据更新时，数据所处的状态要么是另一事务修改它之前的状态，要么是另一事务修改后的状态，事务不会查看到中间状态的数据。事务之间的相应影响，分别为：脏读、不可重复读、幻读、丢失更新。 持久性（Durability）:意味着在事务完成以后，该事务锁对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。 ACID的实现原理事务可以保证ACID原则的操作，那么事务是如何保证这些原则的？解决ACID问题的两大技术点是： 预写日志（Write-ahead logging）保证原子性和持久性 锁（locking）保证隔离性 这里并没有提到一致性，是因为一致性是应用相关的话题，它的定义一个由业务系统来定义，什么样的状态才是一致？而实现一致性的代码通常在业务逻辑的代码中得以体现。 注：锁是指在并发环境中通过读写锁来保证操作的互斥性。根据隔离程度不同，锁的运用也不同。测试环境 操作系统 CentOS 6.5 JDK jdk1.7.0_67 CDH 5.9 Hadoop 2.6.0 Hive 1.1.0 Hive的ACID测试 Hive中的锁（不开启事务）Hive中定义了两种锁的模式：共享锁（S）和排它锁（X），顾名思义，多个共享锁(S)可以同时获取，但是排它锁(X)会阻塞其它所有锁。在本次测试中，CDH5.9的Concurrency参数是默认开启的（hive.support.concurrency=true），以下分别对开启Concurrency和关闭进行相关测试。 首先在测试之前，创建一个普通的hive表： 1create table test_notransaction(user_id Int,name String); 向test_transaction表中插入测试数据： 1insert into test_notransaction values(1,'peach1'),(2,'peach2'),(3, 'peach3'),(4, 'peach4'); 查看插入的数据： 开启Concurrency1、对catalog_sales表进行并发select操作 执行的sql语句：select count(*) from catalog_sales; 执行单条sql查询时，获取一个共享锁（S），sql语句正常执行 同时执行两条sql查询是，获取两个共享锁，并且sql语句均正常执行 分析：由此对比可得出hive在执行sql查询时获取Share锁，在并发的情况下可获取多个共享锁。 2、对test表进行并发Insert操作 创建表： 1create table test(name string, id int); 执行sql语句： 12insert into test values('test11aaa1',1252); insert into test values('test1',52); 执行单条insert语句时，获取一个X锁，sql语句正常执行 同时执行两条insert语句时，只能获取一个test表X锁，第一条insert语句正常执行，第二条insert语句处于等待状态，在第一条insert语句释放test表的X锁，第二条sql语句正常执行. 分析：由此对比可得出hive在执行insert操作时，只能获取一个X锁且锁不能共享，只能在sql执行完成释放锁后，后续sql方可继续执行。 3、对test表执行select的同时执行insert操作 执行sql语句： 12select count(*) from test; insert into test values(&quot;test123&quot;,123); 步骤： 1) 执行select语句，在select未运行完时，在新的窗口同时执行insert语句观察两条sql执行情况，select语句正常执行，insert语句处于等待状态。 2) 此时查看test表锁状态 在步骤1的执行过程中，获取到test表的锁为共享锁（S） 3) 在select语句执行完成后，观察insert语句开始正常执行，此时获取test表锁为排它锁（X）。注意：在select语句执行完成后，大概过40s左右insert语句才正常执行，这是由hive.lock.sleep.between.retries参数控制，默认60 分析： 由上述操作可得出，hive中一个表只能有一个排它锁(X)且锁不能共享，在获取排它锁时，表上不能有其它锁包括共享锁(S)，只有在表上所有的锁都释放后，insert操作才能继续，否则处于等待状态。 对注意部分进行参数调整，将hive.lock.sleep.between.retries设置为10s，再次进行测试发现，在select语句执行完成后，大概过6s左右insert语句开始执行,通过两次测试发现，等待时间均在10s以内，由此可以得出此参数影响sql操作获取锁的间隔（在未获取到锁的情况下），如果此时未到获取锁触发周期，执行其它sql则，该sql会优于等待的sql执行。 4、对test表执行insert的同时执行select操作 执行sql语句： 12insert into test values(&quot;test123&quot;,123); select count(*) from test; 操作步骤： 1) 在命令窗口执行insert语句，在insert操作未执行完成时，在新的命令窗口执行select语句，观察两个窗口的sql执行情况，insert语句正常执行，select语句处于等待状态。 2) 此时查看test表锁状态，只有insert操作获取的排它锁（X） 3) 在insert语句执行完成后，观察select语句开始正常执行，此时查看test表锁状态为共享锁（S），之前的insert操作获取的排它锁（X）已被释放 分析：在test表锁状态为排它锁(X)时，所有的操作均被阻塞处于等待状态，只有在排它锁(X)释放其它操作可继续进行。 5、测试update和delete修改test表数据 sql语句： 12update test set name=&apos;aaaa&apos; where id=1252; delete test set name=&apos;bbbb&apos; where id=123; 1) 表中数据，更新前 2) 在beeline窗口执行update操作 执行update操作报错，异常提示“Attempt to do update or delete using transaction manager that does not support these operations”，在非事务模式下不支持update 和 delete。 关闭Concurrency1、执行insert操作的同时执行select操作 sql语句： 12insert into test_notransaction values(1,&apos;peach1&apos;),(2,&apos;peach2&apos;),(3, &apos;peach3&apos;),(4, &apos;peach4&apos;); select count(*) from test_notransaction; 操作sql前，查看表数据 查看test_notransaction表获取情况，show locks; hive在未开启concurrency 的情况下,show locks不能正常获取表的锁，同时对同一张表执行insert和select操作时并发执行，获取数据取决于sql执行速度，因此在select 的时候未获取到插入数据。 2、执行select操作的同时执行insert操作 sql语句： 12select count(*) from test_notransaction; insert into test_notransaction values(1,&apos;peach1&apos;),(2,&apos;peach2&apos;),(3, &apos;peach3&apos;),(4, &apos;peach4&apos;); 在执行select的同时执行insert操作，操作可以同时并行操作，未产生阻塞等待的过程。 3、同时执行多条insert操作 sql语句： 12insert into test_notransaction values(1,&apos;peach1&apos;),(2,&apos;peach2&apos;),(3, &apos;peach3&apos;),(4, &apos;peach4&apos;); insert into test_notransaction values(1,&apos;peach1&apos;),(2,&apos;peach2&apos;),(3, &apos;peach3&apos;),(4, &apos;peach4&apos;); 同时执行insert操作时，可同时执行未产生阻塞等待的过程。 4、执行update操作，将表中user_id为2的用户名修改为peach22 sql语句： 1update test_notransaction set name=&apos;peach22&apos; where user_id=2; 执行update操作，执行结果如下： 在未配置hive的Transaction和ACID时，不支持update操作。 5、执行delete操作，将表中user_id为1信息删除 sql语句： 1delete from test_notransaction where user_id=1; 执行delete操作，执行结果如下： hive未配置Transaction和ACID，不支持delete操作。 6、查看表获取锁类型 1show locks; 无法正常执行； Hive的事务Hive的事务配置Hive从0.13开始加入了事务支持，在行级别提供完整的ACID特性，Hive在0.14时加入了对INSERT…VALUES,UPDATE,and DELETE的支持。对于在Hive中使用ACID和Transactions，主要有以下限制： 不支持BEGIN,COMMIT和ROLLBACK 只支持ORC文件格式 表必须分桶 不允许从一个非ACID连接写入/读取ACID表 为了使Hive支持事务操作，需将以下参数加入到hive-site.xml文件中。 123456789101112131415161718192021222324&lt;property&gt;&lt;name&gt;hive.support.concurrency&lt;/name&gt;&lt;value&gt;true&lt;/value&gt;&lt;/property&gt;&lt;property&gt;&lt;name&gt;hive.enforce.bucketing&lt;/name&gt;&lt;value&gt;true&lt;/value&gt;&lt;/property&gt;&lt;property&gt;&lt;name&gt;hive.exec.dynamic.partition.mode&lt;/name&gt;&lt;value&gt;nonstrict&lt;/value&gt;&lt;/property&gt;&lt;property&gt;&lt;name&gt;hive.txn.manager&lt;/name&gt;&lt;value&gt;org.apache.hadoop.hive.ql.lockmgr.DbTxnManager&lt;/value&gt;&lt;/property&gt;&lt;property&gt;&lt;name&gt;hive.compactor.initiator.on&lt;/name&gt;&lt;value&gt;true&lt;/value&gt;&lt;/property&gt;&lt;property&gt;&lt;name&gt;hive.compactor.worker.threads &lt;/name&gt;&lt;value&gt;1&lt;/value&gt;&lt;/property&gt; 可以在Cloudera Manager进行以下配置： 为了让beeline支持还需要配置： Hive事务测试环境准备1、创建一个支持ACID的表 建表语句： 123create table test_trancaction (user_id Int,name String) clustered by (user_id) into 3 buckets stored as orc TBLPROPERTIES ('transactional'='true'); 将表名修改为test_transaction 1alter table test_trancaction rename to test_transaction; 2、准备测试数据，向数据库中插入数据 1insert into test_transaction values(1,'peach'),(2,'peach2'),(3,'peach3'),(4,'peach4'),(5,'peach5'); 用例测试1、执行update操作，将user_id的name修改为peach_update sql语句： 1update test_transaction set name='peach_update' where user_id=1; 执行修改操作，查看表获取锁类型 数据修改成功，且不影响其它数据。 2、同时修改同一条数据，将user_id为1的用户名字修改为peach，另一条sql将名字修改为peach_ sql语句： 12update test_transaction set name='peach' where user_id=1;update test_transaction set name='peach_' where user_id=1; sql执行顺序为peach，其次为peach_ 此时查看表获取到的锁 通过获取到锁分析，在同时修改同一条数据时，优先执行的sql获取到了SHARED_WRITE，而后执行的sql获取锁的状态为WAITING状态，表示还未获取到SHARED_WRITE锁，等待第一条sql执行结束后方可获取到锁对数据进行操作。 通过上不执行操作分析，数据user_id为1的用户名字应被修改为peach_ 3、同时修改不同数据，修改id为2的name为peachtest，修改id为3的name为peach_test sql语句： 12update test_transaction set name='peachtest' where user_id=2; update test_transaction set name='peach_test' where user_id=3; sql执行顺序为peachtest，其次为peach_test 此时查看表获取到的锁 通过sql操作获取锁分析，在同时修改不同数据时，优先执行的sql获取到了SHARED_WRITE，而后执行的sql获取锁的状态为WAITING状态，表示还未获取到SHARED_WRITE锁，等待第一条sql执行结束后方可获取到锁对数据进行操作。 4、执行select操作的同时执行insert操作 sql语句： 12select count(*) from test_transaction; insert into test_transaction values(3,'peach3'); 步骤： 先执行select操作，再执行insert操作，执行完成后查看表获取到的锁 由于select和insert操作均获取的是SHARED_READ锁，读锁为并行，所以select查询和insert同时执行，互不影响。 5、update同一条数据的同时select该条数据 sql语句： 12update test_transaction set name='peach_update' where user_id=1; select * from test_transaction where user_id=1; 步骤： 先执行update操作，再执行select操作，获取此时表获取到的锁 通过获取锁的情况分析， 在update操作时，获取到SHARED_WRITE锁，执行select操作时获取到SHARED_READ锁，在进行修改数据时未阻塞select查询操作，update未执行完成时，select查询到的数据为未修改的数据。 6、执行delete操作，将user_id为3的数据删除 sql语句： 1delete from test_transaction where user_id=3; 步骤： 执行delete操作，获取此时表获取到的锁 删除操作获取到的是SHARED_WRITE锁 执行成功后数据 7、同时delete同一条数据 sql语句： 12delete from test_transaction where user_id=3;delete from test_transaction where user_id=3; 步骤： 按顺序执行两条delete操作，查看此时表获取到的锁： 通过查看delete操作获取到的锁，优先执行的操作获取到SHARED_WRITE锁，后执行的delete操作未获取到SHARED_WRITE锁，处于WAITING状态。 执行删除后结果 8、同时delete两条不同的数据 sql语句： 12delete from test_transaction where user_id=1; delete from test_transaction where user_id=5; 步骤： 按顺序执行两条delete操作，查看此时表获取到的锁： 通过查看delete操作获取到的锁，优先执行的操作获取到SHARED_WRITE锁，后执行的delete操作未获取到SHARED_WRITE锁，处于WAITING状态。 执行删除后结果 9、执行delete的同时对删除的数据进行update操作 sql语句： 12delete from test_transaction where user_id=3; update test_transaction set name='test' where user_id=3; 步骤： 按顺序执行两条sql，查看此时获取到表的锁： 通过查看delete和update操作获取到的锁，优先执行的操作获取到SHARED_WRITE锁，后执行的操作未获取到SHARED_WRITE锁，处于WAITING状态。 执行delete和update后结果 注意：此处在delete优先于update执行，但执行结果为update的结果，执行异常。 10、执行delete的同时对不同的数据进行update操作 sql语句： 12delete from test_transaction where user_id=2; update test_transaction set name='test' where user_id=4; 步骤： 按顺序执行上面两条sql，查看表锁获取情况 通过查看delete和update操作获取到的锁，优先执行的操作获取到SHARED_WRITE锁，后执行的操作未获取到SHARED_WRITE锁，处于WAITING状态。 执行delete和update后结果,执行结果正常 11、执行delete的同时执行select操作 sql语句： 12delete from test_transaction where user_id=4; select count(*) from test_transaction; 步骤： 按顺序执行上面两条sql，查看表锁获取情况 在操作delete的同时执行select操作，两个操作均同时获取到SHARED_RED和SHARED_WRITE锁，操作并行进行未出现阻塞。总结对比Hive事务使用建议 传统数据库中有三种模型隐式事务、显示事务和自动事务。在目前Hive对事务仅支持自动事务，因此Hive无法通过显示事务的方式对一个操作序列进行事务控制。 传统数据库事务在遇到异常情况可自动进行回滚，目前Hive无法支持ROLLBACK。 传统数据库中支持事务并发，而Hive对事务无法做到完全并发控制,多个操作均需要获取WRITE的时候则这些操作为串行模式执行（在测试用例中”delete同一条数据的同时update该数据”，操作是串行的且操作完成后数据未被删除且数据被修改）未保证数据一致性。 Hive的事务功能尚属于实验室功能，并不建议用户直接上生产系统，因为目前它还有诸多的限制，如只支持ORC文件格式，建表必须分桶等，使用起来没有那么方便，另外该功能的稳定性还有待进一步验证。 CDH默认开启了Hive的Concurrency功能，主要是对并发读写的的时候通过锁进行了控制。所以为了防止用户在使用Hive的时候，报错提示该表已经被lock，对于用户来说不友好，建议在业务侧控制一下写入和读取，比如写入同一个table或者partition的时候保证是单任务写入，其他写入需控制写完第一个任务了，后面才继续写，并且控制在写的时候不让用户进行查询。另外需要控制在查询的时候不要允许有写入操作。 如果对于数据一致性不在乎，可以完全关闭Hive的Concurrency功能关闭，即设置hive.support.concurrency为false，这样Hive的并发读写将没有任何限制。","raw":null,"content":null,"categories":[{"name":"hive","slug":"hive","permalink":"https://stanxia.github.io/categories/hive/"}],"tags":[{"name":"hive","slug":"hive","permalink":"https://stanxia.github.io/tags/hive/"},{"name":"acid","slug":"acid","permalink":"https://stanxia.github.io/tags/acid/"}]},{"title":"SparkSQL-Catalyst优化理解","slug":"SparkSQL-Catalyst优化理解","date":"2017-11-30T11:32:26.000Z","updated":"2019-04-17T06:08:31.936Z","comments":true,"path":"2017/11/30/SparkSQL-Catalyst优化理解/","link":"","permalink":"https://stanxia.github.io/2017/11/30/SparkSQL-Catalyst优化理解/","excerpt":"前言\n本文主要介绍SparkSQL的优化器系统Catalyst，其设计思路基本都来自于传统型数据库，而且和大多数当前的大数据SQL处理引擎设计基本相同（Impala、Presto、Hive（Calcite）等）。\nSQL优化器核心执行策略主要分为两个大的方向：\n\n基于规则优化（RBO）：是一种经验式、启发式地优化思路，更多地依靠前辈总结出来的优化规则，简单易行且能够覆盖到大部分优化逻辑，但是对于核心优化算子Join却显得有点力不从心。\n基于代价优化 (CBO)：根据代价估算确定一种代价最小的方案。\n\n举个简单的例子，两个表执行Join到底应该使用BroadcastHashJoin还是SortMergeJoin？当前SparkSQL的方式是通过手工设定参数来确定，如果一个表的数据量小于这个值就使用BroadcastHashJoin，但是这种方案显得很不优雅，很不灵活。基于代价优化就是为了解决这类问题，它会针对每个Join评估当前两张表使用每种Join策略的代价，根据代价估算确定一种代价最小的方案。","text":"前言 本文主要介绍SparkSQL的优化器系统Catalyst，其设计思路基本都来自于传统型数据库，而且和大多数当前的大数据SQL处理引擎设计基本相同（Impala、Presto、Hive（Calcite）等）。 SQL优化器核心执行策略主要分为两个大的方向： 基于规则优化（RBO）：是一种经验式、启发式地优化思路，更多地依靠前辈总结出来的优化规则，简单易行且能够覆盖到大部分优化逻辑，但是对于核心优化算子Join却显得有点力不从心。 基于代价优化 (CBO)：根据代价估算确定一种代价最小的方案。 举个简单的例子，两个表执行Join到底应该使用BroadcastHashJoin还是SortMergeJoin？当前SparkSQL的方式是通过手工设定参数来确定，如果一个表的数据量小于这个值就使用BroadcastHashJoin，但是这种方案显得很不优雅，很不灵活。基于代价优化就是为了解决这类问题，它会针对每个Join评估当前两张表使用每种Join策略的代价，根据代价估算确定一种代价最小的方案。 Tree&amp;Rule在介绍SQL优化器工作原理之前，有必要首先介绍两个重要的数据结构：Tree和Rule。SQL语法树就是SQL语句通过编译器之后会被解析成一棵树状结构。这棵树会包含很多节点对象，每个节点都拥有特定的数据类型，同时会有0个或多个孩子节点（节点对象在代码中定义为TreeNode对象），下图是个简单的示例：如上图所示，箭头左边表达式有3种数据类型（Literal表示常量、Attribute表示变量、Add表示动作），表示x+(1+2)。映射到右边树状结构后，每一种数据类型就会变成一个节点。另外，Tree还有一个非常重要的特性，可以通过一定的规则进行等价变换，如下图： 上图定义了一个等价变换规则(Rule)：两个Integer类型的常量相加可以等价转换为一个Integer常量，这个规则其实很简单，对于上文中提到的表达式x+(1+2)来说就可以转变为x+3。对于程序来讲，如何找到两个Integer常量呢？其实就是简单的二叉树遍历算法，每遍历到一个节点，就模式匹配当前节点为Add、左右子节点是Integer常量的结构，定位到之后将此三个节点替换为一个Literal类型的节点。 上面用一个最简单的示例来说明等价变换规则以及如何将规则应用于语法树。在任何一个SQL优化器中，通常会定义大量的Rule（后面会讲到），SQL优化器会遍历语法树中每个节点，针对遍历到的节点模式匹配所有给定规则（Rule），如果有匹配成功的，就进行相应转换，如果所有规则都匹配失败，就继续遍历下一个节点。Catalyst工作流程任何一个优化器工作原理都大同小异：SQL语句首先通过Parser模块被解析为语法树，此棵树称为Unresolved Logical Plan；Unresolved Logical Plan通过Analyzer模块借助于数据元数据解析为Logical Plan；此时再通过各种基于规则的优化策略进行深入优化，得到Optimized Logical Plan；优化后的逻辑执行计划依然是逻辑的，并不能被Spark系统理解，此时需要将此逻辑执行计划转换为Physical Plan；为了更好的对整个过程进行理解，下文通过一个简单示例进行解释。 ParserParser简单来说是将SQL字符串切分成一个一个Token，再根据一定语义规则解析为一棵语法树。Parser模块目前基本都使用第三方类库ANTLR进行实现，比如Hive、 Presto、SparkSQL等。下图是一个示例性的SQL语句（有两张表，其中people表主要存储用户基本信息，score表存储用户的各种成绩），通过Parser解析后的AST语法树如图所示： Analyzer通过解析后的逻辑执行计划基本有了骨架，但是系统并不知道score、sum这些都是些什么鬼，此时需要基本的元数据信息来表达这些词素，最重要的元数据信息主要包括两部分：表的Scheme和基本函数信息，表的scheme主要包括表的基本定义（列名、数据类型）、表的数据格式（Json、Text）、表的物理位置等，基本函数信息主要指类信息。 Analyzer会再次遍历整个语法树，对树上的每个节点进行数据类型绑定以及函数绑定，比如people词素会根据元数据表信息解析为包含age、id以及name三列的表，people.age会被解析为数据类型为int的变量，sum会被解析为特定的聚合函数，如下图所示： SparkSQL中Analyzer定义了各种解析规则，可以查看Analyzer类，其中定义了基本的解析规则，如下： Optimizer优化器是整个Catalyst的核心，上文提到优化器分为基于规则优化和基于代价优化两种，当前SparkSQL 2.1依然没有很好的支持基于代价优化，此处只介绍基于规则的优化策略，基于规则的优化策略实际上就是对语法树进行一次遍历，模式匹配能够满足特定规则的节点，再进行相应的等价转换。因此，基于规则优化说到底就是一棵树等价地转换为另一棵树。SQL中经典的优化规则有很多，下文结合示例介绍三种比较常见的规则： 谓词下推（Predicate Pushdown） 常量累加（Constant Folding） 列值裁剪（Column Pruning） 上图左边是经过Analyzer解析后的语法树，语法树中两个表先做join，之后再使用age&gt;10对结果进行过滤。大家知道join算子通常是一个非常耗时的算子，耗时多少一般取决于参与join的两个表的大小，如果能够减少参与join两表的大小，就可以大大降低join算子所需时间。谓词下推就是这样一种功能，它会将过滤操作下推到join之前进行，上图中过滤条件age&gt;0以及id!=null两个条件就分别下推到了join之前。这样，系统在扫描数据的时候就对数据进行了过滤，参与join的数据量将会得到显著的减少，join耗时必然也会降低。 常量累加其实很简单，就是上文中提到的规则 x+(1+2) -&gt; x+3，虽然是一个很小的改动，但是意义巨大。示例如果没有进行优化的话，每一条结果都需要执行一次100+80的操作，然后再与变量math_score以及english_score相加，而优化后就不需要再执行100+80操作。 列值裁剪是另一个经典的规则，示例中对于people表来说，并不需要扫描它的所有列值，而只需要列值id，所以在扫描people之后需要将其他列进行裁剪，只留下列id。这个优化一方面大幅度减少了网络、内存数据量消耗，另一方面对于列存数据库（Parquet）来说大大提高了扫描效率。 除此之外，Catalyst还定义了很多其他优化规则，可以查看Optimizer类，下图简单的截取一部分规则： 至此，逻辑执行计划已经得到了比较完善的优化，然而，逻辑执行计划依然没办法真正执行，他们只是逻辑上可行，实际上Spark并不知道如何去执行这个东西。比如Join只是一个抽象概念，代表两个表根据相同的id进行合并，然而具体怎么实现这个合并，逻辑执行计划并没有说明。 此时就需要将逻辑执行计划转换为物理执行计划，将逻辑上可行的执行计划变为Spark可以真正执行的计划。比如Join算子，Spark根据不同场景为该算子制定了不同的算法策略，有BroadcastHashJoin、ShuffleHashJoin以及SortMergeJoin等（可以将Join理解为一个接口，BroadcastHashJoin是其中一个具体实现），物理执行计划实际上就是在这些具体实现中挑选一个耗时最小的算法实现，这个过程涉及到基于代价优化策略。查看SparkSQL执行计划至此，通过一个简单的示例完整的介绍了Catalyst的整个工作流程，包括Parser阶段、Analyzer阶段、Optimize阶段以及Physical Planning阶段。有同学可能会比较感兴趣Spark环境下如何查看一条具体的SQL的整个过程，在此介绍两种方法： 查看逻辑执行计划使用queryExecution方法查看逻辑执行计划，如下所示： 查看物理执行计划使用explain方法查看物理执行计划： Spark WebUI进行查看","raw":null,"content":null,"categories":[{"name":"spark","slug":"spark","permalink":"https://stanxia.github.io/categories/spark/"}],"tags":[{"name":"spark","slug":"spark","permalink":"https://stanxia.github.io/tags/spark/"},{"name":"sparkSQL","slug":"sparkSQL","permalink":"https://stanxia.github.io/tags/sparkSQL/"},{"name":"catalyst","slug":"catalyst","permalink":"https://stanxia.github.io/tags/catalyst/"}]},{"title":"spark容错机制","slug":"spark容错机制","date":"2017-11-29T17:16:32.000Z","updated":"2019-04-17T06:08:31.950Z","comments":true,"path":"2017/11/29/spark容错机制/","link":"","permalink":"https://stanxia.github.io/2017/11/29/spark容错机制/","excerpt":"引言\n一般来说，分布式数据集的容错性有两种方式： 数据检查点 和 记录数据的更新 。面向大规模数据分析，数据检查点操作成本很高，需要通过数据中心的网络连接在机器之间复制庞大的数据集，而网络带宽往往比内存带宽低得多，同时还需要消耗更多的存储资源。因此，Spark选择记录更新的方式。\n但是，如果更新粒度太细太多，那么记录更新成本也不低。因此，RDD只支持粗粒度转换，即只记录单个块上执行的单个操作，然后将创建RDD的一系列变换序列（每个RDD都包含了他是如何由其他RDD变换过来的以及如何重建某一块数据的信息。因此RDD的容错机制又称“血统(Lineage)”容错）记录下来，以便恢复丢失的分区。 \nLineage本质上很类似于数据库中的重做日志（Redo Log），只不过这个重做日志粒度很大，是对全局数据做同样的重做进而恢复数据。Lineage机制\nLineage简介相比其他系统的细颗粒度的内存数据更新级别的备份或者LOG机制，RDD的Lineage记录的是粗颗粒度的特定数据Transformation操作（如filter、map、join等）行为。当这个RDD的部分分区数据丢失时，它可以通过Lineage获取足够的信息来重新运算和恢复丢失的数据分区。因为这种粗颗粒的数据模型，限制了Spark的运用场合，所以Spark并不适用于所有高性能要求的场景，但同时相比细颗粒度的数据模型，也带来了性能的提升。","text":"引言 一般来说，分布式数据集的容错性有两种方式： 数据检查点 和 记录数据的更新 。面向大规模数据分析，数据检查点操作成本很高，需要通过数据中心的网络连接在机器之间复制庞大的数据集，而网络带宽往往比内存带宽低得多，同时还需要消耗更多的存储资源。因此，Spark选择记录更新的方式。 但是，如果更新粒度太细太多，那么记录更新成本也不低。因此，RDD只支持粗粒度转换，即只记录单个块上执行的单个操作，然后将创建RDD的一系列变换序列（每个RDD都包含了他是如何由其他RDD变换过来的以及如何重建某一块数据的信息。因此RDD的容错机制又称“血统(Lineage)”容错）记录下来，以便恢复丢失的分区。 Lineage本质上很类似于数据库中的重做日志（Redo Log），只不过这个重做日志粒度很大，是对全局数据做同样的重做进而恢复数据。Lineage机制 Lineage简介相比其他系统的细颗粒度的内存数据更新级别的备份或者LOG机制，RDD的Lineage记录的是粗颗粒度的特定数据Transformation操作（如filter、map、join等）行为。当这个RDD的部分分区数据丢失时，它可以通过Lineage获取足够的信息来重新运算和恢复丢失的数据分区。因为这种粗颗粒的数据模型，限制了Spark的运用场合，所以Spark并不适用于所有高性能要求的场景，但同时相比细颗粒度的数据模型，也带来了性能的提升。 两种依赖关系RDD在Lineage依赖方面分为两种：窄依赖(Narrow Dependencies)与宽依赖(Wide Dependencies,源码中称为Shuffle Dependencies)，用来解决数据容错的高效性。 窄依赖：是指父RDD的每一个分区最多被一个子RDD的分区所用，表现为一个父RDD的分区对应于一个子RDD的分区，或多个父RDD的分区对应于一个子RDD的分区，也就是说一个父RDD的一个分区不可能对应一个子RDD的多个分区。 1个父RDD分区对应1个子RDD分区，这其中又分两种情况：1个子RDD分区对应1个父RDD分区（如map、filter等算子），1个子RDD分区对应N个父RDD分区（如co-paritioned（协同划分）过的Join）。 宽依赖：是指子RDD的分区依赖于父RDD的多个分区或所有分区，即存在一个父RDD的一个分区对应一个子RDD的多个分区。 1个父RDD分区对应多个子RDD分区，这其中又分两种情况：1个父RDD对应所有子RDD分区（未经协同划分的Join）或者1个父RDD对应非全部的多个RDD分区（如groupByKey）。 本质理解根据父RDD分区是对应1个还是多个子RDD分区来区分窄依赖（父分区对应一个子分区，多个父分区对应一个子分区）和宽依赖（父分区对应多个子分区）。如果对应多个，则当容错重算分区时，因为父分区数据只有一部分是需要重算子分区的，其余数据重算就造成了冗余计算。 对于宽依赖，Stage计算的输入和输出在不同的节点上，对于输入节点完好，而输出节点死机的情况，通过重新计算恢复数据这种情况下，这种方法容错是有效的，否则无效，因为无法重试，需要向上追溯其祖先看是否可以重试（这就是lineage，血统的意思），窄依赖对于数据的重算开销要远小于宽依赖的数据重算开销。 窄依赖和宽依赖的概念主要用在两个地方：一个是容错中相当于Redo日志的功能；另一个是在调度中构建DAG作为不同Stage的划分点。 依赖关系的特性第一，窄依赖可以在某个计算节点上直接通过计算父RDD的某块数据计算得到子RDD对应的某块数据；宽依赖则要等到父RDD所有数据都计算完成之后，并且父RDD的计算结果进行hash并传到对应节点上之后才能计算子RDD。 第二，数据丢失时，对于窄依赖只需要重新计算丢失的那一块数据来恢复；对于宽依赖则要将祖先RDD中的所有数据块全部重新计算来恢复。所以在长“血统”链特别是有宽依赖的时候，需要在适当的时机设置数据检查点。也是这两个特性要求对于不同依赖关系要采取不同的任务调度机制和容错恢复机制。 容错原理在容错机制中，如果一个节点死机了，而且运算窄依赖，则只要把丢失的父RDD分区重算即可，不依赖于其他节点。而宽依赖需要父RDD的所有分区都存在，重算就很昂贵了。 可以这样理解开销的经济与否：在窄依赖中，在子RDD的分区丢失、重算父RDD分区时，父RDD相应分区的所有数据都是子RDD分区的数据，并不存在冗余计算。在宽依赖情况下，丢失一个子RDD分区重算的每个父RDD的每个分区的所有数据并不是都给丢失的子RDD分区用的，会有一部分数据相当于对应的是未丢失的子RDD分区中需要的数据，这样就会产生冗余计算开销，这也是宽依赖开销更大的原因。 因此如果使用Checkpoint算子来做检查点，不仅要考虑Lineage是否足够长，也要考虑是否有宽依赖，对宽依赖加Checkpoint是最物有所值的。Checkpoint机制通过上述分析可以看出在以下两种情况下，RDD需要加检查点。 DAG中的Lineage过长，如果重算，则开销太大（如在PageRank中）。 在宽依赖上做Checkpoint获得的收益更大。 由于RDD是只读的，所以Spark的RDD计算中一致性不是主要关心的内容，内存相对容易管理，这也是设计者很有远见的地方，这样减少了框架的复杂性，提升了性能和可扩展性，为以后上层框架的丰富奠定了强有力的基础。 在RDD计算中，通过检查点机制进行容错，传统做检查点有两种方式：通过冗余数据和日志记录更新操作。在RDD中的doCheckPoint方法相当于通过冗余数据来缓存数据，而之前介绍的血统就是通过相当粗粒度的记录更新操作来实现容错的。 检查点（本质是通过将RDD写入Disk做检查点）是为了通过lineage做容错的辅助，lineage过长会造成容错成本过高，这样就不如在中间阶段做检查点容错，如果之后有节点出现问题而丢失分区，从做检查点的RDD开始重做Lineage，就会减少开销。","raw":null,"content":null,"categories":[{"name":"spark","slug":"spark","permalink":"https://stanxia.github.io/categories/spark/"}],"tags":[{"name":"spark","slug":"spark","permalink":"https://stanxia.github.io/tags/spark/"},{"name":"原理","slug":"原理","permalink":"https://stanxia.github.io/tags/原理/"}]},{"title":"ORC与PARQUET文件类型的比较","slug":"ORC与PARQUET文件类型的比较","date":"2017-11-29T10:29:04.000Z","updated":"2019-04-17T06:08:31.936Z","comments":true,"path":"2017/11/29/ORC与PARQUET文件类型的比较/","link":"","permalink":"https://stanxia.github.io/2017/11/29/ORC与PARQUET文件类型的比较/","excerpt":"列式存储由于OLAP查询的特点，列式存储可以提升其查询性能，但是它是如何做到的呢？这就要从列式存储的原理说起，从图1中可以看到，相对于关系数据库中通常使用的行式存储，在使用列式存储时每一列的所有元素都是顺序存储的。由此特点可以给查询带来如下的优化：\n123查询的时候不需要扫描全部的数据，而只需要读取每次查询涉及的列，这样可以将I/O消耗降低N倍，另外可以保存每一列的统计信息(min、max、sum等)，实现部分的谓词下推。由于每一列的成员都是同构的，可以针对不同的数据类型使用更高效的数据压缩算法，进一步减小I/O。由于每一列的成员的同构性，可以使用更加适合CPU pipeline的编码方式，减小CPU的缓存失效。\n图1 行式存储VS列式存储","text":"列式存储由于OLAP查询的特点，列式存储可以提升其查询性能，但是它是如何做到的呢？这就要从列式存储的原理说起，从图1中可以看到，相对于关系数据库中通常使用的行式存储，在使用列式存储时每一列的所有元素都是顺序存储的。由此特点可以给查询带来如下的优化： 123查询的时候不需要扫描全部的数据，而只需要读取每次查询涉及的列，这样可以将I/O消耗降低N倍，另外可以保存每一列的统计信息(min、max、sum等)，实现部分的谓词下推。由于每一列的成员都是同构的，可以针对不同的数据类型使用更高效的数据压缩算法，进一步减小I/O。由于每一列的成员的同构性，可以使用更加适合CPU pipeline的编码方式，减小CPU的缓存失效。 图1 行式存储VS列式存储 嵌套数据格式通常我们使用关系数据库存储结构化数据，而关系数据库支持的数据模型都是扁平式的，而遇到诸如List、Map和自定义Struct的时候就需要用户自己解析，但是在大数据环境下，数据的来源多种多样，例如埋点数据，很可能需要把程序中的某些对象内容作为输出的一部分，而每一个对象都可能是嵌套的，所以如果能够原生的支持这种数据，查询的时候就不需要额外的解析便能获得想要的结果。例如在Twitter，他们一个典型的日志对象（一条记录）有87个字段，其中嵌套了7层，如下图。 图2 嵌套数据模型 随着嵌套格式的数据的需求日益增加，目前Hadoop生态圈中主流的查询引擎都支持更丰富的数据类型，例如Hive、SparkSQL、Impala等都原生的支持诸如struct、map、array这样的复杂数据类型，这样促使各种存储格式都需要支持嵌套数据格式。 Parquet存储格式Apache Parquet是Hadoop生态圈中一种新型列式存储格式，它可以兼容Hadoop生态圈中大多数计算框架(Mapreduce、Spark等)，被多种查询引擎支持（Hive、Impala、Drill等），并且它是语言和平台无关的。Parquet最初是由Twitter和Cloudera合作开发完成并开源，2015年5月从Apache的孵化器里毕业成为Apache顶级项目。 Parquet最初的灵感来自Google于2010年发表的Dremel论文，文中介绍了一种支持嵌套结构的存储格式，并且使用了列式存储的方式提升查询性能，在Dremel论文中还介绍了Google如何使用这种存储格式实现并行查询的，如果对此感兴趣可以参考论文和开源实现Drill。 数据模型Parquet支持嵌套的数据模型，类似于Protocol Buffers，每一个数据模型的schema包含多个字段，每一个字段有三个属性：重复次数、数据类型和字段名，重复次数可以是以下三种：required(只出现1次)，repeated(出现0次或多次)，optional(出现0次或1次)。每一个字段的数据类型可以分成两种：group(复杂类型)和primitive(基本类型)。例如Dremel中提供的Document的schema示例，它的定义如下： 1234567891011121314message Document &#123; required int64 DocId; optional group Links &#123; repeated int64 Backward; repeated int64 Forward; &#125; repeated group Name &#123; repeated group Language &#123; required string Code; optional string Country; &#125; optional string Url; &#125;&#125; 可以把这个Schema转换成树状结构，根节点可以理解为repeated类型，如图3。 图3 Parquet的schema结构 可以看出在Schema中所有的基本类型字段都是叶子节点，在这个Schema中一共存在6个叶子节点，如果把这样的Schema转换成扁平式的关系模型，就可以理解为该表包含六个列。Parquet中没有Map、Array这样的复杂数据结构，但是可以通过repeated和group组合来实现的。由于一条记录中某一列可能出现零次或者多次，需要标示出哪些列的值构成一条完整的记录。这是由Striping/Assembly算法实现的。 由于Parquet支持的数据模型比较松散，可能一条记录中存在比较深的嵌套关系，如果为每一条记录都维护一个类似的树状结可能会占用较大的存储空间，因此Dremel论文中提出了一种高效的对于嵌套数据格式的压缩算法：Striping/Assembly算法。它的原理是每一个记录中的每一个成员值有三部分组成：Value、Repetition level和Definition level。value记录了该成员的原始值，可以根据特定类型的压缩算法进行压缩，两个level值用于记录该值在整个记录中的位置。对于repeated类型的列，Repetition level值记录了当前值属于哪一条记录以及它处于该记录的什么位置；对于repeated和optional类型的列，可能一条记录中某一列是没有值的，假设我们不记录这样的值就会导致本该属于下一条记录的值被当做当前记录的一部分，从而造成数据的错误，因此对于这种情况需要一个占位符标示这种情况。 通过Striping/Assembly算法，parquet可以使用较少的存储空间表示复杂的嵌套格式，并且通常Repetition level和Definition level都是较小的整数值，可以通过RLE算法对其进行压缩，进一步降低存储空间。 文件结构Parquet文件是以二进制方式存储的，是不可以直接读取和修改的，Parquet文件是自解析的，文件中包括该文件的数据和元数据。在HDFS文件系统和Parquet文件中存在如下几个概念： HDFS块(Block)：它是HDFS上的最小的副本单位，HDFS会把一个Block存储在本地的一个文件并且维护分散在不同的机器上的多个副本，通常情况下一个Block的大小为256M、512M等。 HDFS文件(File)：一个HDFS的文件，包括数据和元数据，数据分散存储在多个Block中。 行组(Row Group)：按照行将数据物理上划分为多个单元，每一个行组包含一定的行数，在一个HDFS文件中至少存储一个行组，Parquet读写的时候会将整个行组缓存在内存中，所以如果每一个行组的大小是由内存大的小决定的。 列块(Column Chunk)：在一个行组中每一列保存在一个列块中，行组中的所有列连续的存储在这个行组文件中。不同的列块可能使用不同的算法进行压缩。 页(Page)：每一个列块划分为多个页，一个页是最小的编码的单位，在同一个列块的不同页可能使用不同的编码方式。 通常情况下，在存储Parquet数据的时候会按照HDFS的Block大小设置行组的大小，由于一般情况下每一个Mapper任务处理数据的最小单位是一个Block，这样可以把每一个行组由一个Mapper任务处理，增大任务执行并行度。Parquet文件的格式如下图所示。 图4 Parquet文件结构 上图展示了一个Parquet文件的结构，一个文件中可以存储多个行组，文件的首位都是该文件的Magic Code，用于校验它是否是一个Parquet文件，Footer length存储了文件元数据的大小，通过该值和文件长度可以计算出元数据的偏移量，文件的元数据中包括每一个行组的元数据信息和当前文件的Schema信息。除了文件中每一个行组的元数据，每一页的开始都会存储该页的元数据，在Parquet中，有三种类型的页：数据页、字典页和索引页。数据页用于存储当前行组中该列的值，字典页存储该列值的编码字典，每一个列块中最多包含一个字典页，索引页用来存储当前行组下该列的索引，目前Parquet中还不支持索引页，但是在后面的版本中增加。 数据访问说到列式存储的优势，Project下推是无疑最突出的，它意味着在获取表中原始数据时只需要扫描查询中需要的列，由于每一列的所有值都是连续存储的，避免扫描整个表文件内容。 在Parquet中原生就支持Project下推，执行查询的时候可以通过Configuration传递需要读取的列的信息，这些列必须是Schema的子集，Parquet每次会扫描一个Row Group的数据，然后一次性得将该Row Group里所有需要的列的Cloumn Chunk都读取到内存中，每次读取一个Row Group的数据能够大大降低随机读的次数，除此之外，Parquet在读取的时候会考虑列是否连续，如果某些需要的列是存储位置是连续的，那么一次读操作就可以把多个列的数据读取到内存。 在数据访问的过程中，Parquet还可以利用每一个row group生成的统计信息进行谓词下推，这部分信息包括该Column Chunk的最大值、最小值和空值个数。通过这些统计值和该列的过滤条件可以判断该Row Group是否需要扫描。另外Parquet未来还会增加诸如Bloom Filter和Index等优化数据，更加有效的完成谓词下推。 ORC文件格式ORC文件格式是一种Hadoop生态圈中的列式存储格式，它的产生早在2013年初，最初产生自Apache Hive，用于降低Hadoop数据存储空间和加速Hive查询速度。和Parquet类似，它并不是一个单纯的列式存储格式，仍然是首先根据行组分割整个表，在每一个行组内进行按列存储。ORC文件是自描述的，它的元数据使用Protocol Buffers序列化，并且文件中的数据尽可能的压缩以降低存储空间的消耗，目前也被Spark SQL、Presto等查询引擎支持，但是Impala对于ORC目前没有支持，仍然使用Parquet作为主要的列式存储格式。2015年ORC项目被Apache项目基金会提升为Apache顶级项目。 数据模型和Parquet不同，ORC原生是不支持嵌套数据格式的，而是通过对复杂数据类型特殊处理的方式实现嵌套格式的支持，例如对于如下的hive表： 12345CREATE TABLE `orcStructTable`( `name` string, `course` struct&lt;course:string,score:int&gt;, `score` map&lt;string,int&gt;, `work_locations` array&lt;string&gt;) 图5 ORC的schema结构 在ORC的结构中这个schema包含10个column，其中包含了复杂类型列和原始类型的列，前者包括LIST、STRUCT、MAP和UNION类型，后者包括BOOLEAN、整数、浮点数、字符串类型等，其中STRUCT的孩子节点包括它的成员变量，可能有多个孩子节点，MAP有两个孩子节点，分别为key和value，LIST包含一个孩子节点，类型为该LIST的成员类型，UNION一般不怎么用得到。每一个Schema树的根节点为一个Struct类型，所有的column按照树的中序遍历顺序编号。 ORC只需要存储schema树中叶子节点的值，而中间的非叶子节点只是做一层代理，它们只需要负责孩子节点值得读取，只有真正的叶子节点才会读取数据，然后交由父节点封装成对应的数据结构返回。 文件结构和Parquet类似，ORC文件也是以二进制方式存储的，所以是不可以直接读取，ORC文件也是自解析的，它包含许多的元数据，这些元数据都是同构ProtoBuffer进行序列化的。ORC的文件结构入图6，其中涉及到如下的概念： ORC文件：保存在文件系统上的普通二进制文件，一个ORC文件中可以包含多个stripe，每一个stripe包含多条记录，这些记录按照列进行独立存储，对应到Parquet中的row group的概念。 文件级元数据：包括文件的描述信息PostScript、文件meta信息（包括整个文件的统计信息）、所有stripe的信息和文件schema信息。 stripe：一组行形成一个stripe，每次读取文件是以行组为单位的，一般为HDFS的块大小，保存了每一列的索引和数据。 stripe元数据：保存stripe的位置、每一个列的在该stripe的统计信息以及所有的stream类型和位置。 row group：索引的最小单位，一个stripe中包含多个row group，默认为10000个值组成。 stream：一个stream表示文件中一段有效的数据，包括索引和数据两类。索引stream保存每一个row group的位置和统计信息，数据stream包括多种类型的数据，具体需要哪几种是由该列类型和编码方式决定。 图6 ORC文件结构 在ORC文件中保存了三个层级的统计信息，分别为文件级别、stripe级别和row group级别的，他们都可以用来根据Search ARGuments（谓词下推条件）判断是否可以跳过某些数据，在统计信息中都包含成员数和是否有null值，并且对于不同类型的数据设置一些特定的统计信息。 数据访问读取ORC文件是从尾部开始的，第一次读取16KB的大小，尽可能的将Postscript和Footer数据都读入内存。文件的最后一个字节保存着PostScript的长度，它的长度不会超过256字节，PostScript中保存着整个文件的元数据信息，它包括文件的压缩格式、文件内部每一个压缩块的最大长度(每次分配内存的大小)、Footer长度，以及一些版本信息。在Postscript和Footer之间存储着整个文件的统计信息(上图中未画出)，这部分的统计信息包括每一个stripe中每一列的信息，主要统计成员数、最大值、最小值、是否有空值等。 接下来读取文件的Footer信息，它包含了每一个stripe的长度和偏移量，该文件的schema信息(将schema树按照schema中的编号保存在数组中)、整个文件的统计信息以及每一个row group的行数。 处理stripe时首先从Footer中获取每一个stripe的其实位置和长度、每一个stripe的Footer数据(元数据，记录了index和data的的长度)，整个striper被分为index和data两部分，stripe内部是按照row group进行分块的(每一个row group中多少条记录在文件的Footer中存储)，row group内部按列存储。每一个row group由多个stream保存数据和索引信息。每一个stream的数据会根据该列的类型使用特定的压缩算法保存。在ORC中存在如下几种stream类型： PRESENT：每一个成员值在这个stream中保持一位(bit)用于标示该值是否为NULL，通过它可以只记录部位NULL的值 DATA：该列的中属于当前stripe的成员值。 LENGTH：每一个成员的长度，这个是针对string类型的列才有的。 DICTIONARY_DATA：对string类型数据编码之后字典的内容。 SECONDARY：存储Decimal、timestamp类型的小数或者纳秒数等。 ROW_INDEX：保存stripe中每一个row group的统计信息和每一个row group起始位置信息。 在初始化阶段获取全部的元数据之后，可以通过includes数组指定需要读取的列编号，它是一个boolean数组，如果不指定则读取全部的列，还可以通过传递SearchArgument参数指定过滤条件，根据元数据首先读取每一个stripe中的index信息，然后根据index中统计信息以及SearchArgument参数确定需要读取的row group编号，再根据includes数据决定需要从这些row group中读取的列，通过这两层的过滤需要读取的数据只是整个stripe多个小段的区间，然后ORC会尽可能合并多个离散的区间尽可能的减少I/O次数。然后再根据index中保存的下一个row group的位置信息调至该stripe中第一个需要读取的row group中。 由于ORC中使用了更加精确的索引信息，使得在读取数据时可以指定从任意一行开始读取，更细粒度的统计信息使得读取ORC文件跳过整个row group，ORC默认会对任何一块数据和索引信息使用ZLIB压缩，因此ORC文件占用的存储空间也更小，这点在后面的测试对比中也有所印证。 在新版本的ORC中也加入了对Bloom Filter的支持，它可以进一步提升谓词下推的效率，在Hive 1.2.0版本以后也加入了对此的支持。 性能测试为了对比测试两种存储格式，我选择使用TPC-DS数据集并且对它进行改造以生成宽表、嵌套和多层嵌套的数据。使用最常用的Hive作为SQL引擎进行测试。 测试环境 Hadoop集群：物理测试集群，四台DataNode/NodeManager机器，每个机器32core+128GB，测试时使用整个集群的资源。 Hive：Hive 1.2.1版本，使用hiveserver2启动，本机MySql作为元数据库，jdbc方式提交查询SQL 数据集：100GB TPC-DS数据集，选取其中的Store_Sales为事实表的模型作为测试数据 查询SQL：选择TPC-DS中涉及到上述模型的10条SQL并对其进行改造。 测试场景和结果整个测试设置了四种场景，每一种场景下对比测试数据占用的存储空间的大小和相同查询执行消耗的时间对比，除了场景一基于原始的TPC-DS数据集外，其余的数据都需要进行数据导入，同时对比这几个场景的数据导入时间。 场景一：一个事实表、多个维度表，复杂的join查询。基于原始的TPC-DS数据集。 Store_Sales表记录数：287,997,024，表大小为： 原始Text格式，未压缩 : 38.1 G ORC格式，默认压缩（ZLIB）,一共1800+个分区 : 11.5 G Parquet格式，默认压缩（Snappy），一共1800+个分区 ： 14.8 G 查询测试结果： 场景二：维度表和事实表join之后生成的宽表，只在一个表上做查询。整个测试设置了四种场景，每一种场景下对比测试数据占用的存储空间的大小和相同查询执行消耗的时间对比，除了场景一基于原始的TPC-DS数据集外，其余的数据都需要进行数据导入，同时对比这几个场景的数据导入时间。选取数据模型中的store_sales, household_demographics, customer_address, date_dim, store表生成一个扁平式宽表(store_sales_wide_table)，基于这个表执行查询，由于场景一种选择的query大多数不能完全match到这个宽表，所以对场景1中的SQL进行部分改造。 store_sales_wide_table表记录数：263,704,266，表大小为： 原始Text格式，未压缩 ： 149.0 G ORC格式，默认压缩 ： 10.6 G PARQUET格式，默认压缩 ： 12.5 G 查询测试结果： 场景三：复杂的数据结构组成的宽表，struct、list、map等（1层）整个测试设置了四种场景，每一种场景下对比测试数据占用的存储空间的大小和相同查询执行消耗的时间对比，除了场景一基于原始的TPC-DS数据集外，其余的数据都需要进行数据导入，同时对比这几个场景的数据导入时间。在场景二的基础上，将维度表（除了store_sales表）转换成一个struct或者map对象，源store_sales表中的字段保持不变。生成有一层嵌套的新表（store_sales_wide_table_one_nested），使用的查询逻辑相同。 store_sales_wide_table_one_nested表记录数：263,704,266，表大小为： 原始Text格式，未压缩 ： 245.3 G ORC格式，默认压缩 ： 10.9 G PARQUET格式，默认压缩 ： 29.8 G 查询测试结果： 场景四：复杂的数据结构，多层嵌套。（3层）整个测试设置了四种场景，每一种场景下对比测试数据占用的存储空间的大小和相同查询执行消耗的时间对比，除了场景一基于原始的TPC-DS数据集外，其余的数据都需要进行数据导入，同时对比这几个场景的数据导入时间。在场景三的基础上，将部分维度表的struct内的字段再转换成struct或者map对象，只存在struct中嵌套map的情况，最深的嵌套为三层。生成一个多层嵌套的新表（store_sales_wide_table_more_nested），使用的查询逻辑相同。 该场景中只涉及一个多层嵌套的宽表，没有任何分区字段，store_sales_wide_table_more_nested表记录数：263,704,266，表大小为： 原始Text格式，未压缩 ： 222.7 G ORC格式，默认压缩 ： 10.9 G PARQUET格式，默认压缩 ： 23.1 G 比一层嵌套表store_sales_wide_table_one_nested要小？ 查询测试结果： 结果分析从上述测试结果来看，星状模型对于数据分析场景并不是很合适，多个表的join会大大拖慢查询速度，并且不能很好的利用列式存储带来的性能提升，在使用宽表的情况下，列式存储的性能提升明显，ORC文件格式在存储空间上要远优于Text格式，较之于PARQUET格式有一倍的存储空间提升，在导数据（insert into table select 这样的方式）方面ORC格式也要优于PARQUET，在最终的查询性能上可以看到，无论是无嵌套的扁平式宽表，或是一层嵌套表，还是多层嵌套的宽表，两者的查询性能相差不多，较之于Text格式有2到3倍左右的提升。 另外，通过对比场景二和场景三的测试结果，可以发现扁平式的表结构要比嵌套式结构的查询性能有所提升，所以如果选择使用大宽表，则设计宽表的时候尽可能的将表设计的扁平化，减少嵌套数据。 通过这三种文件存储格式的测试对比，ORC文件存储格式无论是在空间存储、导数据速度还是查询速度上表现的都较好一些，并且ORC可以一定程度上支持ACID操作，社区的发展目前也是Hive中比较提倡使用的一种列式存储格式，另外，本次测试主要针对的是Hive引擎，所以不排除存在Hive与ORC的敏感度比PARQUET要高的可能性。 总结本文主要从数据模型、文件格式和数据访问流程等几个方面详细介绍了Hadoop生态圈中的两种列式存储格式——Parquet和ORC，并通过大数据量的测试对两者的存储和查询性能进行了对比。对于大数据场景下的数据分析需求，使用这两种存储格式总会带来存储和性能上的提升，但是在实际使用时还需要针对实际的数据进行选择。另外由于不同开源产品可能对不同的存储格式有特定的优化，所以选择时还需要考虑查询引擎的因素。 拓展阅读：spark关于parquet的优化","raw":null,"content":null,"categories":[{"name":"spark","slug":"spark","permalink":"https://stanxia.github.io/categories/spark/"}],"tags":[{"name":"spark","slug":"spark","permalink":"https://stanxia.github.io/tags/spark/"},{"name":"orc","slug":"orc","permalink":"https://stanxia.github.io/tags/orc/"},{"name":"parquet","slug":"parquet","permalink":"https://stanxia.github.io/tags/parquet/"}]},{"title":"spark分层取样","slug":"spark分层取样","date":"2017-11-27T16:57:10.000Z","updated":"2019-04-17T06:08:31.936Z","comments":true,"path":"2017/11/27/spark分层取样/","link":"","permalink":"https://stanxia.github.io/2017/11/27/spark分层取样/","excerpt":"先将总体的单位按某种特征分为若干次级总体（层），然后再从每一层内进行单纯随机抽样，组成一个样本的统计学计算方法叫做分层抽样。在spark.mllib中，用key来分层。\n与存在于spark.mllib中的其它统计函数不同，分层采样方法sampleByKey和sampleByKeyExact可以在key-value对的RDD上执行。在分层采样中，可以认为key是一个标签，value是特定的属性。例如，key可以是男人或者女人或者文档id,它相应的value可能是一组年龄或者是文档中的词。sampleByKey方法通过掷硬币的方式决定是否采样一个观察数据，因此它需要我们传递（pass over）数据并且提供期望的数据大小(size)。sampleByKeyExact比每层使用sampleByKey随机抽样需要更多的有意义的资源，但是它能使样本大小的准确性达到了99.99%。\nsampleByKeyExact()允许用户准确抽取f_k * n_k个样本，这里f_k表示期望获取键为k的样本的比例，n_k表示键为k的键值对的数量。下面是一个使用的例子：","text":"先将总体的单位按某种特征分为若干次级总体（层），然后再从每一层内进行单纯随机抽样，组成一个样本的统计学计算方法叫做分层抽样。在spark.mllib中，用key来分层。 与存在于spark.mllib中的其它统计函数不同，分层采样方法sampleByKey和sampleByKeyExact可以在key-value对的RDD上执行。在分层采样中，可以认为key是一个标签，value是特定的属性。例如，key可以是男人或者女人或者文档id,它相应的value可能是一组年龄或者是文档中的词。sampleByKey方法通过掷硬币的方式决定是否采样一个观察数据，因此它需要我们传递（pass over）数据并且提供期望的数据大小(size)。sampleByKeyExact比每层使用sampleByKey随机抽样需要更多的有意义的资源，但是它能使样本大小的准确性达到了99.99%。 sampleByKeyExact()允许用户准确抽取f_k * n_k个样本，这里f_k表示期望获取键为k的样本的比例，n_k表示键为k的键值对的数量。下面是一个使用的例子： 123456789import org.apache.spark.SparkContextimport org.apache.spark.SparkContext._import org.apache.spark.rdd.PairRDDFunctionsval sc: SparkContext = ...val data = ... // an RDD[(K, V)] of any key value pairsval fractions: Map[K, Double] = ... // specify the exact fraction desired from each key// Get an exact sample from each stratumval approxSample = data.sampleByKey(withReplacement = false, fractions)val exactSample = data.sampleByKeyExact(withReplacement = false, fractions) 当withReplacement为true时，采用PoissonSampler取样器，当withReplacement为false使，采用BernoulliSampler取样器。 123456789101112131415161718192021def sampleByKey(withReplacement: Boolean, fractions: Map[K, Double], seed: Long = Utils.random.nextLong): RDD[(K, V)] = self.withScope &#123; val samplingFunc = if (withReplacement) &#123; StratifiedSamplingUtils.getPoissonSamplingFunction(self, fractions, false, seed) &#125; else &#123; StratifiedSamplingUtils.getBernoulliSamplingFunction(self, fractions, false, seed) &#125; self.mapPartitionsWithIndex(samplingFunc, preservesPartitioning = true) &#125;def sampleByKeyExact( withReplacement: Boolean, fractions: Map[K, Double], seed: Long = Utils.random.nextLong): RDD[(K, V)] = self.withScope &#123; val samplingFunc = if (withReplacement) &#123; StratifiedSamplingUtils.getPoissonSamplingFunction(self, fractions, true, seed) &#125; else &#123; StratifiedSamplingUtils.getBernoulliSamplingFunction(self, fractions, true, seed) &#125; self.mapPartitionsWithIndex(samplingFunc, preservesPartitioning = true) &#125; 下面我们分别来看sampleByKey和sampleByKeyExact的实现。 sampleByKey的实现当我们需要不重复抽样时，我们需要用泊松抽样器来抽样。当需要重复抽样时，用伯努利抽样器抽样。sampleByKey的实现比较简单，它就是统一的随机抽样。 泊松抽样器我们首先看泊松抽样器的实现。 12345678910111213141516171819def getPoissonSamplingFunction[K: ClassTag, V: ClassTag](rdd: RDD[(K, V)], fractions: Map[K, Double], exact: Boolean, seed: Long): (Int, Iterator[(K, V)]) =&gt; Iterator[(K, V)] = &#123; (idx: Int, iter: Iterator[(K, V)]) =&gt; &#123; //初始化随机生成器 val rng = new RandomDataGenerator() rng.reSeed(seed + idx) iter.flatMap &#123; item =&gt; //获得下一个泊松值 val count = rng.nextPoisson(fractions(item._1)) if (count == 0) &#123; Iterator.empty &#125; else &#123; Iterator.fill(count)(item) &#125; &#125; &#125;&#125; getPoissonSamplingFunction返回的是一个函数，传递给mapPartitionsWithIndex处理每个分区的数据。这里RandomDataGenerator是一个随机生成器，它用于同时生成均匀值(uniform values)和泊松值(Poisson values)。 伯努利抽样器1234567891011121314def getBernoulliSamplingFunction[K, V](rdd: RDD[(K, V)], fractions: Map[K, Double], exact: Boolean, seed: Long): (Int, Iterator[(K, V)]) =&gt; Iterator[(K, V)] = &#123; var samplingRateByKey = fractions (idx: Int, iter: Iterator[(K, V)]) =&gt; &#123; //初始化随机生成器 val rng = new RandomDataGenerator() rng.reSeed(seed + idx) // Must use the same invoke pattern on the rng as in getSeqOp for without replacement // in order to generate the same sequence of random numbers when creating the sample iter.filter(t =&gt; rng.nextUniform() &lt; samplingRateByKey(t._1)) &#125; &#125; sampleByKeyExact的实现sampleByKeyExact获取更准确的抽样结果，它的实现也分为两种情况，重复抽样和不重复抽样。前者使用泊松抽样器，后者使用伯努利抽样器。 泊松抽样器12345678910111213141516171819202122232425val counts = Some(rdd.countByKey())//计算立即接受的样本数量，并且为每层生成候选名单val finalResult = getAcceptanceResults(rdd, true, fractions, counts, seed)//决定接受样本的阈值，生成准确的样本大小val thresholdByKey = computeThresholdByKey(finalResult, fractions)(idx: Int, iter: Iterator[(K, V)]) =&gt; &#123; val rng = new RandomDataGenerator() rng.reSeed(seed + idx) iter.flatMap &#123; item =&gt; val key = item._1 val acceptBound = finalResult(key).acceptBound // Must use the same invoke pattern on the rng as in getSeqOp for with replacement // in order to generate the same sequence of random numbers when creating the sample val copiesAccepted = if (acceptBound == 0) 0L else rng.nextPoisson(acceptBound) //候选名单 val copiesWaitlisted = rng.nextPoisson(finalResult(key).waitListBound) val copiesInSample = copiesAccepted + (0 until copiesWaitlisted).count(i =&gt; rng.nextUniform() &lt; thresholdByKey(key)) if (copiesInSample &gt; 0) &#123; Iterator.fill(copiesInSample.toInt)(item) &#125; else &#123; Iterator.empty &#125; &#125;&#125; 伯努利抽样1234567891011121314151617def getBernoulliSamplingFunction[K, V](rdd: RDD[(K, V)], fractions: Map[K, Double], exact: Boolean, seed: Long): (Int, Iterator[(K, V)]) =&gt; Iterator[(K, V)] = &#123; var samplingRateByKey = fractions //计算立即接受的样本数量，并且为每层生成候选名单 val finalResult = getAcceptanceResults(rdd, false, fractions, None, seed) //决定接受样本的阈值，生成准确的样本大小 samplingRateByKey = computeThresholdByKey(finalResult, fractions) (idx: Int, iter: Iterator[(K, V)]) =&gt; &#123; val rng = new RandomDataGenerator() rng.reSeed(seed + idx) // Must use the same invoke pattern on the rng as in getSeqOp for without replacement // in order to generate the same sequence of random numbers when creating the sample iter.filter(t =&gt; rng.nextUniform() &lt; samplingRateByKey(t._1)) &#125; &#125;","raw":null,"content":null,"categories":[{"name":"spark","slug":"spark","permalink":"https://stanxia.github.io/categories/spark/"}],"tags":[{"name":"spark","slug":"spark","permalink":"https://stanxia.github.io/tags/spark/"},{"name":"源码","slug":"源码","permalink":"https://stanxia.github.io/tags/源码/"},{"name":"取样","slug":"取样","permalink":"https://stanxia.github.io/tags/取样/"}]},{"title":"Dataset.scala","slug":"Dataset-scala","date":"2017-11-23T09:34:44.000Z","updated":"2019-04-17T06:08:31.918Z","comments":true,"path":"2017/11/23/Dataset-scala/","link":"","permalink":"https://stanxia.github.io/2017/11/23/Dataset-scala/","excerpt":"前言Dataset 是一种强类型的领域特定对象集合，可以在使用功能或关系操作的同时进行转换。每个 Dataset 也有一个名为 “DataFrame” 的无类型视图，它是 [[Row]] 的 Dataset。Dataset 上可用的操作分为转换和动作:\n\n转换：产生新的 Dataset ；包括 map, filter, select, and aggregate (groupBy).动作：触发计算并返回结果 ；包括 count, show, or 写数据到文件系统。\n\nDataset是懒加载的，例如：只有提交动作的时候才会触发计算。在内部，Datasets表示一个逻辑计划，它描述生成数据所需的计算。当提交动作时，Spark的查询优化器会优化逻辑计划，并以并行和分布式的方式生成有效执行的物理计划。请使用explain 功能，探索逻辑计划和优化的物理计划。\n为了有效地支持特定于领域的对象，需要[[Encoder]]。编码器将特定类型的“T”映射到Spark的内部类型系统。例如：给一个 Person 类，并带有两个属性：name (string) and age (int),编码器告诉Spark在运行时生成代码，序列化 Person 对象为二进制结构。\n通常有两种创建Dataset的方法:\n\n使用 SparkSession 上可用的 read 方法读取 Spark 指向的存储系统上的文件。用现存的 Datasets 转换而来。\n\nDataset操作也可以是无类型的，通过多种领域专用语言（DSL）方法定义：这些操作非常类似于 R或Python语言中的 数据框架抽象中可用的操作。","text":"前言Dataset 是一种强类型的领域特定对象集合，可以在使用功能或关系操作的同时进行转换。每个 Dataset 也有一个名为 “DataFrame” 的无类型视图，它是 [[Row]] 的 Dataset。Dataset 上可用的操作分为转换和动作: 转换：产生新的 Dataset ；包括 map, filter, select, and aggregate (groupBy).动作：触发计算并返回结果 ；包括 count, show, or 写数据到文件系统。 Dataset是懒加载的，例如：只有提交动作的时候才会触发计算。在内部，Datasets表示一个逻辑计划，它描述生成数据所需的计算。当提交动作时，Spark的查询优化器会优化逻辑计划，并以并行和分布式的方式生成有效执行的物理计划。请使用explain 功能，探索逻辑计划和优化的物理计划。 为了有效地支持特定于领域的对象，需要[[Encoder]]。编码器将特定类型的“T”映射到Spark的内部类型系统。例如：给一个 Person 类，并带有两个属性：name (string) and age (int),编码器告诉Spark在运行时生成代码，序列化 Person 对象为二进制结构。 通常有两种创建Dataset的方法: 使用 SparkSession 上可用的 read 方法读取 Spark 指向的存储系统上的文件。用现存的 Datasets 转换而来。 Dataset操作也可以是无类型的，通过多种领域专用语言（DSL）方法定义：这些操作非常类似于 R或Python语言中的 数据框架抽象中可用的操作。 basic-基础方法toDF123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * Converts this strongly typed collection of data to generic Dataframe. In contrast to the * strongly typed objects that Dataset operations work on, a Dataframe returns generic [[Row]] * objects that allow fields to be accessed by ordinal or name. * 将这种强类型的数据集合转换为一般的Dataframe。 * 与Dataset操作所使用的强类型对象相反， * Dataframe返回泛型[[Row]]对象，这些对象允许通过序号或名称访问字段 * * @group basic * @since 1.6.0 */// This is declared with parentheses to prevent the Scala compiler from treating// `ds.toDF(\"1\")` as invoking this toDF and then apply on the returned DataFrame.// 这是用括号声明的，以防止Scala编译器处理ds.toDF(“1”)调用这个toDF，然后在返回的DataFrame上应用。def toDF(): DataFrame = new Dataset[Row](sparkSession, queryExecution, RowEncoder(schema)) /** * Converts this strongly typed collection of data to generic `DataFrame` with columns renamed. * This can be quite convenient in conversion from an RDD of tuples into a `DataFrame` with * meaningful names. For example: * * 将这种强类型的数据集合转换为通用的“DataFrame”，并将列重命名。 * 在将tuple的RDD转换为富有含义的名称的“DataFrame”时，这是非常方便的，如： * * &#123;&#123;&#123; * val rdd: RDD[(Int, String)] = ... * rdd.toDF() // 隐式转换创建了 DataFrame ，列名为： `_1` and `_2` * rdd.toDF(\"id\", \"name\") // 创建了 DataFrame ，列名为： \"id\" and \"name\" * &#125;&#125;&#125; * * @group basic * @since 2.0.0 */@scala.annotation.varargsdef toDF(colNames: String*): DataFrame = &#123; require(schema.size == colNames.size, \"The number of columns doesn't match.\\n\" + s\"Old column names ($&#123;schema.size&#125;): \" + schema.fields.map(_.name).mkString(\", \") + \"\\n\" + s\"New column names ($&#123;colNames.size&#125;): \" + colNames.mkString(\", \")) val newCols = logicalPlan.output.zip(colNames).map &#123; case (oldAttribute, newName) =&gt; Column(oldAttribute).as(newName) &#125; select(newCols: _*)&#125; as123456789101112131415161718192021222324252627282930313233/** * :: Experimental :: * Returns a new Dataset where each record has been mapped on to the specified type. The * method used to map columns depend on the type of `U`: * * 返回一个新的Dataset，其中每个记录都被映射到指定的类型。用于映射列的方法取决于“U”的类型: * * - When `U` is a class, fields for the class will be mapped to columns of the same name * (case sensitivity is determined by `spark.sql.caseSensitive`). * * 当“U”是类时：类的属性将映射到相同名称的列 * * - When `U` is a tuple, the columns will be be mapped by ordinal (i.e. the first column will * be assigned to `_1`). * * 当“U”是元组时：列将由序数映射 （例如，第一列将为 \"_1\"） * * - When `U` is a primitive type (i.e. String, Int, etc), then the first column of the * `DataFrame` will be used. * * 当“U”是 基本类型（如 String，Int等）：然后将使用“DataFrame”的第一列。 * * If the schema of the Dataset does not match the desired `U` type, you can use `select` * along with `alias` or `as` to rearrange or rename as required. * * 如果数据集的模式与所需的“U”类型不匹配，您可以使用“select”和“alias”或“as”来重新排列或重命名。 * * @group basic * @since 1.6.0 */ @Experimental @InterfaceStability.Evolving def as[U: Encoder]: Dataset[U] = Dataset[U](sparkSession, logicalPlan) schema12345678/** * Returns the schema of this Dataset. * 返回该Dataset的模版 * * @group basic * @since 1.6.0 */def schema: StructType = queryExecution.analyzed.schema printSchema12345678910/** * Prints the schema to the console in a nice tree format. * * 以一种漂亮的树格式将模式打印到控制台。 * * @group basic * @since 1.6.0 */// scalastyle:off printlndef printSchema(): Unit = println(schema.treeString) explain1234567891011121314151617181920212223242526/** * Prints the plans (logical and physical) to the console for debugging purposes. * * 将计划(逻辑和物理)打印到控制台以进行调试。 * 参数：extended = false 为物理计划 * * @group basic * @since 1.6.0 */def explain(extended: Boolean): Unit = &#123; val explain = ExplainCommand(queryExecution.logical, extended = extended) sparkSession.sessionState.executePlan(explain).executedPlan.executeCollect().foreach &#123; // scalastyle:off println r =&gt; println(r.getString(0)) // scalastyle:on println &#125;&#125; /** * Prints the physical plan to the console for debugging purposes. * 将物理计划打印到控制台以进行调试。 * * @group basic * @since 1.6.0 */def explain(): Unit = explain(extended = false) dtypes12345678910/** * Returns all column names and their data types as an array. * 以数组的形式返回所有列名称和它们的数据类型 * * @group basic * @since 1.6.0 */def dtypes: Array[(String, String)] = schema.fields.map &#123; field =&gt; (field.name, field.dataType.toString)&#125; columns12345678/** * Returns all column names as an array. * 以数组的形式返回 所有列名 * * @group basic * @since 1.6.0 */def columns: Array[String] = schema.fields.map(_.name) isLocal123456789/** * Returns true if the `collect` and `take` methods can be run locally * (without any Spark executors). * 如果`collect` and `take` 方法能在本地运行，则返回true * * @group basic * @since 1.6.0 */def isLocal: Boolean = logicalPlan.isInstanceOf[LocalRelation] checkpoint12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/** * Eagerly checkpoint a Dataset and return the new Dataset. Checkpointing can be used to truncate * the logical plan of this Dataset, which is especially useful in iterative algorithms where the * plan may grow exponentially. It will be saved to files inside the checkpoint * directory set with `SparkContext#setCheckpointDir`. * * 急切地检查一个数据集并返回新的数据集。 * 检查点能用来清除Dataset的逻辑计划，尤其是在可能生成指数级别的迭代算法中尤其有用。 * 将会在检查点目录中保存检查文件。可以在`SparkContext#setCheckpointDir`中设置。 * * @group basic * @since 2.1.0 */@Experimental@InterfaceStability.Evolvingdef checkpoint(): Dataset[T] = checkpoint(eager = true) /** * Returns a checkpointed version of this Dataset. Checkpointing can be used to truncate the * logical plan of this Dataset, which is especially useful in iterative algorithms where the * plan may grow exponentially. It will be saved to files inside the checkpoint * directory set with `SparkContext#setCheckpointDir`. * 返回Dataset 之前检查过的版本。 * 检查点能用来清除Dataset的逻辑计划，尤其是在可能生成指数级别的迭代算法中尤其有用。 * 将会在检查点目录中保存检查文件。可以在`SparkContext#setCheckpointDir`中设置。 * * @group basic * @since 2.1.0 */@Experimental@InterfaceStability.Evolvingdef checkpoint(eager: Boolean): Dataset[T] = &#123; val internalRdd = queryExecution.toRdd.map(_.copy()) internalRdd.checkpoint() if (eager) &#123; internalRdd.count() &#125; val physicalPlan = queryExecution.executedPlan // Takes the first leaf partitioning whenever we see a `PartitioningCollection`. Otherwise the // size of `PartitioningCollection` may grow exponentially for queries involving deep inner // joins. // 每当我们看到“PartitioningCollection”时，就采用第一个叶子分区 // 否则，用于涉及深度内连接的查询，“PartitioningCollection”的大小可能会以指数形式增长。 def firstLeafPartitioning(partitioning: Partitioning): Partitioning = &#123; partitioning match &#123; case p: PartitioningCollection =&gt; firstLeafPartitioning(p.partitionings.head) case p =&gt; p &#125; &#125; val outputPartitioning = firstLeafPartitioning(physicalPlan.outputPartitioning) Dataset.ofRows( sparkSession, LogicalRDD( logicalPlan.output, internalRdd, outputPartitioning, physicalPlan.outputOrdering )(sparkSession)).as[T]&#125; persist1234567891011121314151617181920212223242526272829303132333435/** * Persist this Dataset with the default storage level (`MEMORY_AND_DISK`). * * 持久化。 * 根据默认的 存储级别 (`MEMORY_AND_DISK`) 持久化Dataset。 * * @group basic * @since 1.6.0 */def persist(): this.type = &#123; sparkSession.sharedState.cacheManager.cacheQuery(this) this&#125; /** * Persist this Dataset with the given storage level. * * 根据指定的 存储级别 持久化 Dataset。 * * @param newLevel One of: * `MEMORY_ONLY`, * `MEMORY_AND_DISK`, * `MEMORY_ONLY_SER`, * `MEMORY_AND_DISK_SER`, * `DISK_ONLY`, * `MEMORY_ONLY_2`, 与MEMORY_ONLY的区别是会备份数据到其他节点上 * `MEMORY_AND_DISK_2`, 与MEMORY_AND_DISK的区别是会备份数据到其他节点上 * etc. * @group basic * @since 1.6.0 */def persist(newLevel: StorageLevel): this.type = &#123; sparkSession.sharedState.cacheManager.cacheQuery(this, None, newLevel) this&#125; cache1234567891011/** * Persist this Dataset with the default storage level (`MEMORY_AND_DISK`). * * 持久化。 * 根据默认的 存储级别 (`MEMORY_AND_DISK`) 持久化Dataset。 * 和 persist 一致。 * * @group basic * @since 1.6.0 */def cache(): this.type = persist() storageLevel12345678910111213/** * Get the Dataset's current storage level, or StorageLevel.NONE if not persisted. * * 获取当前Dataset的当前存储级别。如果没有缓存则 StorageLevel.NONE。 * * @group basic * @since 2.1.0 */def storageLevel: StorageLevel = &#123; sparkSession.sharedState.cacheManager.lookupCachedData(this).map &#123; cachedData =&gt; cachedData.cachedRepresentation.storageLevel &#125;.getOrElse(StorageLevel.NONE)&#125; unpersist1234567891011121314151617181920212223242526/** * Mark the Dataset as non-persistent, and remove all blocks for it from memory and disk. * * 解除持久化。 * 将Dataset标记为非持久化，并从内存和磁盘中移除所有的块。 * * @param blocking Whether to block until all blocks are deleted. * 是否阻塞，直到删除所有的块。 * @group basic * @since 1.6.0 */def unpersist(blocking: Boolean): this.type = &#123; sparkSession.sharedState.cacheManager.uncacheQuery(this, blocking) this&#125; /** * Mark the Dataset as non-persistent, and remove all blocks for it from memory and disk. * * 解除持久化。 * 将Dataset标记为非持久化，并从内存和磁盘中移除所有的块。 * * @group basic * @since 1.6.0 */def unpersist(): this.type = unpersist(blocking = false) rdd123456789101112131415/** * Represents the content of the Dataset as an `RDD` of [[T]]. * * 转换为[[T]]的“RDD”，表示Dataset的内容 * * @group basic * @since 1.6.0 */lazy val rdd: RDD[T] = &#123; val objectType = exprEnc.deserializer.dataType val deserialized = CatalystSerde.deserialize[T](logicalPlan) sparkSession.sessionState.executePlan(deserialized).toRdd.mapPartitions &#123; rows =&gt; rows.map(_.get(0, objectType).asInstanceOf[T]) &#125;&#125; toJavaRDD12345678910111213141516171819/** * Returns the content of the Dataset as a `JavaRDD` of [[T]]s. * * 转换为JavaRDD * * @group basic * @since 1.6.0 */def toJavaRDD: JavaRDD[T] = rdd.toJavaRDD() /** * Returns the content of the Dataset as a `JavaRDD` of [[T]]s. * * 转换为JavaRDD * * @group basic * @since 1.6.0 */def javaRDD: JavaRDD[T] = toJavaRDD registerTempTable1234567891011121314/** * Registers this Dataset as a temporary table using the given name. The lifetime of this * temporary table is tied to the [[SparkSession]] that was used to create this Dataset. * * 根据指定的表名，注册临时表。 * 生命周期为[[SparkSession]]的生命周期。 * * @group basic * @since 1.6.0 */@deprecated(\"Use createOrReplaceTempView(viewName) instead.\", \"2.0.0\")def registerTempTable(tableName: String): Unit = &#123; createOrReplaceTempView(tableName)&#125; createTempView123456789101112131415161718192021/** * Creates a local temporary view using the given name. The lifetime of this * temporary view is tied to the [[SparkSession]] that was used to create this Dataset. * * 用指定的名字创建本地临时表。 * 与[[SparkSession]] 同生命周期。 * * Local temporary view is session-scoped. Its lifetime is the lifetime of the session that * created it, i.e. it will be automatically dropped when the session terminates. It's not * tied to any databases, i.e. we can't use `db1.view1` to reference a local temporary view. * * 本地临时表是 session范围内的。当创建它的session停止的时候，该表也随之停止。 * * @throws AnalysisException if the view name already exists * @group basic * @since 2.0.0 */@throws[AnalysisException]def createTempView(viewName: String): Unit = withPlan &#123; createTempViewCommand(viewName, replace = false, global = false)&#125; createOrReplaceTempView123456789101112/** * Creates a local temporary view using the given name. The lifetime of this * temporary view is tied to the [[SparkSession]] that was used to create this Dataset. * * 用指定的名字创建本地临时表。如果已经有了则替换。 * * @group basic * @since 2.0.0 */def createOrReplaceTempView(viewName: String): Unit = withPlan &#123; createTempViewCommand(viewName, replace = true, global = false)&#125; createGlobalTempView1234567891011121314151617181920212223/** * Creates a global temporary view using the given name. The lifetime of this * temporary view is tied to this Spark application. * * 创建全局临时表。 * 生命周期为整个Spark application. * * Global temporary view is cross-session. Its lifetime is the lifetime of the Spark application, * i.e. it will be automatically dropped when the application terminates. It's tied to a system * preserved database `_global_temp`, and we must use the qualified name to refer a global temp * view, e.g. `SELECT * FROM _global_temp.view1`. * * 全局临时表是跨session的。属于 _global_temp 数据库。e.g. `SELECT * FROM _global_temp.view1`. * * @throws AnalysisException if the view name already exists * 如果表已经存在，则报错。 * @group basic * @since 2.1.0 */@throws[AnalysisException]def createGlobalTempView(viewName: String): Unit = withPlan &#123; createTempViewCommand(viewName, replace = false, global = true)&#125; write123456789101112131415/** * Interface for saving the content of the non-streaming Dataset out into external storage. * * 将非流Dataset的内容保存到外部存储中的接口。 * * @group basic * @since 1.6.0 */def write: DataFrameWriter[T] = &#123; if (isStreaming) &#123; logicalPlan.failAnalysis( \"'write' can not be called on streaming Dataset/DataFrame\") &#125; new DataFrameWriter[T](this)&#125; writeStream123456789101112131415161718/** * :: Experimental :: * Interface for saving the content of the streaming Dataset out into external storage. * * 将流Dataset保存在外部存储。 * * @group basic * @since 2.0.0 */@Experimental@InterfaceStability.Evolvingdef writeStream: DataStreamWriter[T] = &#123; if (!isStreaming) &#123; logicalPlan.failAnalysis( \"'writeStream' can be called only on streaming Dataset/DataFrame\") &#125; new DataStreamWriter[T](this)&#125; toJSON1234567891011121314151617181920212223242526272829303132333435/** * Returns the content of the Dataset as a Dataset of JSON strings. * * 将Dataset转换为JSON。 * * @since 2.0.0 */def toJSON: Dataset[String] = &#123; val rowSchema = this.schema val rdd: RDD[String] = queryExecution.toRdd.mapPartitions &#123; iter =&gt; val writer = new CharArrayWriter() // create the Generator without separator inserted between 2 records val gen = new JacksonGenerator(rowSchema, writer) new Iterator[String] &#123; override def hasNext: Boolean = iter.hasNext override def next(): String = &#123; gen.write(iter.next()) gen.flush() val json = writer.toString if (hasNext) &#123; writer.reset() &#125; else &#123; gen.close() &#125; json &#125; &#125; &#125; import sparkSession.implicits.newStringEncoder sparkSession.createDataset(rdd)&#125; inputFiles12345678910111213141516171819202122/** * Returns a best-effort snapshot of the files that compose this Dataset. This method simply * asks each constituent BaseRelation for its respective files and takes the union of all results. * Depending on the source relations, this may not find all input files. Duplicates are removed. * * 返回组成这个Dataset的所有文件的最佳快照。 * 该方法简单地要求每个组件BaseRelation对其各自的文件进行处理，并联合所有结果。 * 基于源关系，应该可以找到所有的输入文件。 * 重复的也会被移除。 * * @group basic * @since 2.0.0 */def inputFiles: Array[String] = &#123; val files: Seq[String] = queryExecution.optimizedPlan.collect &#123; case LogicalRelation(fsBasedRelation: FileRelation, _, _) =&gt; fsBasedRelation.inputFiles case fr: FileRelation =&gt; fr.inputFiles &#125;.flatten files.toSet.toArray&#125; streamingisStreaming123456789101112131415161718/** * Returns true if this Dataset contains one or more sources that continuously * return data as it arrives. A Dataset that reads data from a streaming source * must be executed as a `StreamingQuery` using the `start()` method in * `DataStreamWriter`. Methods that return a single answer, e.g. `count()` or * `collect()`, will throw an [[AnalysisException]] when there is a streaming * source present. * * 如果Dataset包含一个或多个持续返回数据的源，则返回true； * 如果Dataset从streaming源读取数据，则必须像 `StreamingQuery` 一样执行：使用 `DataStreamWriter` 中的 `start()`方法。 * 返回单个值的方法，例如： `count()` or `collect()`，当存在streaming源时，将会抛出[[AnalysisException]]。 * * @group streaming * @since 2.0.0 */@Experimental@InterfaceStability.Evolvingdef isStreaming: Boolean = logicalPlan.isStreaming withWatermark123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * :: Experimental :: 实验性的 * Defines an event time watermark for this [[Dataset]]. A watermark tracks a point in time * before which we assume no more late data is going to arrive. * * 为这个[[Dataset]]定义事件时间水印。 * 我们假设没有更多的晚期数据将到达之前，一个水印跟踪一个时间点。 * * Spark will use this watermark for several purposes: * Spark用水印有几个目的： * - To know when a given time window aggregation can be finalized and thus can be emitted when * using output modes that do not allow updates. * * 可以知道何时完成给定的时间窗口聚合能够完成，因此当使用不允许更新的输出模式时能够被放出。 * - To minimize the amount of state that we need to keep for on-going aggregations. * 为了最小化我们需要持续不断的聚合的状态数量。 * * * The current watermark is computed by looking at the `MAX(eventTime)` seen across * all of the partitions in the query minus a user specified `delayThreshold`. Due to the cost * of coordinating this value across partitions, the actual watermark used is only guaranteed * to be at least `delayThreshold` behind the actual event time. In some cases we may still * process records that arrive more than `delayThreshold` late. * * 当前的水印 = 查看查询中所有分区上看到的`MAX(eventTime)` - 用户指定的`delayThreshold` * 由于在分区之间协调这个值的花销，实际使用的水印只保证在实际事件时间后至少是“delayThreshold”。 * 在某些情况下，我们可能还会处理比“delayThreshold”晚些时候到达的记录。 * * @param eventTime the name of the column that contains the event time of the row. * 包含行的事件时间的列名 * @param delayThreshold the minimum delay to wait to data to arrive late, relative to the latest * record that has been processed in the form of an interval * (e.g. \"1 minute\" or \"5 hours\"). * 等待晚到数据的最少延迟，相对于以间隔形式处理的最新记录 * @group streaming * @since 2.1.0 */@Experimental@InterfaceStability.Evolving// We only accept an existing column name, not a derived column here as a watermark that is// defined on a derived column cannot referenced elsewhere in the plan.// 我们只接受一个现有的列名，而不是作为一个在派生列上定义的水印的派生列，而不能在该计划的其他地方引用。def withWatermark(eventTime: String, delayThreshold: String): Dataset[T] = withTypedPlan &#123; val parsedDelay = Option(CalendarInterval.fromString(\"interval \" + delayThreshold)) .getOrElse(throw new AnalysisException(s\"Unable to parse time delay '$delayThreshold'\")) EventTimeWatermark(UnresolvedAttribute(eventTime), parsedDelay, logicalPlan)&#125; actionshow123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990/** * Displays the Dataset in a tabular form. Strings more than 20 characters will be truncated, * and all cells will be aligned right. For example: * * 以表格形式显示数据集。 * 字符串超过20个字符将被截断， * 所有单元格将被对齐。 * &#123;&#123;&#123; * year month AVG('Adj Close) MAX('Adj Close) * 1980 12 0.503218 0.595103 * 1981 01 0.523289 0.570307 * 1982 02 0.436504 0.475256 * 1983 03 0.410516 0.442194 * 1984 04 0.450090 0.483521 * &#125;&#125;&#125; * * @param numRows Number of rows to show 要显示的行数 * @group action * @since 1.6.0 */def show(numRows: Int): Unit = show(numRows, truncate = true) /** * Displays the top 20 rows of Dataset in a tabular form. Strings more than 20 characters * will be truncated, and all cells will be aligned right. * 显示头20行 * * @group action * @since 1.6.0 */def show(): Unit = show(20)/** * Displays the top 20 rows of Dataset in a tabular form. * 显示头20行 * * @param truncate Whether truncate long strings. If true, strings more than 20 characters will * be truncated and all cells will be aligned right * 是否截断长字符串。如果 true：超过20个字符就会被截断 * @group action * @since 1.6.0 */def show(truncate: Boolean): Unit = show(20, truncate)/** * Displays the Dataset in a tabular form. For example: * &#123;&#123;&#123; * year month AVG('Adj Close) MAX('Adj Close) * 1980 12 0.503218 0.595103 * 1981 01 0.523289 0.570307 * 1982 02 0.436504 0.475256 * 1983 03 0.410516 0.442194 * 1984 04 0.450090 0.483521 * &#125;&#125;&#125; * * @param numRows Number of rows to show 显示的行数 * @param truncate Whether truncate long strings. If true, strings more than 20 characters will * be truncated and all cells will be aligned right * 是否截断长字符串 * @group action * @since 1.6.0 */// scalastyle:off printlndef show(numRows: Int, truncate: Boolean): Unit = if (truncate) &#123; println(showString(numRows, truncate = 20))&#125; else &#123; println(showString(numRows, truncate = 0))&#125;// scalastyle:on println/** * Displays the Dataset in a tabular form. For example: * &#123;&#123;&#123; * year month AVG('Adj Close) MAX('Adj Close) * 1980 12 0.503218 0.595103 * 1981 01 0.523289 0.570307 * 1982 02 0.436504 0.475256 * 1983 03 0.410516 0.442194 * 1984 04 0.450090 0.483521 * &#125;&#125;&#125; * * @param numRows Number of rows to show * @param truncate If set to more than 0, truncates strings to `truncate` characters and * all cells will be aligned right. * 设置 触发截断字符串的阈值 * @group action * @since 1.6.0 */// scalastyle:off printlndef show(numRows: Int, truncate: Int): Unit = println(showString(numRows, truncate)) reduce1234567891011121314151617181920212223242526272829/** * :: Experimental :: * (Scala-specific) * Reduces the elements of this Dataset using the specified binary function. The given `func` * must be commutative and associative or the result may be non-deterministic. * * 使用指定的二进制函数减少这个数据集的元素。给定的“func”必须是可交换的和关联的，否则结果可能是不确定性的。 * * @group action * @since 1.6.0 */@Experimental@InterfaceStability.Evolvingdef reduce(func: (T, T) =&gt; T): T = rdd.reduce(func)/** * :: Experimental :: * (Java-specific) * Reduces the elements of this Dataset using the specified binary function. The given `func` * must be commutative and associative or the result may be non-deterministic. * * 使用指定的二进制函数减少这个数据集的元素。给定的“func”必须是可交换的和关联的，否则结果可能是不确定性的。 * * @group action * @since 1.6.0 */@Experimental@InterfaceStability.Evolvingdef reduce(func: ReduceFunction[T]): T = reduce(func.call(_, _)) describe123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566/** * Computes statistics for numeric and string columns, including count, mean, stddev, min, and * max. If no columns are given, this function computes statistics for all numerical or string * columns. * * 计算数字和字符串列的统计数据，包括count、mean、stddev、min和max。 * 如果没有给出任何列，该函数计算所有数值或字符串列的统计信息。 * * This function is meant for exploratory data analysis, as we make no guarantee about the * backward compatibility of the schema of the resulting Dataset. If you want to * programmatically compute summary statistics, use the `agg` function instead. * * 这个函数用于探索性的数据分析，因为我们不能保证生成数据集的模式的向后兼容性。 * 如果您想通过编程计算汇总统计信息，可以使用“agg”函数。 * * &#123;&#123;&#123; * ds.describe(\"age\", \"height\").show() * * // output: * // summary age height * // count 10.0 10.0 * // mean 53.3 178.05 * // stddev 11.6 15.7 * // min 18.0 163.0 * // max 92.0 192.0 * &#125;&#125;&#125; * * @group action * @since 1.6.0 */ @scala.annotation.varargs def describe(cols: String*): DataFrame = withPlan &#123; // The list of summary statistics to compute, in the form of expressions. val statistics = List[(String, Expression =&gt; Expression)]( \"count\" -&gt; ((child: Expression) =&gt; Count(child).toAggregateExpression()), \"mean\" -&gt; ((child: Expression) =&gt; Average(child).toAggregateExpression()), \"stddev\" -&gt; ((child: Expression) =&gt; StddevSamp(child).toAggregateExpression()), \"min\" -&gt; ((child: Expression) =&gt; Min(child).toAggregateExpression()), \"max\" -&gt; ((child: Expression) =&gt; Max(child).toAggregateExpression())) val outputCols = (if (cols.isEmpty) aggregatableColumns.map(usePrettyExpression(_).sql) else cols).toList val ret: Seq[Row] = if (outputCols.nonEmpty) &#123; val aggExprs = statistics.flatMap &#123; case (_, colToAgg) =&gt; outputCols.map(c =&gt; Column(Cast(colToAgg(Column(c).expr), StringType)).as(c)) &#125; val row = groupBy().agg(aggExprs.head, aggExprs.tail: _*).head().toSeq // Pivot the data so each summary is one row row.grouped(outputCols.size).toSeq.zip(statistics).map &#123; case (aggregation, (statistic, _)) =&gt; Row(statistic :: aggregation.toList: _*) &#125; &#125; else &#123; // If there are no output columns, just output a single column that contains the stats. statistics.map &#123; case (name, _) =&gt; Row(name) &#125; &#125; // All columns are string type val schema = StructType( StructField(\"summary\", StringType) :: outputCols.map(StructField(_, StringType))).toAttributes // `toArray` forces materialization to make the seq serializable LocalRelation.fromExternalRows(schema, ret.toArray.toSeq) &#125; head123456789101112131415161718192021222324/** * Returns the first `n` rows. * * 返回前n行 * * @note this method should only be used if the resulting array is expected to be small, as * all the data is loaded into the driver's memory. * 仅适用于结果很少的时候使用，因为会将结果加载进内存中 * @group action * @since 1.6.0 */def head(n: Int): Array[T] = withTypedCallback(\"head\", limit(n)) &#123; df =&gt; df.collect(needCallback = false)&#125;/** * Returns the first row. * * 返回第一行（默认1） * * @group action * @since 1.6.0 */def head(): T = head(1).head first123456789/** * Returns the first row. Alias for head(). * * 返回第一行 ，与head()一样 * * @group action * @since 1.6.0 */def first(): T = head() foreach12345678910111213141516171819202122/** * Applies a function `f` to all rows. * * 对所有行应用函数f。 * * @group action * @since 1.6.0 */def foreach(f: T =&gt; Unit): Unit = withNewExecutionId &#123; rdd.foreach(f)&#125;/** * (Java-specific) * Runs `func` on each element of this Dataset. * * 在这个数据集的每个元素上运行“func”。 * * @group action * @since 1.6.0 */def foreach(func: ForeachFunction[T]): Unit = foreach(func.call(_)) foreachPartition1234567891011121314151617181920212223/** * Applies a function `f` to each partition of this Dataset. * * 对这个数据集的每个分区应用一个函数f。 * * @group action * @since 1.6.0 */def foreachPartition(f: Iterator[T] =&gt; Unit): Unit = withNewExecutionId &#123; rdd.foreachPartition(f)&#125;/** * (Java-specific) * Runs `func` on each partition of this Dataset. * * 对这个数据集的每个分区应用一个函数f。 * * @group action * @since 1.6.0 */def foreachPartition(func: ForeachPartitionFunction[T]): Unit = foreachPartition(it =&gt; func.call(it.asJava)) take123456789101112131415/** * Returns the first `n` rows in the Dataset. * * 返回数据集中的前“n”行。 * 同head(n) * * Running take requires moving data into the application's driver process, and doing so with * a very large `n` can crash the driver process with OutOfMemoryError. * * take在driver端执行，n太大会造成oom * * @group action * @since 1.6.0 */def take(n: Int): Array[T] = head(n) takeAsList1234567891011121314/** * Returns the first `n` rows in the Dataset as a list. * * 以List形式返回 前n行 * * Running take requires moving data into the application's driver process, and doing so with * a very large `n` can crash the driver process with OutOfMemoryError. * * take在driver端执行，n太大会造成oom * * @group action * @since 1.6.0 */def takeAsList(n: Int): java.util.List[T] = java.util.Arrays.asList(take(n): _*) collect12345678910111213141516/** * Returns an array that contains all of [[Row]]s in this Dataset. * * 返回包含所有Row的 一个数组 * * Running collect requires moving all the data into the application's driver process, and * doing so on a very large dataset can crash the driver process with OutOfMemoryError. * * 会将所有数据移动到driver，所以可能会造成oom * * For Java API, use [[collectAsList]]. * * @group action * @since 1.6.0 */def collect(): Array[T] = collect(needCallback = true) collectAsList12345678910111213141516171819/** * Returns a Java list that contains all of [[Row]]s in this Dataset. * * 返回包含所有Row的一个Java List * * Running collect requires moving all the data into the application's driver process, and * doing so on a very large dataset can crash the driver process with OutOfMemoryError. * * 会将所有数据移动到driver，所以可能会造成oom * * @group action * @since 1.6.0 */def collectAsList(): java.util.List[T] = withCallback(\"collectAsList\", toDF()) &#123; _ =&gt; withNewExecutionId &#123; val values = queryExecution.executedPlan.executeCollect().map(boundEnc.fromRow) java.util.Arrays.asList(values: _*) &#125;&#125; toLocalIterator12345678910111213141516171819202122/** * Return an iterator that contains all of [[Row]]s in this Dataset. * * 返回包含所有Row的一个迭代器 * * The iterator will consume as much memory as the largest partition in this Dataset. * * 迭代器将消耗与此数据集中最大的分区一样多的内存。 * * @note this results in multiple Spark jobs, and if the input Dataset is the result * of a wide transformation (e.g. join with different partitioners), to avoid * recomputing the input Dataset should be cached first. * 这将导致多个Spark作业，如果输入数据集是宽依赖转换的结果(例如，与不同的分区连接)， * 那么为了避免重新计算输入数据，应该首先缓存输入数据集。 * @group action * @since 2.0.0 */def toLocalIterator(): java.util.Iterator[T] = withCallback(\"toLocalIterator\", toDF()) &#123; _ =&gt; withNewExecutionId &#123; queryExecution.executedPlan.executeToIterator().map(boundEnc.fromRow).asJava &#125;&#125; count1234567891011/** * Returns the number of rows in the Dataset. * * 返回总行数 * * @group action * @since 1.6.0 */def count(): Long = withCallback(\"count\", groupBy().count()) &#123; df =&gt; df.collect(needCallback = false).head.getLong(0)&#125; untypedrel-无类型转换na123456789101112/** * Returns a [[DataFrameNaFunctions]] for working with missing data. * 返回一个用于处理丢失数据的[[DataFrameNaFunctions]]。 * &#123;&#123;&#123; * // Dropping rows containing any null values. 删除包含任何null 值的行 * ds.na.drop() * &#125;&#125;&#125; * * @group untypedrel * @since 1.6.0 */def na: DataFrameNaFunctions = new DataFrameNaFunctions(toDF()) stat123456789101112/** * Returns a [[DataFrameStatFunctions]] for working statistic functions support. * 返回用于支持统计功能的[[DataFrameStatFunctions]]。 * &#123;&#123;&#123; * // Finding frequent items in column with name 'a'. 查询列名为\"a\"中的频繁数据。 * ds.stat.freqItems(Seq(\"a\")) * &#125;&#125;&#125; * * @group untypedrel * @since 1.6.0 */def stat: DataFrameStatFunctions = new DataFrameStatFunctions(toDF()) join123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180/** * Join with another `DataFrame`. * 和 另一个 `DataFrame` jion * * Behaves as an INNER JOIN and requires a subsequent join predicate. * 作为一个内部连接，并需要一个后续的连接谓词。 * * @param right Right side of the join operation. join操作的右侧 * @group untypedrel * @since 2.0.0 */ def join(right: Dataset[_]): DataFrame = withPlan &#123; Join(logicalPlan, right.logicalPlan, joinType = Inner, None) &#125; /** * Inner equi-join with another `DataFrame` using the given column. * 给定列名的内部等值连接 * * Different from other join functions, the join column will only appear once in the output, * i.e. similar to SQL's `JOIN USING` syntax. * * &#123;&#123;&#123; * // Joining df1 and df2 using the column \"user_id\" 用\"user_id\" 连接 df1 和df2 * df1.join(df2, \"user_id\") * &#125;&#125;&#125; * * @param right Right side of the join operation. join连接右侧 * @param usingColumn Name of the column to join on. This column must exist on both sides. * 列名。必须在两边都存在 * @note If you perform a self-join using this function without aliasing the input * `DataFrame`s, you will NOT be able to reference any columns after the join, since * there is no way to disambiguate which side of the join you would like to reference. * 自连接的时候，请指定 表别名。不然干不了事 * @group untypedrel * @since 2.0.0 */ def join(right: Dataset[_], usingColumn: String): DataFrame = &#123; join(right, Seq(usingColumn)) &#125; /** * Inner equi-join with another `DataFrame` using the given columns. * 根据指定多个列进行join * * Different from other join functions, the join columns will only appear once in the output, * i.e. similar to SQL's `JOIN USING` syntax. * * &#123;&#123;&#123; * // Joining df1 and df2 using the columns \"user_id\" and \"user_name\" * df1.join(df2, Seq(\"user_id\", \"user_name\")) * &#125;&#125;&#125; * * @param right Right side of the join operation. * @param usingColumns Names of the columns to join on. This columns must exist on both sides. * @note If you perform a self-join using this function without aliasing the input * `DataFrame`s, you will NOT be able to reference any columns after the join, since * there is no way to disambiguate which side of the join you would like to reference. * @group untypedrel * @since 2.0.0 */ def join(right: Dataset[_], usingColumns: Seq[String]): DataFrame = &#123; join(right, usingColumns, \"inner\") &#125; /** * Equi-join with another `DataFrame` using the given columns. * * Different from other join functions, the join columns will only appear once in the output, * i.e. similar to SQL's `JOIN USING` syntax. * * @param right Right side of the join operation. * @param usingColumns Names of the columns to join on. This columns must exist on both sides. * @param joinType One of: `inner`, `outer`, `left_outer`, `right_outer`, `leftsemi`. * 连接类型：内连接，外连接，左外连接，右外连接，左内连接 * @note If you perform a self-join using this function without aliasing the input * `DataFrame`s, you will NOT be able to reference any columns after the join, since * there is no way to disambiguate which side of the join you would like to reference. * @group untypedrel * @since 2.0.0 */ def join(right: Dataset[_], usingColumns: Seq[String], joinType: String): DataFrame = &#123; // Analyze the self join. The assumption is that the analyzer will disambiguate left vs right // by creating a new instance for one of the branch. // 自连接的时候，为其中一个分支创建一个新实例来消除左vs右的歧义。 val joined = sparkSession.sessionState.executePlan( Join(logicalPlan, right.logicalPlan, joinType = JoinType(joinType), None)) .analyzed.asInstanceOf[Join] withPlan &#123; Join( joined.left, joined.right, UsingJoin(JoinType(joinType), usingColumns), None) &#125; &#125; /** * Inner join with another `DataFrame`, using the given join expression. * 用给定的表达式进行join * &#123;&#123;&#123; * // The following two are equivalent: * df1.join(df2, $\"df1Key\" === $\"df2Key\") * df1.join(df2).where($\"df1Key\" === $\"df2Key\") * &#125;&#125;&#125; * * @group untypedrel * @since 2.0.0 */ def join(right: Dataset[_], joinExprs: Column): DataFrame = join(right, joinExprs, \"inner\") /** * Join with another `DataFrame`, using the given join expression. The following performs * a full outer join between `df1` and `df2`. * * &#123;&#123;&#123; * // Scala: * import org.apache.spark.sql.functions._ * df1.join(df2, $\"df1Key\" === $\"df2Key\", \"outer\") * * // Java: * import static org.apache.spark.sql.functions.*; * df1.join(df2, col(\"df1Key\").equalTo(col(\"df2Key\")), \"outer\"); * &#125;&#125;&#125; * * @param right Right side of the join. * @param joinExprs Join expression. * @param joinType One of: `inner`, `outer`, `left_outer`, `right_outer`, `leftsemi`. * @group untypedrel * @since 2.0.0 */ def join(right: Dataset[_], joinExprs: Column, joinType: String): DataFrame = &#123; // Note that in this function, we introduce a hack in the case of self-join to automatically // resolve ambiguous join conditions into ones that might make sense [SPARK-6231]. // Consider this case: df.join(df, df(\"key\") === df(\"key\")) // Since df(\"key\") === df(\"key\") is a trivially true condition, this actually becomes a // cartesian join. However, most likely users expect to perform a self join using \"key\". // With that assumption, this hack turns the trivially true condition into equality on join // keys that are resolved to both sides. // Trigger analysis so in the case of self-join, the analyzer will clone the plan. // After the cloning, left and right side will have distinct expression ids. // 针对自连接的优化：正常情况下，自连接如果使用 df.join(df, df(\"key\") === df(\"key\")) // 会造成 笛卡尔积 // 这种情况下，分析器会 克隆计划，克隆完成后，左右两边则有不同的 id val plan = withPlan( Join(logicalPlan, right.logicalPlan, JoinType(joinType), Some(joinExprs.expr))) .queryExecution.analyzed.asInstanceOf[Join] // If auto self join alias is disabled, return the plan. if (!sparkSession.sessionState.conf.dataFrameSelfJoinAutoResolveAmbiguity) &#123; return withPlan(plan) &#125; // If left/right have no output set intersection, return the plan. val lanalyzed = withPlan(this.logicalPlan).queryExecution.analyzed val ranalyzed = withPlan(right.logicalPlan).queryExecution.analyzed if (lanalyzed.outputSet.intersect(ranalyzed.outputSet).isEmpty) &#123; return withPlan(plan) &#125; // Otherwise, find the trivially true predicates and automatically resolves them to both sides. // By the time we get here, since we have already run analysis, all attributes should've been // resolved and become AttributeReference. val cond = plan.condition.map &#123; _.transform &#123; case catalyst.expressions.EqualTo(a: AttributeReference, b: AttributeReference) if a.sameRef(b) =&gt; catalyst.expressions.EqualTo( withPlan(plan.left).resolve(a.name), withPlan(plan.right).resolve(b.name)) &#125; &#125; withPlan &#123; plan.copy(condition = cond) &#125; &#125; crossJoin12345678910111213/** * Explicit cartesian join with another `DataFrame`. * 显式笛卡尔积join * * @param right Right side of the join operation. * @note Cartesian joins are very expensive without an extra filter that can be pushed down. * 如果没有额外的过滤器，笛卡尔连接非常昂贵。 * @group untypedrel * @since 2.1.0 */def crossJoin(right: Dataset[_]): DataFrame = withPlan &#123; Join(logicalPlan, right.logicalPlan, joinType = Cross, None)&#125; apply123456789101112/** * Selects column based on the column name and return it as a [[Column]]. * * 选择基于列名的列，并将其作为[[Column]]返回。 * * @note The column name can also reference to a nested column like `a.b`. * * 列名也可以引用像“a.b”这样的嵌套列。 * @group untypedrel * @since 2.0.0 */def apply(colName: String): Column = col(colName) col123456789101112131415161718/** * Selects column based on the column name and return it as a [[Column]]. * * 选择基于列名的列，并将其作为[[Column]]返回。 * * @note The column name can also reference to a nested column like `a.b`. * * 列名也可以引用像“a.b”这样的嵌套列。 * @group untypedrel * @since 2.0.0 */def col(colName: String): Column = colName match &#123; case \"*\" =&gt; Column(ResolvedStar(queryExecution.analyzed.output)) case _ =&gt; val expr = resolve(colName) Column(expr)&#125; select12345678910111213141516171819202122232425262728293031/** * Selects a set of column based expressions. * &#123;&#123;&#123; * ds.select($\"colA\", $\"colB\" + 1) * &#125;&#125;&#125; * * @group untypedrel * @since 2.0.0 */@scala.annotation.varargsdef select(cols: Column*): DataFrame = withPlan &#123; Project(cols.map(_.named), logicalPlan)&#125;/** * Selects a set of columns. This is a variant of `select` that can only select * existing columns using column names (i.e. cannot construct expressions). * * 只能是已经存在的列名 * * &#123;&#123;&#123; * // The following two are equivalent: * ds.select(\"colA\", \"colB\") * ds.select($\"colA\", $\"colB\") * &#125;&#125;&#125; * * @group untypedrel * @since 2.0.0 */@scala.annotation.varargsdef select(col: String, cols: String*): DataFrame = select((col +: cols).map(Column(_)): _*) selectExpr12345678910111213141516171819202122/** * Selects a set of SQL expressions. This is a variant of `select` that accepts * SQL expressions. * * 接受SQL表达式 * * &#123;&#123;&#123; * // The following are equivalent: * 以下是等价的: * ds.selectExpr(\"colA\", \"colB as newName\", \"abs(colC)\") * ds.select(expr(\"colA\"), expr(\"colB as newName\"), expr(\"abs(colC)\")) * &#125;&#125;&#125; * * @group untypedrel * @since 2.0.0 */@scala.annotation.varargsdef selectExpr(exprs: String*): DataFrame = &#123; select(exprs.map &#123; expr =&gt; Column(sparkSession.sessionState.sqlParser.parseExpression(expr)) &#125;: _*)&#125; groupBy123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** * Groups the Dataset using the specified columns, so we can run aggregation on them. See * [[RelationalGroupedDataset]] for all the available aggregate functions. * * 使用指定的列对数据集进行分组，这样我们就可以对它们进行聚合。 * 查看[[RelationalGroupedDataset]]为所有可用的聚合函数。 * * * &#123;&#123;&#123; * // Compute the average for all numeric columns grouped by department. * * 计算按部门分组的所有数字列的平均值。 * * ds.groupBy($\"department\").avg() * * // Compute the max age and average salary, grouped by department and gender. * ds.groupBy($\"department\", $\"gender\").agg(Map( * \"salary\" -&gt; \"avg\", * \"age\" -&gt; \"max\" * )) * &#125;&#125;&#125; * * @group untypedrel * @since 2.0.0 */@scala.annotation.varargsdef groupBy(cols: Column*): RelationalGroupedDataset = &#123; RelationalGroupedDataset(toDF(), cols.map(_.expr), RelationalGroupedDataset.GroupByType)&#125; /** * Groups the Dataset using the specified columns, so that we can run aggregation on them. * See [[RelationalGroupedDataset]] for all the available aggregate functions. * * This is a variant of groupBy that can only group by existing columns using column names * (i.e. cannot construct expressions). * * &#123;&#123;&#123; * // Compute the average for all numeric columns grouped by department. * ds.groupBy(\"department\").avg() * * // Compute the max age and average salary, grouped by department and gender. * ds.groupBy($\"department\", $\"gender\").agg(Map( * \"salary\" -&gt; \"avg\", * \"age\" -&gt; \"max\" * )) * &#125;&#125;&#125; * * @group untypedrel * @since 2.0.0 */@scala.annotation.varargsdef groupBy(col1: String, cols: String*): RelationalGroupedDataset = &#123; val colNames: Seq[String] = col1 +: cols RelationalGroupedDataset( toDF(), colNames.map(colName =&gt; resolve(colName)), RelationalGroupedDataset.GroupByType)&#125; rollup1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/** * Create a multi-dimensional rollup for the current Dataset using the specified columns, * so we can run aggregation on them. * See [[RelationalGroupedDataset]] for all the available aggregate functions. * * 使用指定的列为当前数据集创建多维的汇总，因此我们可以在它们上运行聚合。 * * * &#123;&#123;&#123; * // Compute the average for all numeric columns rolluped by department and group. * * 汇总后 求平均值 * * ds.rollup($\"department\", $\"group\").avg() * * // Compute the max age and average salary, rolluped by department and gender. * ds.rollup($\"department\", $\"gender\").agg(Map( * \"salary\" -&gt; \"avg\", * \"age\" -&gt; \"max\" * )) * &#125;&#125;&#125; * * @group untypedrel * @since 2.0.0 */ @scala.annotation.varargs def rollup(cols: Column*): RelationalGroupedDataset = &#123; RelationalGroupedDataset(toDF(), cols.map(_.expr), RelationalGroupedDataset.RollupType) &#125; /** * Create a multi-dimensional rollup for the current Dataset using the specified columns, * so we can run aggregation on them. * See [[RelationalGroupedDataset]] for all the available aggregate functions. * * 使用指定的列为当前数据集创建多维的rollup，因此我们可以在它们上运行聚合。 * rollup可以实现 从右到左一次递减的多级统计，显示统计某一层次结构的聚合 * 例如 rollup(a,b,c,d) =结果=&gt; (a,b,c,d),(a,b,c),(a,b),a * * This is a variant of rollup that can only group by existing columns using column names * (i.e. cannot construct expressions). * * &#123;&#123;&#123; * // Compute the average for all numeric columns rolluped by department and group. * ds.rollup(\"department\", \"group\").avg() * * // Compute the max age and average salary, rolluped by department and gender. * ds.rollup($\"department\", $\"gender\").agg(Map( * \"salary\" -&gt; \"avg\", * \"age\" -&gt; \"max\" * )) * &#125;&#125;&#125; * * @group untypedrel * @since 2.0.0 */ @scala.annotation.varargs def rollup(col1: String, cols: String*): RelationalGroupedDataset = &#123; val colNames: Seq[String] = col1 +: cols RelationalGroupedDataset( toDF(), colNames.map(colName =&gt; resolve(colName)), RelationalGroupedDataset.RollupType) &#125; cube123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/** * Create a multi-dimensional cube for the current Dataset using the specified columns, * so we can run aggregation on them. * See [[RelationalGroupedDataset]] for all the available aggregate functions. * * 使用指定的列为当前数据集创建多维数据集，因此我们可以在它们上运行聚合。 * * * &#123;&#123;&#123; * // Compute the average for all numeric columns cubed by department and group. * ds.cube($\"department\", $\"group\").avg() * * // Compute the max age and average salary, cubed by department and gender. * ds.cube($\"department\", $\"gender\").agg(Map( * \"salary\" -&gt; \"avg\", * \"age\" -&gt; \"max\" * )) * &#125;&#125;&#125; * * @group untypedrel * @since 2.0.0 */ @scala.annotation.varargs def cube(cols: Column*): RelationalGroupedDataset = &#123; RelationalGroupedDataset(toDF(), cols.map(_.expr), RelationalGroupedDataset.CubeType) &#125; /** * Create a multi-dimensional cube for the current Dataset using the specified columns, * so we can run aggregation on them. * See [[RelationalGroupedDataset]] for all the available aggregate functions. * * 魔方 例如：cube(a,b,c) =结果=&gt; (a,b),(a,c),a,(b,c),b,c 结果为所有的维度 * 使用指定的列为当前数据集创建多维多维数据集，因此我们可以在它们上运行聚合。 * * This is a variant of cube that can only group by existing columns using column names * (i.e. cannot construct expressions). * * 这是一个多维数据集的变体，它只能通过使用列名的现有列来分组 * * &#123;&#123;&#123; * // Compute the average for all numeric columns cubed by department and group. * ds.cube(\"department\", \"group\").avg() * * // Compute the max age and average salary, cubed by department and gender. * ds.cube($\"department\", $\"gender\").agg(Map( * \"salary\" -&gt; \"avg\", * \"age\" -&gt; \"max\" * )) * &#125;&#125;&#125; * * @group untypedrel * @since 2.0.0 */ @scala.annotation.varargs def cube(col1: String, cols: String*): RelationalGroupedDataset = &#123; val colNames: Seq[String] = col1 +: cols RelationalGroupedDataset( toDF(), colNames.map(colName =&gt; resolve(colName)), RelationalGroupedDataset.CubeType) &#125; agg123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/** * (Scala-specific) Aggregates on the entire Dataset without groups. * 对整个数据集进行聚合，无需分组。 * &#123;&#123;&#123; * // ds.agg(...) is a shorthand for ds.groupBy().agg(...) * ds.agg(\"age\" -&gt; \"max\", \"salary\" -&gt; \"avg\") * ds.groupBy().agg(\"age\" -&gt; \"max\", \"salary\" -&gt; \"avg\") * &#125;&#125;&#125; * * @group untypedrel * @since 2.0.0 */ def agg(aggExpr: (String, String), aggExprs: (String, String)*): DataFrame = &#123; groupBy().agg(aggExpr, aggExprs: _*) &#125; /** * (Scala-specific) Aggregates on the entire Dataset without groups. * 对整个数据集进行聚合，无需分组。 * * &#123;&#123;&#123; * // ds.agg(...) is a shorthand for ds.groupBy().agg(...) * ds.agg(Map(\"age\" -&gt; \"max\", \"salary\" -&gt; \"avg\")) * ds.groupBy().agg(Map(\"age\" -&gt; \"max\", \"salary\" -&gt; \"avg\")) * &#125;&#125;&#125; * * @group untypedrel * @since 2.0.0 */ def agg(exprs: Map[String, String]): DataFrame = groupBy().agg(exprs) /** * (Java-specific) Aggregates on the entire Dataset without groups. * * 对整个数据集进行聚合，无需分组。 * * &#123;&#123;&#123; * // ds.agg(...) is a shorthand for ds.groupBy().agg(...) * ds.agg(Map(\"age\" -&gt; \"max\", \"salary\" -&gt; \"avg\")) * ds.groupBy().agg(Map(\"age\" -&gt; \"max\", \"salary\" -&gt; \"avg\")) * &#125;&#125;&#125; * * @group untypedrel * @since 2.0.0 */ def agg(exprs: java.util.Map[String, String]): DataFrame = groupBy().agg(exprs) /** * Aggregates on the entire Dataset without groups. * * 对整个数据集进行聚合，无需分组。 * * &#123;&#123;&#123; * // ds.agg(...) is a shorthand for ds.groupBy().agg(...) * ds.agg(max($\"age\"), avg($\"salary\")) * ds.groupBy().agg(max($\"age\"), avg($\"salary\")) * &#125;&#125;&#125; * * @group untypedrel * @since 2.0.0 */ @scala.annotation.varargs def agg(expr: Column, exprs: Column*): DataFrame = groupBy().agg(expr, exprs: _*) explode12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091/** * (Scala-specific) Returns a new Dataset where each row has been expanded to zero or more * rows by the provided function. This is similar to a `LATERAL VIEW` in HiveQL. The columns of * the input row are implicitly joined with each row that is output by the function. * * 根据提供的方法，该数据集的每一行都被扩展为零个或更多的行，返回一个新的数据集。 * 这类似于HiveQL的“LATERAL VIEW”。 * 输入行的列 隐式地加入了由函数输出的每一行。 * * Given that this is deprecated, as an alternative, you can explode columns either using * `functions.explode()` or `flatMap()`. The following example uses these alternatives to count * the number of books that contain a given word: * * 考虑到这已经被弃用，作为替代，您可以使用“functions.explode()”或“flatMap()”来引爆列。 * 下面的示例使用这些替代方法来计算包含给定单词的图书的数量: * * &#123;&#123;&#123; * case class Book(title: String, words: String) * val ds: Dataset[Book] * * val allWords = ds.select('title, explode(split('words, \" \")).as(\"word\")) * * val bookCountPerWord = allWords.groupBy(\"word\").agg(countDistinct(\"title\")) * &#125;&#125;&#125; * * Using `flatMap()` this can similarly be exploded as: * * &#123;&#123;&#123; * ds.flatMap(_.words.split(\" \")) * &#125;&#125;&#125; * * @group untypedrel * @since 2.0.0 已经过时，用 flatMap() 或 functions.explode() 代替 */@deprecated(\"use flatMap() or select() with functions.explode() instead\", \"2.0.0\")def explode[A &lt;: Product : TypeTag](input: Column*)(f: Row =&gt; TraversableOnce[A]): DataFrame = &#123; val elementSchema = ScalaReflection.schemaFor[A].dataType.asInstanceOf[StructType] val convert = CatalystTypeConverters.createToCatalystConverter(elementSchema) val rowFunction = f.andThen(_.map(convert(_).asInstanceOf[InternalRow])) val generator = UserDefinedGenerator(elementSchema, rowFunction, input.map(_.expr)) withPlan &#123; Generate(generator, join = true, outer = false, qualifier = None, generatorOutput = Nil, logicalPlan) &#125;&#125;/** * (Scala-specific) Returns a new Dataset where a single column has been expanded to zero * or more rows by the provided function. This is similar to a `LATERAL VIEW` in HiveQL. All * columns of the input row are implicitly joined with each value that is output by the function. * * Given that this is deprecated, as an alternative, you can explode columns either using * `functions.explode()`: * * &#123;&#123;&#123; * ds.select(explode(split('words, \" \")).as(\"word\")) * &#125;&#125;&#125; * * or `flatMap()`: * * &#123;&#123;&#123; * ds.flatMap(_.words.split(\" \")) * &#125;&#125;&#125; * * @group untypedrel * @since 2.0.0 */@deprecated(\"use flatMap() or select() with functions.explode() instead\", \"2.0.0\")def explode[A, B: TypeTag](inputColumn: String, outputColumn: String)(f: A =&gt; TraversableOnce[B]): DataFrame = &#123; val dataType = ScalaReflection.schemaFor[B].dataType val attributes = AttributeReference(outputColumn, dataType)() :: Nil // TODO handle the metadata? val elementSchema = attributes.toStructType def rowFunction(row: Row): TraversableOnce[InternalRow] = &#123; val convert = CatalystTypeConverters.createToCatalystConverter(dataType) f(row(0).asInstanceOf[A]).map(o =&gt; InternalRow(convert(o))) &#125; val generator = UserDefinedGenerator(elementSchema, rowFunction, apply(inputColumn).expr :: Nil) withPlan &#123; Generate(generator, join = true, outer = false, qualifier = None, generatorOutput = Nil, logicalPlan) &#125;&#125; withColumn1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * Returns a new Dataset by adding a column or replacing the existing column that has * the same name. * 通过添加一个列或替换具有相同名称的现有列返回新的数据集。 * * @group untypedrel * @since 2.0.0 */def withColumn(colName: String, col: Column): DataFrame = &#123; val resolver = sparkSession.sessionState.analyzer.resolver val output = queryExecution.analyzed.output val shouldReplace = output.exists(f =&gt; resolver(f.name, colName)) if (shouldReplace) &#123; val columns = output.map &#123; field =&gt; if (resolver(field.name, colName)) &#123; col.as(colName) &#125; else &#123; Column(field) &#125; &#125; select(columns: _*) &#125; else &#123; select(Column(\"*\"), col.as(colName)) &#125;&#125;/** * Returns a new Dataset by adding a column with metadata. * 通过添加带有元数据的列返回一个新的数据集。 */private[spark] def withColumn(colName: String, col: Column, metadata: Metadata): DataFrame = &#123; val resolver = sparkSession.sessionState.analyzer.resolver val output = queryExecution.analyzed.output val shouldReplace = output.exists(f =&gt; resolver(f.name, colName)) if (shouldReplace) &#123; val columns = output.map &#123; field =&gt; if (resolver(field.name, colName)) &#123; col.as(colName, metadata) &#125; else &#123; Column(field) &#125; &#125; select(columns: _*) &#125; else &#123; select(Column(\"*\"), col.as(colName, metadata)) &#125;&#125; withColumnRenamed1234567891011121314151617181920212223242526/** * Returns a new Dataset with a column renamed. * This is a no-op if schema doesn't contain existingName. * 返回一个重命名的列的新数据集。 * 如果模式不包含存在名称，那么这是不操作的。 * * @group untypedrel * @since 2.0.0 */def withColumnRenamed(existingName: String, newName: String): DataFrame = &#123; val resolver = sparkSession.sessionState.analyzer.resolver val output = queryExecution.analyzed.output val shouldRename = output.exists(f =&gt; resolver(f.name, existingName)) if (shouldRename) &#123; val columns = output.map &#123; col =&gt; if (resolver(col.name, existingName)) &#123; Column(col).as(newName) &#125; else &#123; Column(col) &#125; &#125; select(columns: _*) &#125; else &#123; toDF() &#125;&#125; drop1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/** * Returns a new Dataset with a column dropped. This is a no-op if schema doesn't contain * column name. * * 返回删除指定列之后的新Dataset * * This method can only be used to drop top level columns. the colName string is treated * literally without further interpretation. * * 仅用于删除顶层的列 * * @group untypedrel * @since 2.0.0 */def drop(colName: String): DataFrame = &#123; drop(Seq(colName): _*)&#125;/** * Returns a new Dataset with columns dropped. * This is a no-op if schema doesn't contain column name(s). * * 删除指定的多个列，并返回新的dataset * * This method can only be used to drop top level columns. the colName string is treated literally * without further interpretation. * * @group untypedrel * @since 2.0.0 */@scala.annotation.varargsdef drop(colNames: String*): DataFrame = &#123; val resolver = sparkSession.sessionState.analyzer.resolver val allColumns = queryExecution.analyzed.output val remainingCols = allColumns.filter &#123; attribute =&gt; colNames.forall(n =&gt; !resolver(attribute.name, n)) &#125;.map(attribute =&gt; Column(attribute)) if (remainingCols.size == allColumns.size) &#123; toDF() &#125; else &#123; this.select(remainingCols: _*) &#125;&#125;/** * Returns a new Dataset with a column dropped. * This version of drop accepts a [[Column]] rather than a name. * This is a no-op if the Dataset doesn't have a column * with an equivalent expression. * * 删除指定的 列（根据Column） * * @group untypedrel * @since 2.0.0 */def drop(col: Column): DataFrame = &#123; val expression = col match &#123; case Column(u: UnresolvedAttribute) =&gt; queryExecution.analyzed.resolveQuoted( u.name, sparkSession.sessionState.analyzer.resolver).getOrElse(u) case Column(expr: Expression) =&gt; expr &#125; val attrs = this.logicalPlan.output val colsAfterDrop = attrs.filter &#123; attr =&gt; attr != expression &#125;.map(attr =&gt; Column(attr)) select(colsAfterDrop: _*)&#125; typedrel-有类型的转换joinWith123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108/** * :: Experimental :: 实验的 * Joins this Dataset returning a `Tuple2` for each pair where `condition` evaluates to * true. * 连接这个数据集返回一个“Tuple2”对每一对的“条件”计算为true。 * * This is similar to the relation `join` function with one important difference in the * result schema. Since `joinWith` preserves objects present on either side of the join, the * result schema is similarly nested into a tuple under the column names `_1` and `_2`. * 这类似于关系“join”函数，在结果模式中有一个重要的区别。 * 由于“joinWith”保存了连接的任何一边的对象，因此结果模式类似地嵌套在列名称“_1”和“_2”下面的tuple中。 * * This type of join can be useful both for preserving type-safety with the original object * types as well as working with relational data where either side of the join has column * names in common. * 这种类型的联接既可以用于保存与原始对象类型的类型安全性， * 也可以用于处理连接的任何一端都有列名的关系数据。 * * @param other Right side of the join. * @param condition Join expression. * @param joinType One of: `inner`, `outer`, `left_outer`, `right_outer`, `leftsemi`. * @group typedrel * @since 1.6.0 */@Experimental@InterfaceStability.Evolvingdef joinWith[U](other: Dataset[U], condition: Column, joinType: String): Dataset[(T, U)] = &#123; // Creates a Join node and resolve it first, to get join condition resolved, self-join resolved, // 创建一个联接节点并首先解析它，使Join条件得到解析，self - Join解析， // etc. val joined = sparkSession.sessionState.executePlan( Join( this.logicalPlan, other.logicalPlan, JoinType(joinType), Some(condition.expr))).analyzed.asInstanceOf[Join] // For both join side, combine all outputs into a single column and alias it with \"_1\" or \"_2\", // to match the schema for the encoder of the join result. // 对于这两个连接，将所有输出合并为一个列，并将其别名为“_1”或“_2”，以匹配连接结果的编码器的模式。 // Note that we do this before joining them, to enable the join operator to return null for one // side, in cases like outer-join. // 请注意，在join它们之前，我们这样做，使join操作符在像outer - join这样的情况下返回null。 val left = &#123; val combined = if (this.exprEnc.flat) &#123; assert(joined.left.output.length == 1) Alias(joined.left.output.head, \"_1\")() &#125; else &#123; Alias(CreateStruct(joined.left.output), \"_1\")() &#125; Project(combined :: Nil, joined.left) &#125; val right = &#123; val combined = if (other.exprEnc.flat) &#123; assert(joined.right.output.length == 1) Alias(joined.right.output.head, \"_2\")() &#125; else &#123; Alias(CreateStruct(joined.right.output), \"_2\")() &#125; Project(combined :: Nil, joined.right) &#125; // Rewrites the join condition to make the attribute point to correct column/field, after we // combine the outputs of each join side. // 在将每个连接的输出组合在一起之后,重写联接条件，使属性指向正确的列/字段。 val conditionExpr = joined.condition.get transformUp &#123; case a: Attribute if joined.left.outputSet.contains(a) =&gt; if (this.exprEnc.flat) &#123; left.output.head &#125; else &#123; val index = joined.left.output.indexWhere(_.exprId == a.exprId) GetStructField(left.output.head, index) &#125; case a: Attribute if joined.right.outputSet.contains(a) =&gt; if (other.exprEnc.flat) &#123; right.output.head &#125; else &#123; val index = joined.right.output.indexWhere(_.exprId == a.exprId) GetStructField(right.output.head, index) &#125; &#125; implicit val tuple2Encoder: Encoder[(T, U)] = ExpressionEncoder.tuple(this.exprEnc, other.exprEnc) withTypedPlan(Join(left, right, joined.joinType, Some(conditionExpr)))&#125;/** * :: Experimental :: * Using inner equi-join to join this Dataset returning a `Tuple2` for each pair * where `condition` evaluates to true. * * 使用内部的等连接加入这个数据集，为每一对返回一个“Tuple2”，其中“条件”的计算结果为true。 * * @param other Right side of the join. * @param condition Join expression. * @group typedrel * @since 1.6.0 */@Experimental@InterfaceStability.Evolvingdef joinWith[U](other: Dataset[U], condition: Column): Dataset[(T, U)] = &#123; joinWith(other, condition, \"inner\")&#125; sortWithinPartitions123456789101112131415161718192021222324252627282930313233/** * Returns a new Dataset with each partition sorted by the given expressions. * * 返回一个新的数据集，每个分区按照给定的表达式排序。 * * This is the same operation as \"SORT BY\" in SQL (Hive QL). * * 这与SQL(Hive QL)中“SORT BY”的操作相同。 * * @group typedrel * @since 2.0.0 */@scala.annotation.varargsdef sortWithinPartitions(sortCol: String, sortCols: String*): Dataset[T] = &#123; sortWithinPartitions((sortCol +: sortCols).map(Column(_)): _*)&#125;/** * Returns a new Dataset with each partition sorted by the given expressions. * * 返回一个新的数据集，每个分区按照给定的表达式排序。 * * This is the same operation as \"SORT BY\" in SQL (Hive QL). * * 这与SQL(Hive QL)中“SORT BY”的操作相同。 * * @group typedrel * @since 2.0.0 */@scala.annotation.varargsdef sortWithinPartitions(sortExprs: Column*): Dataset[T] = &#123; sortInternal(global = false, sortExprs)&#125; sort1234567891011121314151617181920212223242526272829303132333435/** * Returns a new Dataset sorted by the specified column, all in ascending order. * 排序 升序 * &#123;&#123;&#123; * // The following 3 are equivalent * 下面3个是等价的 * ds.sort(\"sortcol\") * ds.sort($\"sortcol\") * ds.sort($\"sortcol\".asc) * &#125;&#125;&#125; * * @group typedrel * @since 2.0.0 */ @scala.annotation.varargs def sort(sortCol: String, sortCols: String*): Dataset[T] = &#123; sort((sortCol +: sortCols).map(apply): _*) &#125; /** * Returns a new Dataset sorted by the given expressions. For example: * * 返回一个由给定表达式排序的新数据集。例如: * * &#123;&#123;&#123; * ds.sort($\"col1\", $\"col2\".desc) * &#125;&#125;&#125; * * @group typedrel * @since 2.0.0 */ @scala.annotation.varargs def sort(sortExprs: Column*): Dataset[T] = &#123; sortInternal(global = true, sortExprs) &#125; orderBy123456789101112131415161718192021/** * Returns a new Dataset sorted by the given expressions. * This is an alias of the `sort` function. * 这是“sort”函数的别名。 * * @group typedrel * @since 2.0.0 */ @scala.annotation.varargs def orderBy(sortCol: String, sortCols: String*): Dataset[T] = sort(sortCol, sortCols: _*) /** * Returns a new Dataset sorted by the given expressions. * This is an alias of the `sort` function. * 这是“sort”函数的别名。 * * @group typedrel * @since 2.0.0 */ @scala.annotation.varargs def orderBy(sortExprs: Column*): Dataset[T] = sort(sortExprs: _*) as12345678910111213141516171819/** * Returns a new Dataset with an alias set. * * 返回一个具有别名集的新数据集。 * * @group typedrel * @since 1.6.0 */ def as(alias: String): Dataset[T] = withTypedPlan &#123; SubqueryAlias(alias, logicalPlan, None) &#125; /** * (Scala-specific) Returns a new Dataset with an alias set. * * @group typedrel * @since 2.0.0 */ def as(alias: Symbol): Dataset[T] = as(alias.name) alias12345678910111213141516/** * Returns a new Dataset with an alias set. Same as `as`. * 返回一个具有别名集的新数据集。与“as”相同。 * * @group typedrel * @since 2.0.0 */ def alias(alias: String): Dataset[T] = as(alias) /** * (Scala-specific) Returns a new Dataset with an alias set. Same as `as`. * * @group typedrel * @since 2.0.0 */ def alias(alias: Symbol): Dataset[T] = as(alias) select1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889/** * :: Experimental :: * Returns a new Dataset by computing the given [[Column]] expression for each element. * * 通过计算每个元素的给定[[列]]表达式返回一个新的数据集。 * * &#123;&#123;&#123; * val ds = Seq(1, 2, 3).toDS() * val newDS = ds.select(expr(\"value + 1\").as[Int]) * &#125;&#125;&#125; * * @group typedrel * @since 1.6.0 */ @Experimental @InterfaceStability.Evolving def select[U1](c1: TypedColumn[T, U1]): Dataset[U1] = &#123; implicit val encoder = c1.encoder val project = Project(c1.withInputType(exprEnc, logicalPlan.output).named :: Nil, logicalPlan) if (encoder.flat) &#123; new Dataset[U1](sparkSession, project, encoder) &#125; else &#123; // Flattens inner fields of U1 // 使U1的内部区域变平 new Dataset[Tuple1[U1]](sparkSession, project, ExpressionEncoder.tuple(encoder)).map(_._1) &#125; &#125; /** * :: Experimental :: * Returns a new Dataset by computing the given [[Column]] expressions for each element. * * @group typedrel * @since 1.6.0 */ @Experimental @InterfaceStability.Evolving def select[U1, U2](c1: TypedColumn[T, U1], c2: TypedColumn[T, U2]): Dataset[(U1, U2)] = selectUntyped(c1, c2).asInstanceOf[Dataset[(U1, U2)]] /** * :: Experimental :: * Returns a new Dataset by computing the given [[Column]] expressions for each element. * * @group typedrel * @since 1.6.0 */ @Experimental @InterfaceStability.Evolving def select[U1, U2, U3]( c1: TypedColumn[T, U1], c2: TypedColumn[T, U2], c3: TypedColumn[T, U3]): Dataset[(U1, U2, U3)] = selectUntyped(c1, c2, c3).asInstanceOf[Dataset[(U1, U2, U3)]] /** * :: Experimental :: * Returns a new Dataset by computing the given [[Column]] expressions for each element. * * @group typedrel * @since 1.6.0 */ @Experimental @InterfaceStability.Evolving def select[U1, U2, U3, U4]( c1: TypedColumn[T, U1], c2: TypedColumn[T, U2], c3: TypedColumn[T, U3], c4: TypedColumn[T, U4]): Dataset[(U1, U2, U3, U4)] = selectUntyped(c1, c2, c3, c4).asInstanceOf[Dataset[(U1, U2, U3, U4)]] /** * :: Experimental :: * Returns a new Dataset by computing the given [[Column]] expressions for each element. * * @group typedrel * @since 1.6.0 */ @Experimental @InterfaceStability.Evolving def select[U1, U2, U3, U4, U5]( c1: TypedColumn[T, U1], c2: TypedColumn[T, U2], c3: TypedColumn[T, U3], c4: TypedColumn[T, U4], c5: TypedColumn[T, U5]): Dataset[(U1, U2, U3, U4, U5)] = selectUntyped(c1, c2, c3, c4, c5).asInstanceOf[Dataset[(U1, U2, U3, U4, U5)]] filter12345678910111213141516171819202122232425262728293031323334/** * Filters rows using the given condition. * * 用给定的条件过滤rows * * &#123;&#123;&#123; * // The following are equivalent: * 以下是等价的： * peopleDs.filter($\"age\" &gt; 15) * peopleDs.where($\"age\" &gt; 15) * &#125;&#125;&#125; * * @group typedrel * @since 1.6.0 */ def filter(condition: Column): Dataset[T] = withTypedPlan &#123; Filter(condition.expr, logicalPlan) &#125; /** * Filters rows using the given SQL expression. * * 用给定的 SQL 表达式 过滤rows * * &#123;&#123;&#123; * peopleDs.filter(\"age &gt; 15\") * &#125;&#125;&#125; * * @group typedrel * @since 1.6.0 */ def filter(conditionExpr: String): Dataset[T] = &#123; filter(Column(sparkSession.sessionState.sqlParser.parseExpression(conditionExpr))) &#125; where1234567891011121314151617181920212223242526272829303132/** * Filters rows using the given condition. This is an alias for `filter`. * * 使用给定条件过滤行。 * 这是“filter”的别名。 * * &#123;&#123;&#123; * // The following are equivalent: * peopleDs.filter($\"age\" &gt; 15) * peopleDs.where($\"age\" &gt; 15) * &#125;&#125;&#125; * * @group typedrel * @since 1.6.0 */ def where(condition: Column): Dataset[T] = filter(condition) /** * Filters rows using the given SQL expression. * * 使用给定的 SQL 表达式 过滤 rows * * &#123;&#123;&#123; * peopleDs.where(\"age &gt; 15\") * &#125;&#125;&#125; * * @group typedrel * @since 1.6.0 */ def where(conditionExpr: String): Dataset[T] = &#123; filter(Column(sparkSession.sessionState.sqlParser.parseExpression(conditionExpr))) &#125; groupByKey12345678910111213141516171819202122232425262728293031323334353637/** * :: Experimental :: * (Scala-specific) * Returns a [[KeyValueGroupedDataset]] where the data is grouped by the given key `func`. * 返回一个[[KeyValueGroupedDataset]]，数据由给定键' func '分组。 * * @group typedrel * @since 2.0.0 */@Experimental@InterfaceStability.Evolvingdef groupByKey[K: Encoder](func: T =&gt; K): KeyValueGroupedDataset[K, T] = &#123; val inputPlan = logicalPlan val withGroupingKey = AppendColumns(func, inputPlan) val executed = sparkSession.sessionState.executePlan(withGroupingKey) new KeyValueGroupedDataset( encoderFor[K], encoderFor[T], executed, inputPlan.output, withGroupingKey.newColumns)&#125;/** * :: Experimental :: * (Java-specific) * Returns a [[KeyValueGroupedDataset]] where the data is grouped by the given key `func`. * 返回一个[[KeyValueGroupedDataset]]，数据由给定键' func '分组。 * * @group typedrel * @since 2.0.0 */@Experimental@InterfaceStability.Evolvingdef groupByKey[K](func: MapFunction[T, K], encoder: Encoder[K]): KeyValueGroupedDataset[K, T] = groupByKey(func.call(_))(encoder) limit123456789101112131415/** * Returns a new Dataset by taking the first `n` rows. The difference between this function * and `head` is that `head` is an action and returns an array (by triggering query execution) * while `limit` returns a new Dataset. * * 通过使用第一个“n”行返回一个新的数据集。 * 这个函数和“head”的区别在于“head”是一个动作， * 并返回一个数组(通过触发查询执行)，而“limit”则返回一个新的数据集。 * * @group typedrel * @since 2.0.0 */def limit(n: Int): Dataset[T] = withTypedPlan &#123; Limit(Literal(n), logicalPlan)&#125; unionAll-已过时1234567891011121314151617/** * Returns a new Dataset containing union of rows in this Dataset and another Dataset. * This is equivalent to `UNION ALL` in SQL. * * 返回一个新的数据集，该数据集包含该数据集中的行和另一个数据集。 * 这相当于SQL中的“UNION ALL”。 * * To do a SQL-style set union (that does deduplication of elements), use this function followed * by a [[distinct]]. * * 如果需要去重的话，在该方法后继续直接 [[distinct]] * * @group typedrel * @since 2.0.0 已经过时 */@deprecated(\"use union()\", \"2.0.0\")def unionAll(other: Dataset[T]): Dataset[T] = union(other) union123456789101112131415161718192021/** * Returns a new Dataset containing union of rows in this Dataset and another Dataset. * This is equivalent to `UNION ALL` in SQL. * * 返回一个新的数据集，该数据集包含该数据集中的行和另一个数据集。 * 这相当于SQL中的“UNION ALL”。 * * To do a SQL-style set union (that does deduplication of elements), use this function followed * by a [[distinct]]. * * 如果需要去重的话，在该方法后继续直接 [[distinct]] * * @group typedrel * @since 2.0.0 */def union(other: Dataset[T]): Dataset[T] = withSetOperator &#123; // This breaks caching, but it's usually ok because it addresses a very specific use case: // using union to union many files or partitions. // 这打破了缓存，但通常是可以的，因为它解决了一个非常具体的用例:使用union来联合许多文件或分区。 CombineUnions(Union(logicalPlan, other.logicalPlan))&#125; intersect-交集123456789101112131415161718/** * Returns a new Dataset containing rows only in both this Dataset and another Dataset. * This is equivalent to `INTERSECT` in SQL. * * 返回一个新的数据集，只包含该数据集和另一个数据集相同的行. * 这相当于在SQL中“INTERSECT”。 * 会去重. * * @note Equality checking is performed directly on the encoded representation of the data * and thus is not affected by a custom `equals` function defined on `T`. * * 等式检查直接执行数据的编码表示，因此不受定义为“T”的自定义“equals”函数的影响。 * @group typedrel * @since 1.6.0 */def intersect(other: Dataset[T]): Dataset[T] = withSetOperator &#123; Intersect(logicalPlan, other.logicalPlan)&#125; except-只显示另个Dataset中没有的值12345678910111213141516/** * Returns a new Dataset containing rows in this Dataset but not in another Dataset. * This is equivalent to `EXCEPT` in SQL. * * 返回一个新的数据集，该数据集包含该数据集中的行，而不是在另一个数据集。 * 这等价于SQL中的“EXCEPT”。 * 会去重. * * @note Equality checking is performed directly on the encoded representation of the data * and thus is not affected by a custom `equals` function defined on `T`. * @group typedrel * @since 2.0.0 */def except(other: Dataset[T]): Dataset[T] = withSetOperator &#123; Except(logicalPlan, other.logicalPlan)&#125; sample-随机抽样1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * Returns a new [[Dataset]] by sampling a fraction of rows, using a user-supplied seed. * * 通过使用用户提供的种子，通过抽样的方式返回一个新的[[Dataset]]。 * * @param withReplacement Sample with replacement or not. * 样本已经取过的值是否放回 * @param fraction Fraction of rows to generate. * 每一行数据被取样的概率 * @param seed Seed for sampling. * 取样种子（与随机数生成有关） * @note This is NOT guaranteed to provide exactly the fraction of the count * of the given [[Dataset]]. * 不能保证准确的按照给定的分数取样。（一般结果会在概率值*总数左右） * @group typedrel * @since 1.6.0 */def sample(withReplacement: Boolean, fraction: Double, seed: Long): Dataset[T] = &#123; require(fraction &gt;= 0, s\"Fraction must be nonnegative, but got $&#123;fraction&#125;\") withTypedPlan &#123; Sample(0.0, fraction, withReplacement, seed, logicalPlan)() &#125;&#125;/** * Returns a new [[Dataset]] by sampling a fraction of rows, using a random seed. * * 通过程序随机的种子，抽样返回新的DataSet * * @param withReplacement Sample with replacement or not. * 取样结果是否放回 * @param fraction Fraction of rows to generate. * 每行数据被取样的概率 * @note This is NOT guaranteed to provide exactly the fraction of the total count * of the given [[Dataset]]. * 不能保证准确的按照给定的分数取样。（一般结果会在概率值*总数左右） * @group typedrel * @since 1.6.0 */def sample(withReplacement: Boolean, fraction: Double): Dataset[T] = &#123; sample(withReplacement, fraction, Utils.random.nextLong)&#125; randomSplit-按照权重分割1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/** * Randomly splits this Dataset with the provided weights. * * 随机将此数据集按照所提供的权重进行分割。 * * @param weights weights for splits, will be normalized if they don't sum to 1. * 切分的权重。如果和不为1就会被标准化。 * @param seed Seed for sampling. * 取样的种子（影响随机数生成器） * * For Java API, use [[randomSplitAsList]]. * Java API 使用 [[randomSplitAsList]]. * @group typedrel * @since 2.0.0 */ def randomSplit(weights: Array[Double], seed: Long): Array[Dataset[T]] = &#123; require(weights.forall(_ &gt;= 0), s\"Weights must be nonnegative, but got $&#123;weights.mkString(\"[\", \",\", \"]\")&#125;\") require(weights.sum &gt; 0, s\"Sum of weights must be positive, but got $&#123;weights.mkString(\"[\", \",\", \"]\")&#125;\") // It is possible that the underlying dataframe doesn't guarantee the ordering of rows in its // constituent partitions each time a split is materialized which could result in // overlapping splits. To prevent this, we explicitly sort each input partition to make the // ordering deterministic. // MapType cannot be sorted. val sorted = Sort(logicalPlan.output.filterNot(_.dataType.isInstanceOf[MapType]) .map(SortOrder(_, Ascending)), global = false, logicalPlan) val sum = weights.sum // scanLeft 从右到右依次累计算 scanLeft(0.0d)(_+_): (0.0,(0.0+0.2),(0.0+0.2+0.8)) val normalizedCumWeights = weights.map(_ / sum).scanLeft(0.0d)(_ + _) // sliding(n) 每次取n个值，以步长为1向右滑动，如：(0.0,0.2,0.8).sliding(2)=(0.0,0.2),(0.2,0.8) normalizedCumWeights.sliding(2).map &#123; x =&gt; new Dataset[T]( sparkSession, Sample(x(0), x(1), withReplacement = false, seed, sorted)(), encoder) &#125;.toArray &#125; /** * Randomly splits this Dataset with the provided weights. * * 程序自动生成随机数种子，随机将此数据集按照所提供的权重进行分割。 * * @param weights weights for splits, will be normalized if they don't sum to 1. * 切分的权重。如果和不为1就会被标准化。 * @group typedrel * @since 2.0.0 */ def randomSplit(weights: Array[Double]): Array[Dataset[T]] = &#123; randomSplit(weights, Utils.random.nextLong) &#125; /** * Randomly splits this Dataset with the provided weights. Provided for the Python Api. * Python 使用该方法 * * @param weights weights for splits, will be normalized if they don't sum to 1. * @param seed Seed for sampling. */ private[spark] def randomSplit(weights: List[Double], seed: Long): Array[Dataset[T]] = &#123; randomSplit(weights.toArray, seed) &#125; randomSplitAsList12345678910111213141516/** * Returns a Java list that contains randomly split Dataset with the provided weights. * * 根据提供的权重分割DataFrames，返回Java list * * @param weights weights for splits, will be normalized if they don't sum to 1. * 切分的权重。如果和不为1就会被标准化。 * @param seed Seed for sampling. * 取样的种子（影响随机数生成器） * @group typedrel * @since 2.0.0 */def randomSplitAsList(weights: Array[Double], seed: Long): java.util.List[Dataset[T]] = &#123; val values = randomSplit(weights, seed) java.util.Arrays.asList(values: _*)&#125; dropDuplicates-去重123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475/** * Returns a new Dataset that contains only the unique rows from this Dataset. * This is an alias for `distinct`. * * 删除重复的row数据，是distinct的别名 * * @group typedrel * @since 2.0.0 */def dropDuplicates(): Dataset[T] = dropDuplicates(this.columns)/** * (Scala-specific) Returns a new Dataset with duplicate rows removed, considering only * the subset of columns. * * 只删除指定列的重复数据 * * @group typedrel * @since 2.0.0 */def dropDuplicates(colNames: Seq[String]): Dataset[T] = withTypedPlan &#123; val resolver = sparkSession.sessionState.analyzer.resolver val allColumns = queryExecution.analyzed.output val groupCols = colNames.flatMap &#123; colName =&gt; // It is possibly there are more than one columns with the same name, // so we call filter instead of find. val cols = allColumns.filter(col =&gt; resolver(col.name, colName)) if (cols.isEmpty) &#123; throw new AnalysisException( s\"\"\"Cannot resolve column name \"$colName\" among ($&#123;schema.fieldNames.mkString(\", \")&#125;)\"\"\") &#125; cols &#125; val groupColExprIds = groupCols.map(_.exprId) val aggCols = logicalPlan.output.map &#123; attr =&gt; if (groupColExprIds.contains(attr.exprId)) &#123; attr &#125; else &#123; // Removing duplicate rows should not change output attributes. We should keep // the original exprId of the attribute. Otherwise, to select a column in original // dataset will cause analysis exception due to unresolved attribute. // 删除重复行不应该更改输出属性。 // 我们应该保留这个属性的原始属性。 // 否则，在原始数据集中选择一个列将导致分析异常，原因是未解析的属性。 Alias(new First(attr).toAggregateExpression(), attr.name)(exprId = attr.exprId) &#125; &#125; Aggregate(groupCols, aggCols, logicalPlan)&#125;/** * Returns a new Dataset with duplicate rows removed, considering only * the subset of columns. * * 只针对特定列做去重 * * @group typedrel * @since 2.0.0 */def dropDuplicates(colNames: Array[String]): Dataset[T] = dropDuplicates(colNames.toSeq)/** * Returns a new [[Dataset]] with duplicate rows removed, considering only * the subset of columns. * * 只针对特定多列做去重 * * @group typedrel * @since 2.0.0 */@scala.annotation.varargsdef dropDuplicates(col1: String, cols: String*): Dataset[T] = &#123; val colNames: Seq[String] = col1 +: cols dropDuplicates(colNames)&#125; transform-自定义转换1234567891011121314151617/** * Concise syntax for chaining custom transformations. * * 用于链接自定义转换的简明语法。 * * &#123;&#123;&#123; * def featurize(ds: Dataset[T]): Dataset[U] = ... * * ds * .transform(featurize) * .transform(...) * &#125;&#125;&#125; * * @group typedrel * @since 1.6.0 */def transform[U](t: Dataset[T] =&gt; Dataset[U]): Dataset[U] = t(this) filter-过滤12345678910111213141516171819202122232425262728293031/** * :: Experimental :: * (Scala-specific) * Returns a new Dataset that only contains elements where `func` returns `true`. * * 该数据集只包含“func”返回“true”的元素。 * * @group typedrel * @since 1.6.0 */ @Experimental @InterfaceStability.Evolving def filter(func: T =&gt; Boolean): Dataset[T] = &#123; withTypedPlan(TypedFilter(func, logicalPlan)) &#125; /** * :: Experimental :: * (Java-specific) * Returns a new Dataset that only contains elements where `func` returns `true`. * * 返回一个新数据集，该数据集只包含“func”返回“true”的元素。 * * @group typedrel * @since 1.6.0 */ @Experimental @InterfaceStability.Evolving def filter(func: FilterFunction[T]): Dataset[T] = &#123; withTypedPlan(TypedFilter(func, logicalPlan)) &#125; map1234567891011121314151617181920212223242526272829303132/** * :: Experimental :: * (Scala-specific) * Returns a new Dataset that contains the result of applying `func` to each element. * * 返回一个新的数据集，该数据集包含对每个元素应用“func”的结果。 * * @group typedrel * @since 1.6.0 */@Experimental@InterfaceStability.Evolvingdef map[U: Encoder](func: T =&gt; U): Dataset[U] = withTypedPlan &#123; MapElements[T, U](func, logicalPlan)&#125;/** * :: Experimental :: * (Java-specific) * Returns a new Dataset that contains the result of applying `func` to each element. * * 返回一个新的数据集，该数据集包含对每个元素应用“func”的结果。 * * @group typedrel * @since 1.6.0 */@Experimental@InterfaceStability.Evolvingdef map[U](func: MapFunction[T, U], encoder: Encoder[U]): Dataset[U] = &#123; implicit val uEnc = encoder withTypedPlan(MapElements[T, U](func, logicalPlan))&#125; mapPartitions1234567891011121314151617181920212223242526272829303132333435/** * :: Experimental :: * (Scala-specific) * Returns a new Dataset that contains the result of applying `func` to each partition. * * 返回一个新的数据集，该数据集包含对每个分区应用“func”的结果。 * * @group typedrel * @since 1.6.0 */@Experimental@InterfaceStability.Evolvingdef mapPartitions[U: Encoder](func: Iterator[T] =&gt; Iterator[U]): Dataset[U] = &#123; new Dataset[U]( sparkSession, MapPartitions[T, U](func, logicalPlan), implicitly[Encoder[U]])&#125;/** * :: Experimental :: * (Java-specific) * Returns a new Dataset that contains the result of applying `f` to each partition. * * 返回一个新的数据集，该数据集包含对每个分区应用“f”的结果。 * * @group typedrel * @since 1.6.0 */@Experimental@InterfaceStability.Evolvingdef mapPartitions[U](f: MapPartitionsFunction[T, U], encoder: Encoder[U]): Dataset[U] = &#123; val func: (Iterator[T]) =&gt; Iterator[U] = x =&gt; f.call(x.asJava).asScala mapPartitions(func)(encoder)&#125; flatMap-将map结果flat扁平化123456789101112131415161718192021222324252627282930313233/** * :: Experimental :: * (Scala-specific) * Returns a new Dataset by first applying a function to all elements of this Dataset, * and then flattening the results. * * 返回一个新的数据集，首先对该数据集的所有元素应用一个函数，然后将结果扁平化。 * * @group typedrel * @since 1.6.0 */@Experimental@InterfaceStability.Evolvingdef flatMap[U: Encoder](func: T =&gt; TraversableOnce[U]): Dataset[U] = mapPartitions(_.flatMap(func))/** * :: Experimental :: * (Java-specific) * Returns a new Dataset by first applying a function to all elements of this Dataset, * and then flattening the results. * * 返回一个新的数据集，首先对该数据集的所有元素应用一个函数，然后将结果扁平化。 * * @group typedrel * @since 1.6.0 */@Experimental@InterfaceStability.Evolvingdef flatMap[U](f: FlatMapFunction[T, U], encoder: Encoder[U]): Dataset[U] = &#123; val func: (T) =&gt; Iterator[U] = x =&gt; f.call(x).asScala flatMap(func)(encoder)&#125; repartition-重分区123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * Returns a new Dataset that has exactly `numPartitions` partitions. * * 返回一个 给定分区数量的新DataSet * * @group typedrel * @since 1.6.0 */ def repartition(numPartitions: Int): Dataset[T] = withTypedPlan &#123; Repartition(numPartitions, shuffle = true, logicalPlan) &#125; /** * Returns a new Dataset partitioned by the given partitioning expressions into * `numPartitions`. The resulting Dataset is hash partitioned. * * 返回一个由给定的分区表达式划分为“num分区”的新数据集。 * 生成的Dataset是哈希分区的。 * * This is the same operation as \"DISTRIBUTE BY\" in SQL (Hive QL). * * 和 SQL (Hive QL) 中的 \"DISTRIBUTE BY\" 作用相同 * * @group typedrel * @since 2.0.0 */ @scala.annotation.varargs def repartition(numPartitions: Int, partitionExprs: Column*): Dataset[T] = withTypedPlan &#123; RepartitionByExpression(partitionExprs.map(_.expr), logicalPlan, Some(numPartitions)) &#125; /** * Returns a new Dataset partitioned by the given partitioning expressions, using * `spark.sql.shuffle.partitions` as number of partitions. * The resulting Dataset is hash partitioned. * * 根据指定的分区表达式进行重分区。 * 分区数量由`spark.sql.shuffle.partitions` 获得。 * 结果Dataset 是哈希分区的。 * * This is the same operation as \"DISTRIBUTE BY\" in SQL (Hive QL). * * 和 SQL (Hive QL) 中的 \"DISTRIBUTE BY\" 作用相同 * * @group typedrel * @since 2.0.0 */ @scala.annotation.varargs def repartition(partitionExprs: Column*): Dataset[T] = withTypedPlan &#123; RepartitionByExpression(partitionExprs.map(_.expr), logicalPlan, numPartitions = None) &#125; coalesce-合并分区1234567891011121314151617/** * Returns a new Dataset that has exactly `numPartitions` partitions. * Similar to coalesce defined on an `RDD`, this operation results in a narrow dependency, e.g. * if you go from 1000 partitions to 100 partitions, there will not be a shuffle, instead each of * the 100 new partitions will claim 10 of the current partitions. * * 合并。 * 返回确定分区数量的Dataset。 * 和RDD中的合并方法类似，这个操作导致了一个窄依赖。 * 例如：将1000个分区合并为100个分区，这个过程没有shuffle，而是100个新分区中的每个分区将声明当前的10个分区。 * * @group typedrel * @since 1.6.0 */ def coalesce(numPartitions: Int): Dataset[T] = withTypedPlan &#123; Repartition(numPartitions, shuffle = false, logicalPlan) &#125; distinct-去重1234567891011121314/** * Returns a new Dataset that contains only the unique rows from this Dataset. * This is an alias for `dropDuplicates`. * * 去重。 * 返回去重后的Dataset。 * 和 `dropDuplicates` 方法一致。 * * @note Equality checking is performed directly on the encoded representation of the data * and thus is not affected by a custom `equals` function defined on `T`. * @group typedrel * @since 2.0.0 */ def distinct(): Dataset[T] = dropDuplicates()","raw":null,"content":null,"categories":[{"name":"spark","slug":"spark","permalink":"https://stanxia.github.io/categories/spark/"}],"tags":[{"name":"spark","slug":"spark","permalink":"https://stanxia.github.io/tags/spark/"},{"name":"源码","slug":"源码","permalink":"https://stanxia.github.io/tags/源码/"}]},{"title":"JavaRDDLike.scala","slug":"JavaRDDLike-scala","date":"2017-11-21T14:21:23.000Z","updated":"2019-04-17T06:08:31.936Z","comments":true,"path":"2017/11/21/JavaRDDLike-scala/","link":"","permalink":"https://stanxia.github.io/2017/11/21/JavaRDDLike-scala/","excerpt":"使用Java开发Spark程序，JavaRDD的功能算子中英文注释JavaRDDLike的实现应该扩展这个虚拟抽象类，而不是直接继承这个特性。\n\nJavaRDD1234567891011121314151617181920package org.apache.spark.api.javaprivate[spark] abstract class AbstractJavaRDDLike[T, This &lt;: JavaRDDLike[T, This]]  extends JavaRDDLike[T, This]/**  * Defines operations common to several Java RDD implementations.  *  * 定义几个Java RDD实现的常见操作。  *  * @note This trait is not intended to be implemented by user code.  *  *       该特性不打算由用户代码实现。  */trait JavaRDDLike[T, This &lt;: JavaRDDLike[T, This]] extends Serializable &#123;  def wrapRDD(rdd: RDD[T]): This  implicit val classTag: ClassTag[T]  def rdd: RDD[T]","text":"使用Java开发Spark程序，JavaRDD的功能算子中英文注释JavaRDDLike的实现应该扩展这个虚拟抽象类，而不是直接继承这个特性。 JavaRDD1234567891011121314151617181920package org.apache.spark.api.javaprivate[spark] abstract class AbstractJavaRDDLike[T, This &lt;: JavaRDDLike[T, This]] extends JavaRDDLike[T, This]/** * Defines operations common to several Java RDD implementations. * * 定义几个Java RDD实现的常见操作。 * * @note This trait is not intended to be implemented by user code. * * 该特性不打算由用户代码实现。 */trait JavaRDDLike[T, This &lt;: JavaRDDLike[T, This]] extends Serializable &#123; def wrapRDD(rdd: RDD[T]): This implicit val classTag: ClassTag[T] def rdd: RDD[T] partitions1234/** Set of partitions in this RDD. * 在这个RDD中设置的分区。 * */def partitions: JList[Partition] = rdd.partitions.toSeq.asJava getNumPartitions12345/** Return the number of partitions in this RDD. * 返回该RDD中的分区数。 * */@Since(\"1.6.0\")def getNumPartitions: Int = rdd.getNumPartitions partitioner1234/** The partitioner of this RDD. * 这个RDD的分区。 * */def partitioner: Optional[Partitioner] = JavaUtils.optionToOptional(rdd.partitioner) context12345/** The [[org.apache.spark.SparkContext]] that this RDD was created on. * * 这个RDD是在[[org.apache.spark.SparkContext]]上面创建的。 * */def context: SparkContext = rdd.context id1234/** A unique ID for this RDD (within its SparkContext). * 这个RDD的惟一ID(在它的SparkContext内)。 * */def id: Int = rdd.id name1def name(): String = rdd.name getStorageLevel1234/** Get the RDD's current storage level, or StorageLevel.NONE if none is set. * 获取RDD的当前存储级别，或StorageLevel。如果没有设置就没有。 * */def getStorageLevel: StorageLevel = rdd.getStorageLevel iterator12345678910/** * Internal method to this RDD; will read from cache if applicable, or otherwise compute it. * This should ''not'' be called by users directly, but is available for implementors of custom * subclasses of RDD. * 内部方法的RDD;将从缓存读取，如果适用的话，或者计算它。 * 这应该“不是”直接由用户调用，而是用于RDD的自定义子类的实现者 * */def iterator(split: Partition, taskContext: TaskContext): JIterator[T] = rdd.iterator(split, taskContext).asJavs Transformations (return a new RDD)map1234567/** * Return a new RDD by applying a function to all elements of this RDD. * 将一个函数应用于这个RDD的所有元素，返回一个新的RDD。 * */def map[R](f: JFunction[T, R]): JavaRDD[R] = new JavaRDD(rdd.map(f)(fakeClassTag))(fakeClassTag) mapPartitionsWithIndex1234567891011/** * Return a new RDD by applying a function to each partition of this RDD, while tracking the index * of the original partition. * 通过在RDD的每个分区上应用一个函数来返回一个新的RDD，同时跟踪原始分区的索引。 * */def mapPartitionsWithIndex[R]( f: JFunction2[jl.Integer, JIterator[T], JIterator[R]], preservesPartitioning: Boolean = false): JavaRDD[R] = new JavaRDD(rdd.mapPartitionsWithIndex((a, b) =&gt; f.call(a, b.asJava).asScala, preservesPartitioning)(fakeClassTag))(fakeClassTag) mapToDouble1234567/** * Return a new RDD by applying a function to all elements of this RDD. * 将一个函数应用于这个RDD的所有元素，返回一个新的RDD。 */def mapToDouble[R](f: DoubleFunction[T]): JavaDoubleRDD = &#123; new JavaDoubleRDD(rdd.map(f.call(_).doubleValue()))&#125; mapToPair123456789/** * Return a new RDD by applying a function to all elements of this RDD. * 将一个函数应用于这个RDD的所有元素，返回一个新的RDD。 * */def mapToPair[K2, V2](f: PairFunction[T, K2, V2]): JavaPairRDD[K2, V2] = &#123; def cm: ClassTag[(K2, V2)] = implicitly[ClassTag[(K2, V2)]] new JavaPairRDD(rdd.map[(K2, V2)](f)(cm))(fakeClassTag[K2], fakeClassTag[V2])&#125; flatMap12345678910/** * Return a new RDD by first applying a function to all elements of this * RDD, and then flattening the results. * 返回一个新的RDD，首先将一个函数应用于这个RDD的所有元素，然后将结果扁平化。 * */def flatMap[U](f: FlatMapFunction[T, U]): JavaRDD[U] = &#123; def fn: (T) =&gt; Iterator[U] = (x: T) =&gt; f.call(x).asScala JavaRDD.fromRDD(rdd.flatMap(fn)(fakeClassTag[U]))(fakeClassTag[U])&#125; flatMapToDouble12345678910/** * Return a new RDD by first applying a function to all elements of this * RDD, and then flattening the results. * 返回一个新的RDD，首先将一个函数应用于这个RDD的所有元素，然后将结果扁平化。 * */def flatMapToDouble(f: DoubleFlatMapFunction[T]): JavaDoubleRDD = &#123; def fn: (T) =&gt; Iterator[jl.Double] = (x: T) =&gt; f.call(x).asScala new JavaDoubleRDD(rdd.flatMap(fn).map(_.doubleValue()))&#125; flatMapToPair1234567891011/** * Return a new RDD by first applying a function to all elements of this * RDD, and then flattening the results. * 返回一个新的RDD，首先将一个函数应用于这个RDD的所有元素，然后将结果扁平化。 * */def flatMapToPair[K2, V2](f: PairFlatMapFunction[T, K2, V2]): JavaPairRDD[K2, V2] = &#123; def fn: (T) =&gt; Iterator[(K2, V2)] = (x: T) =&gt; f.call(x).asScala def cm: ClassTag[(K2, V2)] = implicitly[ClassTag[(K2, V2)]] JavaPairRDD.fromRDD(rdd.flatMap(fn)(cm))(fakeClassTag[K2], fakeClassTag[V2])&#125; mapPartitions12345678910111213141516171819202122232425/** * Return a new RDD by applying a function to each partition of this RDD. * 通过将一个函数应用于这个RDD的每个分区，返回一个新的RDD。 * */def mapPartitions[U](f: FlatMapFunction[JIterator[T], U]): JavaRDD[U] = &#123; def fn: (Iterator[T]) =&gt; Iterator[U] = &#123; (x: Iterator[T]) =&gt; f.call(x.asJava).asScala &#125; JavaRDD.fromRDD(rdd.mapPartitions(fn)(fakeClassTag[U]))(fakeClassTag[U])&#125;/** * Return a new RDD by applying a function to each partition of this RDD. * 通过将一个函数应用于这个RDD的每个分区，返回一个新的RDD。 * */def mapPartitions[U](f: FlatMapFunction[JIterator[T], U], preservesPartitioning: Boolean): JavaRDD[U] = &#123; def fn: (Iterator[T]) =&gt; Iterator[U] = &#123; (x: Iterator[T]) =&gt; f.call(x.asJava).asScala &#125; JavaRDD.fromRDD( rdd.mapPartitions(fn, preservesPartitioning)(fakeClassTag[U]))(fakeClassTag[U])&#125; mapPartitionsToDouble12345678910111213141516171819202122232425/** * Return a new RDD by applying a function to each partition of this RDD. * 通过将一个函数应用于这个RDD的每个分区，返回一个新的RDD。 * */def mapPartitionsToDouble(f: DoubleFlatMapFunction[JIterator[T]]): JavaDoubleRDD = &#123; def fn: (Iterator[T]) =&gt; Iterator[jl.Double] = &#123; (x: Iterator[T]) =&gt; f.call(x.asJava).asScala &#125; new JavaDoubleRDD(rdd.mapPartitions(fn).map(_.doubleValue()))&#125;/** * Return a new RDD by applying a function to each partition of this RDD. * 通过将一个函数应用于这个RDD的每个分区，返回一个新的RDD。 * */def mapPartitionsToDouble(f: DoubleFlatMapFunction[JIterator[T]], preservesPartitioning: Boolean): JavaDoubleRDD = &#123; def fn: (Iterator[T]) =&gt; Iterator[jl.Double] = &#123; (x: Iterator[T]) =&gt; f.call(x.asJava).asScala &#125; new JavaDoubleRDD(rdd.mapPartitions(fn, preservesPartitioning) .map(_.doubleValue()))&#125; mapPartitionsToPair1234567891011121314151617181920212223242526/** * Return a new RDD by applying a function to each partition of this RDD. * 通过将一个函数应用于这个RDD的每个分区，返回一个新的RDD。 * */def mapPartitionsToPair[K2, V2](f: PairFlatMapFunction[JIterator[T], K2, V2]):JavaPairRDD[K2, V2] = &#123; def fn: (Iterator[T]) =&gt; Iterator[(K2, V2)] = &#123; (x: Iterator[T]) =&gt; f.call(x.asJava).asScala &#125; JavaPairRDD.fromRDD(rdd.mapPartitions(fn))(fakeClassTag[K2], fakeClassTag[V2])&#125;/** * Return a new RDD by applying a function to each partition of this RDD. * 通过将一个函数应用于这个RDD的每个分区，返回一个新的RDD。 * */def mapPartitionsToPair[K2, V2](f: PairFlatMapFunction[JIterator[T], K2, V2], preservesPartitioning: Boolean): JavaPairRDD[K2, V2] = &#123; def fn: (Iterator[T]) =&gt; Iterator[(K2, V2)] = &#123; (x: Iterator[T]) =&gt; f.call(x.asJava).asScala &#125; JavaPairRDD.fromRDD( rdd.mapPartitions(fn, preservesPartitioning))(fakeClassTag[K2], fakeClassTag[V2])&#125; foreachPartition12345678/** * Applies a function f to each partition of this RDD. * 将函数f应用于该RDD的每个分区。 * */def foreachPartition(f: VoidFunction[JIterator[T]]): Unit = &#123; rdd.foreachPartition(x =&gt; f.call(x.asJava))&#125; glom1234567/** * Return an RDD created by coalescing all elements within each partition into an array. * 返回一个RDD，它将每个分区中的所有元素合并到一个数组中。 * */def glom(): JavaRDD[JList[T]] = new JavaRDD(rdd.glom().map(_.toSeq.asJava)) cartesian12345678/** * Return the Cartesian product of this RDD and another one, that is, the RDD of all pairs of * elements (a, b) where a is in `this` and b is in `other`. * 返回这个RDD和另一个的笛卡尔乘积，即所有元素对的RDD(a,b) ：a在该RDD中，b在另一个RDD中 * */def cartesian[U](other: JavaRDDLike[U, _]): JavaPairRDD[T, U] = JavaPairRDD.fromRDD(rdd.cartesian(other.rdd)(other.classTag))(classTag, other.classTag) groupBy123456789101112131415161718192021222324252627/** * Return an RDD of grouped elements. Each group consists of a key and a sequence of elements * mapping to that key. * 返回分组元素的RDD。 * 每个组由一个键和一个映射到该键的元素序列组成。 * */def groupBy[U](f: JFunction[T, U]): JavaPairRDD[U, JIterable[T]] = &#123; // The type parameter is U instead of K in order to work around a compiler bug; see SPARK-4459 // 类型参数是U而不是K，是为了绕过编译器错误 implicit val ctagK: ClassTag[U] = fakeClassTag implicit val ctagV: ClassTag[JList[T]] = fakeClassTag JavaPairRDD.fromRDD(groupByResultToJava(rdd.groupBy(f)(fakeClassTag)))&#125;/** * Return an RDD of grouped elements. Each group consists of a key and a sequence of elements * mapping to that key. * 返回分组元素的RDD。 * 每个组由一个键和一个映射到该键的元素序列组成。 */def groupBy[U](f: JFunction[T, U], numPartitions: Int): JavaPairRDD[U, JIterable[T]] = &#123; // The type parameter is U instead of K in order to work around a compiler bug; see SPARK-4459 implicit val ctagK: ClassTag[U] = fakeClassTag implicit val ctagV: ClassTag[JList[T]] = fakeClassTag JavaPairRDD.fromRDD(groupByResultToJava(rdd.groupBy(f, numPartitions)(fakeClassTag[U])))&#125; pipe123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * Return an RDD created by piping elements to a forked external process. * 返回由管道元素调用外部程序返回新的RDD * */def pipe(command: String): JavaRDD[String] = &#123; rdd.pipe(command)&#125;/** * Return an RDD created by piping elements to a forked external process. * 返回由管道元素调用外部程序返回新的RDD * */def pipe(command: JList[String]): JavaRDD[String] = &#123; rdd.pipe(command.asScala)&#125;/** * Return an RDD created by piping elements to a forked external process. * 返回由管道元素调用外部程序返回新的RDD * */def pipe(command: JList[String], env: JMap[String, String]): JavaRDD[String] = &#123; rdd.pipe(command.asScala, env.asScala)&#125;/** * Return an RDD created by piping elements to a forked external process. * 返回由管道元素调用外部程序返回新的RDD * */def pipe(command: JList[String], env: JMap[String, String], separateWorkingDir: Boolean, bufferSize: Int): JavaRDD[String] = &#123; rdd.pipe(command.asScala, env.asScala, null, null, separateWorkingDir, bufferSize)&#125;/** * Return an RDD created by piping elements to a forked external process. * 返回由管道元素调用外部程序返回新的RDD * */def pipe(command: JList[String], env: JMap[String, String], separateWorkingDir: Boolean, bufferSize: Int, encoding: String): JavaRDD[String] = &#123; rdd.pipe(command.asScala, env.asScala, null, null, separateWorkingDir, bufferSize, encoding)&#125; zip123456789101112/** * Zips this RDD with another one, returning key-value pairs with the first element in each RDD, * second element in each RDD, etc. Assumes that the two RDDs have the *same number of * partitions* and the *same number of elements in each partition* (e.g. one was made through * a map on the other). * 将此RDD与另一个RDD进行Zips，返回键值对，每个RDD中的第一个元素，每个RDD中的第二个元素，等等。 * 假设两个RDDs拥有相同数量的分区和每个分区中相同数量的元素 * (例如，一个是通过另一个map的)。 */def zip[U](other: JavaRDDLike[U, _]): JavaPairRDD[T, U] = &#123; JavaPairRDD.fromRDD(rdd.zip(other.rdd)(other.classTag))(classTag, other.classTag)&#125; zipPartitions1234567891011121314151617/** * Zip this RDD's partitions with one (or more) RDD(s) and return a new RDD by * applying a function to the zipped partitions. Assumes that all the RDDs have the * *same number of partitions*, but does *not* require them to have the same number * of elements in each partition. * 用一个(或多个)RDD(或多个)来压缩这个RDD的分区，并返回一个新的RDD将函数应用于压缩分区。 * 假设所有RDDs拥有相同数量的分区，但不要求它们在每个分区中拥有相同数量的元素。 */def zipPartitions[U, V]( other: JavaRDDLike[U, _], f: FlatMapFunction2[JIterator[T], JIterator[U], V]): JavaRDD[V] = &#123; def fn: (Iterator[T], Iterator[U]) =&gt; Iterator[V] = &#123; (x: Iterator[T], y: Iterator[U]) =&gt; f.call(x.asJava, y.asJava).asScala &#125; JavaRDD.fromRDD( rdd.zipPartitions(other.rdd)(fn)(other.classTag, fakeClassTag[V]))(fakeClassTag[V])&#125; zipWithUniqueId1234567891011/** * Zips this RDD with generated unique Long ids. Items in the kth partition will get ids k, n+k, * 2*n+k, ..., where n is the number of partitions. So there may exist gaps, but this method * won't trigger a spark job, which is different from [[org.apache.spark.rdd.RDD#zipWithIndex]]. * 用生成的唯一长的id来压缩这个RDD。 * 第k个分区的项将得到id k,n + k,2 *n+ k，…，其中n是分区数。 * 因此，可能存在差距，但这种方法不会触发spark作业，它与[org .apache.spark. spark.rdd. rdd. rdd # zipWithIndex]不同。 */def zipWithUniqueId(): JavaPairRDD[T, jl.Long] = &#123; JavaPairRDD.fromRDD(rdd.zipWithUniqueId()).asInstanceOf[JavaPairRDD[T, jl.Long]]&#125; zipWithIndex12345678910111213141516/** * Zips this RDD with its element indices. The ordering is first based on the partition index * and then the ordering of items within each partition. So the first item in the first * partition gets index 0, and the last item in the last partition receives the largest index. * This is similar to Scala's zipWithIndex but it uses Long instead of Int as the index type. * This method needs to trigger a spark job when this RDD contains more than one partitions. * * 用它的元素索引来压缩这个RDD。 * 排序首先基于分区索引，然后是每个分区中的条目的排序。 * 因此，第一个分区中的第一个项的索引值为0，最后一个分区中的最后一个项得到最大的索引。 * 这类似于Scala的zipWithIndex，但它使用的是Long而不是Int作为索引类型。 * 当这个RDD包含多个分区时，这个方法需要触发一个spark作业。 */def zipWithIndex(): JavaPairRDD[T, jl.Long] = &#123; JavaPairRDD.fromRDD(rdd.zipWithIndex()).asInstanceOf[JavaPairRDD[T, jl.Long]]&#125; Actions (launch a job to return a value to the user program)foreach1234567/** * Applies a function f to all elements of this RDD. * 将函数f应用于该RDD的所有元素。 */def foreach(f: VoidFunction[T]) &#123; rdd.foreach(x =&gt; f.call(x))&#125; collect12345678910/** * Return an array that contains all of the elements in this RDD. * 返回包含该RDD中所有元素的数组。 * * @note this method should only be used if the resulting array is expected to be small, as * all the data is loaded into the driver's memory. * 该方法只在预期的数组很小的情况下使用，因为所有的数据都被加载到驱动程序的内存中。 */def collect(): JList[T] = rdd.collect().toSeq.asJava toLocalIterator123456789/** * Return an iterator that contains all of the elements in this RDD. * 返回包含该RDD中所有元素的迭代器。 * * The iterator will consume as much memory as the largest partition in this RDD. * 迭代器将消耗与此RDD中最大的分区一样多的内存。 */def toLocalIterator(): JIterator[T] = asJavaIteratorConverter(rdd.toLocalIterator).asJava collectPartitions1234567891011 /** * Return an array that contains all of the elements in a specific partition of this RDD. * 返回包含该RDD的特定分区中的所有元素的数组。 */def collectPartitions(partitionIds: Array[Int]): Array[JList[T]] = &#123; // This is useful for implementing `take` from other language frontends // like Python where the data is serialized. // 这有助于从其他语言的前沿实现“take”，如Python，数据被序列化。 val res = context.runJob(rdd, (it: Iterator[T]) =&gt; it.toArray, partitionIds) res.map(_.toSeq.asJava)&#125; reduce123456/** * Reduces the elements of this RDD using the specified commutative and associative binary * operator. * 使用指定的交换和关联二元运算符来减少该RDD的元素。 */def reduce(f: JFunction2[T, T, T]): T = rdd.reduce(f) treeReduce12345678910111213/** * Reduces the elements of this RDD in a multi-level tree pattern. * 将此RDD的元素简化为多层树模式。 * * @param depth suggested depth of the tree 建议树的深度 * @see [[org.apache.spark.api.java.JavaRDDLike#reduce]] */def treeReduce(f: JFunction2[T, T, T], depth: Int): T = rdd.treeReduce(f, depth)/** * [[org.apache.spark.api.java.JavaRDDLike#treeReduce]] 建议深度 2 . */def treeReduce(f: JFunction2[T, T, T]): T = treeReduce(f, 2) fold123456789101112131415161718192021 /** * Aggregate the elements of each partition, and then the results for all the partitions, using a * given associative function and a neutral \"zero value\". The function * op(t1, t2) is allowed to modify t1 and return it as its result value to avoid object * allocation; however, it should not modify t2. * 对每个分区的元素进行聚合，然后使用给定的关联函数和中立的“零值”，对所有分区进行结果。 * 函数op(t1,t2)被允许修改t1，并将其作为其结果值返回，以避免对象分配;但是，它不应该修改t2。 * * This behaves somewhat differently from fold operations implemented for non-distributed * collections in functional languages like Scala. This fold operation may be applied to * partitions individually, and then fold those results into the final result, rather than * apply the fold to each element sequentially in some defined ordering. For functions * that are not commutative, the result may differ from that of a fold applied to a * non-distributed collection. * 这与在Scala等函数式语言中实现非分布式集合的折叠操作有一定的不同。 * 这个折叠操作可以单独应用于分区，然后将这些结果折叠到最终结果中，而不是在某些定义的排序中顺序地对每个元素进行折叠。 * 对于非交换的函数，结果可能与应用于非分布式集合的函数不同。 * */def fold(zeroValue: T)(f: JFunction2[T, T, T]): T = rdd.fold(zeroValue)(f) aggregate12345678910111213141516 /** * Aggregate the elements of each partition, and then the results for all the partitions, using * given combine functions and a neutral \"zero value\". This function can return a different result * type, U, than the type of this RDD, T. Thus, we need one operation for merging a T into an U * and one operation for merging two U's, as in scala.TraversableOnce. Both of these functions are * allowed to modify and return their first argument instead of creating a new U to avoid memory * allocation. * 对每个分区的元素进行聚合，然后使用给定的组合函数和一个中立的“零值”，对所有分区进行结果。 * 这个函数可以返回一个不同的结果类型U，而不是这个RDD的类型。 * 因此，我们需要一个操作来将一个T合并到一个U和一个合并两个U的操作，就像在scala . traversableonce中那样。 * 这两个函数都可以修改和返回第一个参数，而不是创建一个新的U，以避免内存分配。 * */def aggregate[U](zeroValue: U)(seqOp: JFunction2[U, T, U], combOp: JFunction2[U, U, U]): U = rdd.aggregate(zeroValue)(seqOp, combOp)(fakeClassTag[U]) treeAggregate12345678910111213141516171819202122232425 /** * Aggregates the elements of this RDD in a multi-level tree pattern. * 将此RDD的元素聚集在多层树模式中。 * * @param depth suggested depth of the tree 建议的树的深度 * @see [[org.apache.spark.api.java.JavaRDDLike#aggregate]] */def treeAggregate[U]( zeroValue: U, seqOp: JFunction2[U, T, U], combOp: JFunction2[U, U, U], depth: Int): U = &#123; rdd.treeAggregate(zeroValue)(seqOp, combOp, depth)(fakeClassTag[U])&#125;/** * [[org.apache.spark.api.java.JavaRDDLike#treeAggregate]] with suggested depth 2. * 建议的树的深度为 2 */def treeAggregate[U]( zeroValue: U, seqOp: JFunction2[U, T, U], combOp: JFunction2[U, U, U]): U = &#123; treeAggregate(zeroValue, seqOp, combOp, 2)&#125; count123456/** * Return the number of elements in the RDD. * 返回RDD中元素的数量。 * */def count(): Long = rdd.count() countApprox12345678910111213141516171819202122232425262728293031323334353637 /** * Approximate version of count() that returns a potentially incomplete result * within a timeout, even if not all tasks have finished. * 近似版本的count()，即使不是所有的任务都完成了，也会在一个超时中返回一个潜在的不完整的结果。 * * * The confidence is the probability that the error bounds of the result will * contain the true value. That is, if countApprox were called repeatedly * with confidence 0.9, we would expect 90% of the results to contain the * true count. The confidence must be in the range [0,1] or an exception will * be thrown. * 置信值是结果的误差边界包含真实值的概率。 * 也就是说，如果countApprox被反复调用，confidence 0.9，我们将期望90%的结果包含真实的计数。 * confidence必须在范围[0,1]中，否则将抛出异常。 * * * @param timeout maximum time to wait for the job, in milliseconds * 等待工作的最大时间，以毫秒为单位 * @param confidence the desired statistical confidence in the result * 对结果的期望的统计信心 * @return a potentially incomplete result, with error bounds * 一个可能不完整的结果，有错误界限 */def countApprox(timeout: Long, confidence: Double): PartialResult[BoundedDouble] = rdd.countApprox(timeout, confidence)/** * Approximate version of count() that returns a potentially incomplete result * within a timeout, even if not all tasks have finished. * 近似版本的count()，即使不是所有的任务都完成了，也会在一个超时中返回一个潜在的不完整的结果。 * * * @param timeout maximum time to wait for the job, in milliseconds * 等待工作的最大时间，以毫秒为单位 */def countApprox(timeout: Long): PartialResult[BoundedDouble] = rdd.countApprox(timeout) countByValue123456789/** * Return the count of each unique value in this RDD as a map of (value, count) pairs. The final * combine step happens locally on the master, equivalent to running a single reduce task. * 将此RDD中的每个惟一值的计数作为(值、计数)对的映射。 * 最后的联合步骤在master的本地发生，相当于运行一个reduce任务。 * */def countByValue(): JMap[T, jl.Long] = mapAsSerializableJavaMap(rdd.countByValue()).asInstanceOf[JMap[T, jl.Long]] countByValueApprox1234567891011121314151617181920212223242526272829303132333435363738 /** * Approximate version of countByValue(). * countByValue()近似的版本。 * * The confidence is the probability that the error bounds of the result will * contain the true value. That is, if countApprox were called repeatedly * with confidence 0.9, we would expect 90% of the results to contain the * true count. The confidence must be in the range [0,1] or an exception will * be thrown. * 置信值是结果的误差边界包含真实值的概率。 * 也就是说，如果countApprox被反复调用，confidence 0.9，我们将期望90%的结果包含真实的计数。 * confidence必须在范围[0,1]中，否则将抛出异常。 * * * @param timeout maximum time to wait for the job, in milliseconds * 等待工作的最大时间，毫秒为单位。 * @param confidence the desired statistical confidence in the result * 对结果的期望的统计信心 * @return a potentially incomplete result, with error bounds * 一个可能不完整的结果，有错误界限 */def countByValueApprox( timeout: Long, confidence: Double ): PartialResult[JMap[T, BoundedDouble]] = rdd.countByValueApprox(timeout, confidence).map(mapAsSerializableJavaMap)/** * Approximate version of countByValue(). * countByValue().的近似版本. * * @param timeout maximum time to wait for the job, in milliseconds * 等待工作的最大时间，毫秒为单位。 * @return a potentially incomplete result, with error bounds * 一个可能不完整的结果，有错误界限 */def countByValueApprox(timeout: Long): PartialResult[JMap[T, BoundedDouble]] = rdd.countByValueApprox(timeout).map(mapAsSerializableJavaMap) take12345678910111213141516 /** * Take the first num elements of the RDD. This currently scans the partitions *one by one*, so * it will be slow if a lot of partitions are required. In that case, use collect() to get the * whole RDD instead. * 获取RDD的第一个num元素。 * 这将会一次一个地扫描分区，所以如果需要很多分区，它将会很慢。 * 在这种情况下，使用collect()来获得整个RDD。 * * * @note this method should only be used if the resulting array is expected to be small, as * all the data is loaded into the driver's memory. * 该方法只在预期的数组很小的情况下使用，因为所有的数据都被加载到驱动程序的内存中。 * */def take(num: Int): JList[T] = rdd.take(num).toSeq.asJava takeSample12345def takeSample(withReplacement: Boolean, num: Int): JList[T] = takeSample(withReplacement, num, Utils.random.nextLong)def takeSample(withReplacement: Boolean, num: Int, seed: Long): JList[T] = rdd.takeSample(withReplacement, num, seed).toSeq.asJava first12345 /** * Return the first element in this RDD. * 返回这个RDD中的第一个元素。 */def first(): T = rdd.first() isEmpty1234567/** * @return true if and only if the RDD contains no elements at all. Note that an RDD * may be empty even when it has at least 1 partition. * 当且仅当RDD不包含任何元素，则为真。 * 请注意，即使在至少有一个分区的情况下，RDD也可能是空的。 */def isEmpty(): Boolean = rdd.isEmpty() saveAsTextFile123456789101112131415/** * Save this RDD as a text file, using string representations of elements. * 将此RDD保存为文本文件，使用元素的字符串表示形式。 */def saveAsTextFile(path: String): Unit = &#123; rdd.saveAsTextFile(path)&#125;/** * Save this RDD as a compressed text file, using string representations of elements. * 将此RDD保存为一个压缩文本文件，使用元素的字符串表示形式。 */def saveAsTextFile(path: String, codec: Class[_ &lt;: CompressionCodec]): Unit = &#123; rdd.saveAsTextFile(path, codec)&#125; saveAsObjectFile1234567/** * Save this RDD as a SequenceFile of serialized objects. * 将此RDD保存为序列化对象的序列文件。 */def saveAsObjectFile(path: String): Unit = &#123; rdd.saveAsObjectFile(path)&#125; keyBy12345678910/** * Creates tuples of the elements in this RDD by applying `f`. * 通过应用“f”创建这个RDD中元素的元组。 */def keyBy[U](f: JFunction[T, U]): JavaPairRDD[U, T] = &#123; // The type parameter is U instead of K in order to work around a compiler bug; see SPARK-4459 // 类型参数用U替代K，为了绕过编译器错误; implicit val ctag: ClassTag[U] = fakeClassTag JavaPairRDD.fromRDD(rdd.keyBy(f))&#125; checkpoint12345678910111213141516/** * Mark this RDD for checkpointing. It will be saved to a file inside the checkpoint * directory set with SparkContext.setCheckpointDir() and all references to its parent * RDDs will be removed. This function must be called before any job has been * executed on this RDD. It is strongly recommended that this RDD is persisted in * memory, otherwise saving it on a file will require recomputation. * 将此RDD标记为检查点。 * 它将被保存到由SparkContext.setCheckpointDir()设置的检查点目录下的文件中。 * 所有对其父RDDs的引用将被删除。 * 在此RDD上执行任何作业之前，必须调用此函数。 * 强烈建议将此RDD保存在内存中，否则将其保存在文件中需要重新计算。 * */def checkpoint(): Unit = &#123; rdd.checkpoint()&#125; isCheckpointed12345/** * Return whether this RDD has been checkpointed or not * 返回 RDD是否已被检查过 */def isCheckpointed: Boolean = rdd.isCheckpointed getCheckpointFile1234567/** * Gets the name of the file to which this RDD was checkpointed * 获取该RDD所指向的checkpointed文件的名称 */def getCheckpointFile(): Optional[String] = &#123; JavaUtils.optionToOptional(rdd.getCheckpointFile)&#125; toDebugString123456/** A description of this RDD and its recursive dependencies for debugging. * 对该RDD及其对调试的递归依赖的描述。 * */def toDebugString(): String = &#123; rdd.toDebugString&#125; top12345678910111213141516171819202122232425262728293031323334/** * Returns the top k (largest) elements from this RDD as defined by * the specified Comparator[T] and maintains the order. * 根据指定的比较器[T]，从这个RDD中返回最大的k(最大)元素，并维护顺序。 * * * @note this method should only be used if the resulting array is expected to be small, as * all the data is loaded into the driver's memory. * 该方法只在预期的数组很小的情况下使用，因为所有的数据都被加载到驱动程序的内存中。 * * @param num k, the number of top elements to return 返回的元素数量 * @param comp the comparator that defines the order 定义排序的比较器 * @return an array of top elements 返回最大元素的数组 */def top(num: Int, comp: Comparator[T]): JList[T] = &#123; rdd.top(num)(Ordering.comparatorToOrdering(comp)).toSeq.asJava&#125;/** * Returns the top k (largest) elements from this RDD using the * natural ordering for T and maintains the order. * 使用T的自然顺序，从这个RDD中返回最大的k(最大)元素，并维护顺序。 * * @note this method should only be used if the resulting array is expected to be small, as * all the data is loaded into the driver's memory. * 该方法只在预期的数组很小的情况下使用，因为所有的数据都被加载到驱动程序的内存中。 * * @param num k, the number of top elements to return 返回的元素数量 * @return an array of top elements 最大元素的数组 */def top(num: Int): JList[T] = &#123; val comp = com.google.common.collect.Ordering.natural().asInstanceOf[Comparator[T]] top(num, comp)&#125; takeOrdered123456789101112131415161718192021222324252627282930313233/** * Returns the first k (smallest) elements from this RDD as defined by * the specified Comparator[T] and maintains the order. * 从这个RDD中返回第一个k(最小)元素，由指定的Comparator[T]定义，并维护该顺序。 * * * @note this method should only be used if the resulting array is expected to be small, as * all the data is loaded into the driver's memory. * 该方法只在预期的数组很小的情况下使用，因为所有的数据都被加载到驱动程序的内存中。 * * @param num k, the number of elements to return 返回的元素数量 * @param comp the comparator that defines the order 排序比较器 * @return an array of top elements 元素数组 */def takeOrdered(num: Int, comp: Comparator[T]): JList[T] = &#123; rdd.takeOrdered(num)(Ordering.comparatorToOrdering(comp)).toSeq.asJava&#125;/** * Returns the first k (smallest) elements from this RDD using the * natural ordering for T while maintain the order. * 使用原生的 T排序比较器，返回 k个 最小值，并维护这个顺序 * * @note this method should only be used if the resulting array is expected to be small, as * all the data is loaded into the driver's memory. * 尽量应用于小的数组，因为会加载到driver内存中。 * @param num k, the number of top elements to return * @return an array of top elements */def takeOrdered(num: Int): JList[T] = &#123; val comp = com.google.common.collect.Ordering.natural().asInstanceOf[Comparator[T]] takeOrdered(num, comp)&#125; max123456789101112/** * Returns the maximum element from this RDD as defined by the specified * Comparator[T]. * 按照指定比较器[T]定义的RDD， * 返回最大元素。 * * @param comp the comparator that defines ordering 指定的比较器 * @return the maximum of the RDD 最大值 */def max(comp: Comparator[T]): T = &#123; rdd.max()(Ordering.comparatorToOrdering(comp))&#125; min123456789101112/** * Returns the minimum element from this RDD as defined by the specified * Comparator[T]. * 按照指定比较器[T]定义的RDD， * 返回最小元素。 * * @param comp the comparator that defines ordering 指定的比较器 * @return the minimum of the RDD 最小值 */def min(comp: Comparator[T]): T = &#123; rdd.min()(Ordering.comparatorToOrdering(comp))&#125; countApproxDistinct123456789101112131415161718/*** Return approximate number of distinct elements in the RDD.* 返回RDD中不重复元素的数量近似数。** The algorithm used is based on streamlib's implementation of \"HyperLogLog in Practice:* Algorithmic Engineering of a State of The Art Cardinality Estimation Algorithm\", available * &lt;a href=\"http://dx.doi.org/10.1145/2452376.2452456\"&gt;here&lt;/a&gt;. * 所使用的算法是基于streamlib在实践中的“HyperLogLog”的实现: * “一种艺术基数估计算法状态的算法工程”， * * * @param relativeSD Relative accuracy. Smaller values create counters that require more space. * It must be greater than 0.000017. * 相对精度。 * 较小的值创建需要更多空间的计数器。 * 它必须大于0.000017。 */ def countApproxDistinct(relativeSD: Double): Long = rdd.countApproxDistinct(relativeSD) countAsync12345678/** * The asynchronous version of `count`, which returns a * future for counting the number of elements in this RDD. * “count”的异步版本，它为计算这个RDD中元素的数量返回一个未来。 */def countAsync(): JavaFutureAction[jl.Long] = &#123;new JavaFutureActionWrapper[Long, jl.Long](rdd.countAsync(), jl.Long.valueOf)&#125; collectAsync12345678910111213/** * The asynchronous version of `collect`, which returns a future for * retrieving an array containing all of the elements in this RDD. * “collect”的异步版本， * 它返回一个用于检索包含该RDD中所有元素的数组的未来。 * * @note this method should only be used if the resulting array is expected to be small, as * all the data is loaded into the driver's memory. * 尽量应用于小数量数组。 */def collectAsync(): JavaFutureAction[JList[T]] = &#123;new JavaFutureActionWrapper(rdd.collectAsync(), (x: Seq[T]) =&gt; x.asJava)&#125; takeAsync123456789101112/** * The asynchronous version of the `take` action, which returns a * future for retrieving the first `num` elements of this RDD. * “take”操作的异步版本， * 它将返回用于检索此RDD的第一个“num”元素的未来。 * * @note this method should only be used if the resulting array is expected to be small, as * all the data is loaded into the driver's memory. */def takeAsync(num: Int): JavaFutureAction[JList[T]] = &#123;new JavaFutureActionWrapper(rdd.takeAsync(num), (x: Seq[T]) =&gt; x.asJava)&#125; foreachAsync1234567891011/** * The asynchronous version of the `foreach` action, which * applies a function f to all the elements of this RDD. * “foreach”操作的异步版本， * 它将函数f应用于这个RDD的所有元素。 * */def foreachAsync(f: VoidFunction[T]): JavaFutureAction[Void] = &#123;new JavaFutureActionWrapper[Unit, Void](rdd.foreachAsync(x =&gt; f.call(x)),&#123; x =&gt; null.asInstanceOf[Void] &#125;)&#125; foreachPartitionAsync1234567891011/** * The asynchronous version of the `foreachPartition` action, which * applies a function f to each partition of this RDD. * “foreachPartition”操作的异步版本， * 它将函数f应用于该RDD的每个分区。 */def foreachPartitionAsync(f: VoidFunction[JIterator[T]]): JavaFutureAction[Void] = &#123;new JavaFutureActionWrapper[Unit, Void](rdd.foreachPartitionAsync(x =&gt; f.call(x.asJava)),&#123; x =&gt; null.asInstanceOf[Void] &#125;)&#125;&#125;","raw":null,"content":null,"categories":[{"name":"spark","slug":"spark","permalink":"https://stanxia.github.io/categories/spark/"}],"tags":[{"name":"spark","slug":"spark","permalink":"https://stanxia.github.io/tags/spark/"},{"name":"源码","slug":"源码","permalink":"https://stanxia.github.io/tags/源码/"}]},{"title":"spark源码注释翻译","slug":"spark源码注释翻译","date":"2017-11-06T16:57:05.000Z","updated":"2019-04-17T06:08:31.950Z","comments":true,"path":"2017/11/06/spark源码注释翻译/","link":"","permalink":"https://stanxia.github.io/2017/11/06/spark源码注释翻译/","excerpt":"版本：spark2.1.1目的：方便中文用户阅读源码，把时间花在理解而不是翻译上\n\n初衷开始立项进行翻译，一方面方便日后阅读源码，另一方面先粗粒度的熟悉下spark框架和组件。优化完之后希望能帮助更多的中文用户，节省翻译时间。","text":"版本：spark2.1.1目的：方便中文用户阅读源码，把时间花在理解而不是翻译上 初衷开始立项进行翻译，一方面方便日后阅读源码，另一方面先粗粒度的熟悉下spark框架和组件。优化完之后希望能帮助更多的中文用户，节省翻译时间。 进度已完成： 正在作：spark core模块 模块名 模块介绍 完成度 api broadcast deploy executor 执行器：用于启动线程池，是真正负责执行task的部件 已完成 input internal io launcher mapred memory metrics network partial rdd rpc scheduler 调度器：spark应用程序的任务调度器 正在作 security serializer shuffle status.api.v1 storage util","raw":null,"content":null,"categories":[{"name":"spark","slug":"spark","permalink":"https://stanxia.github.io/categories/spark/"}],"tags":[{"name":"spark","slug":"spark","permalink":"https://stanxia.github.io/tags/spark/"}]},{"title":"spark关于parquet的优化","slug":"spark关于parquet的优化","date":"2017-11-01T14:53:13.000Z","updated":"2019-04-17T06:08:31.936Z","comments":true,"path":"2017/11/01/spark关于parquet的优化/","link":"","permalink":"https://stanxia.github.io/2017/11/01/spark关于parquet的优化/","excerpt":"parquet是一种列式存储。可以提供面向列的存储和查询。\nParquet的优势在sparkSQL程序中使用parquet格式存储文件，在存储空间和查询性能方面都有很高的效率。\n存储方面因为是面向列的存储，同一列的类型相同，因而在存储的过程中可以使用更高效的压缩方案，可以节省大量的存储空间。\n查询方面在执行查询任务时，只会扫描需要的列，而不是全部，高度灵活性使查询变得非常高效。","text":"parquet是一种列式存储。可以提供面向列的存储和查询。 Parquet的优势在sparkSQL程序中使用parquet格式存储文件，在存储空间和查询性能方面都有很高的效率。 存储方面因为是面向列的存储，同一列的类型相同，因而在存储的过程中可以使用更高效的压缩方案，可以节省大量的存储空间。 查询方面在执行查询任务时，只会扫描需要的列，而不是全部，高度灵活性使查询变得非常高效。 实例测试 测试数据大小 存储类型 存储所占空间 查询性能 1T TEXTFILE 897.9G 698s 1T Parquet 231.4G 21s Parquet的使用使用parquet的简单demo： 12345678910111213141516171819202122// Encoders for most common types are automatically provided by importing spark.implicits._import spark.implicits._val peopleDF = spark.read.json(\"examples/src/main/resources/people.json\")// DataFrames can be saved as Parquet files, maintaining the schema informationpeopleDF.write.parquet(\"people.parquet\")// Read in the parquet file created above// Parquet files are self-describing so the schema is preserved// The result of loading a Parquet file is also a DataFrameval parquetFileDF = spark.read.parquet(\"people.parquet\")// Parquet files can also be used to create a temporary view and then used in SQL statementsparquetFileDF.createOrReplaceTempView(\"parquetFile\")val namesDF = spark.sql(\"SELECT name FROM parquetFile WHERE age BETWEEN 13 AND 19\")namesDF.map(attributes =&gt; \"Name: \" + attributes(0)).show()// +------------+// | value|// +------------+// |Name: Justin|// +------------+ Parquet 的问题 spark 写入数据到 hive 中，使用 Parquet 存储格式，查询该表时报错如下： 1Error: java.io.IOException: org.apache.parquet.io.ParquetDecodingException: Can not read value at 0 in block -1 in file 当时设置的字段属性为： 经过比对，发现是 decimal 类型出了问题，查询 decimal 的字段时候就会报错，而查询其他的并不会报错。（这应该是 spark 引起的，因为在 hive 客户端执行 decimal 类型的操作时并不会出错。） 查阅网上，也有些朋友遇到了类似的事情，应该是官方的 bug ，暂时的解决办法是: 121. 将 Parquet 的存储格式转换为 ORC 2. 或将 decimal 换为 double 类型存储字段","raw":null,"content":null,"categories":[{"name":"spark","slug":"spark","permalink":"https://stanxia.github.io/categories/spark/"}],"tags":[{"name":"spark","slug":"spark","permalink":"https://stanxia.github.io/tags/spark/"},{"name":"parquet","slug":"parquet","permalink":"https://stanxia.github.io/tags/parquet/"}]},{"title":"三步走战略","slug":"三步走战略","date":"2017-11-01T10:45:09.000Z","updated":"2019-04-17T06:08:31.950Z","comments":true,"path":"2017/11/01/三步走战略/","link":"","permalink":"https://stanxia.github.io/2017/11/01/三步走战略/","excerpt":"设定中长期规划稳扎稳打，逐个击破，实现技术上的重大突破","text":"设定中长期规划稳扎稳打，逐个击破，实现技术上的重大突破 第一步深刻了解spark运行机制第二步深度剖析sparkSQL和sparkStreaming第三步实现对spark机器学习的深度掌握","raw":null,"content":null,"categories":[{"name":"规划","slug":"规划","permalink":"https://stanxia.github.io/categories/规划/"}],"tags":[{"name":"规划","slug":"规划","permalink":"https://stanxia.github.io/tags/规划/"}]},{"title":"手把手搭建vps和shadowsocks","slug":"手把手搭建vps和shadowsocks","date":"2017-10-31T00:16:22.000Z","updated":"2019-04-17T06:08:31.950Z","comments":true,"path":"2017/10/31/手把手搭建vps和shadowsocks/","link":"","permalink":"https://stanxia.github.io/2017/10/31/手把手搭建vps和shadowsocks/","excerpt":"记性不好，做个记录，日后有需要时难得费神。\n名词解释了解一些原理，熟悉一些名词，也方便理解接下来安装过程中的操作。\nvpsVPS(Virtual private server) 译作虚拟专用伺服器。你可以把它简单地理解为一台在远端的强劲电脑。当你租用了它以后，可以给它安装操作系统、软件，并通过一些工具连接和远程操控它。\nvultrVultr 是一家 VPS 服务器提供商，有美国、亚洲、欧洲等多地的 VPS。它家的服务器以性价比高闻名，按时间计费，最低的资费为每月 $2.5。\nlinuxLinux 是免费开源的操作系统，大概被世界上过半服务器所采用。有大量优秀的开源软件可以安装，上述 Shadowsocks 就是其一。你可以通过命令行来直接给 Linux 操作系统「下命令」，比如 $ cd ~/Desktop 就是进入你根目录下的 Desktop 文件夹。\nssh SSH 是一种网络协议，作为每一台 Linux 电脑的标准配置，用于计算机之间的加密登录。当你为租用的 VPS 安装 Linux 系统后，只要借助一些工具，就可以用 SSH 在你自己的 Mac/PC 电脑上远程登录该 VPS 了。\nshadowsocksShadowsocks(ss) 是由 Clowwindy 开发的一款软件，其作用本来是加密传输资料。当然，也正因为它加密传输资料的特性，使得 GFW 没法将由它传输的资料和其他普通资料区分开来，也就不能干扰我们访问那些「不存在」的网站了。","text":"记性不好，做个记录，日后有需要时难得费神。 名词解释了解一些原理，熟悉一些名词，也方便理解接下来安装过程中的操作。 vpsVPS(Virtual private server) 译作虚拟专用伺服器。你可以把它简单地理解为一台在远端的强劲电脑。当你租用了它以后，可以给它安装操作系统、软件，并通过一些工具连接和远程操控它。 vultrVultr 是一家 VPS 服务器提供商，有美国、亚洲、欧洲等多地的 VPS。它家的服务器以性价比高闻名，按时间计费，最低的资费为每月 $2.5。 linuxLinux 是免费开源的操作系统，大概被世界上过半服务器所采用。有大量优秀的开源软件可以安装，上述 Shadowsocks 就是其一。你可以通过命令行来直接给 Linux 操作系统「下命令」，比如 $ cd ~/Desktop 就是进入你根目录下的 Desktop 文件夹。 ssh SSH 是一种网络协议，作为每一台 Linux 电脑的标准配置，用于计算机之间的加密登录。当你为租用的 VPS 安装 Linux 系统后，只要借助一些工具，就可以用 SSH 在你自己的 Mac/PC 电脑上远程登录该 VPS 了。 shadowsocksShadowsocks(ss) 是由 Clowwindy 开发的一款软件，其作用本来是加密传输资料。当然，也正因为它加密传输资料的特性，使得 GFW 没法将由它传输的资料和其他普通资料区分开来，也就不能干扰我们访问那些「不存在」的网站了。 搭建vps目的就是搭建梯子。无建站的需求。推荐vultr，最便宜的有2.5美元一个月。500g流量完全够用了。且现在支持支付宝付款，颇为方便。现阶段的优惠活动是新注册的用户完成指定的任务会获得3美元的奖励。（详细情况可依参见官网。） 注册首先点击右侧注册链接：https://www.vultr.com/2017Promo，然后会来到下图所示的注册页面。 第一个框中填写注册邮箱，第二个框中填写注册密码（至少包含1个小写字母、1个大写字母和1个数字），最后点击Create Account创建账户。 创建账户后注册邮箱会收到一封验证邮件，我们需要点击Verify Your E-mail来验证邮箱。 如果注册邮箱收不到验证邮件请更换注册邮箱后重复第一步。 验证邮箱后我们会来到下图所示的登录界面，按下图中指示填写信息，然后点击Login登录。 登陆后我们会来到充值界面。Vultr要求新账户充值后才可以正常创建服务器。Vultr已经支持支付宝了，在这里推荐大家使用支付宝充值，最低金额为10美元。 购买充值完毕后点击右上角的蓝色加号按钮进入创建服务器界面。 首先需要选择Server Location即机房位置，从左到右、从上到下依次为东京、新加坡、伦敦、法兰克福、巴黎、阿姆斯特丹、迈阿密、亚特兰大、芝加哥、硅谷、达拉斯、洛杉矶、纽约、西雅图、悉尼。 然后需要选择Server Type即服务类型，这里大家需要选择安装Debian 7 x64系统，因为这个系统折腾起来比较容易，搭建东西也简单便捷。 然后需要选择Server Size即方案类型，这里大家可以按照需要自行选择，如果只是普通使用那么选择第二个5美元方案即可。 然后Additional Features、Startup Script、SSH Keys以及Server Hostname &amp; Label等四部分大家保持默认即可，最后点击右下方的蓝色Deploy Now按钮确认创建服务器。 创建服务器后我们会看到下图所示界面。 上图中我们需要耐心等待3~4分钟，等红色Installing字变为绿色Running字后，点击Cloud Instance即可进入服务器详细信息界面，如下图所示。 左侧红框内四行信息依次为机房位置、IP地址、登录用户名、登录密码。IP地址后面的按钮为复制IP地址，登录密码后面的按钮为复制密码及显示/隐藏密码。右上角红框内后面四个按钮分别是关闭服务器、重启服务器、重装系统、删除服务器。 远程登录安装远程登录软件。这里以windos端的xshell为例。使用mac的同学可以下载iTerm。 下载安装后打开软件。根据下图中的指示，我们点击会话框中的新建按钮。 点击新建按钮后会弹出下图所示界面。根据图中指示，我们首先填写IP地址，然后点击确定按钮。 点击确定按钮后我们会回到下图所示界面。根据图中指示，我们双击打开新建会话或者点击下方连接按钮打开新建会话。 开新建会话后会弹出下图所示界面。根据图中指示，我们点击接受并保存按钮。 点击接受并保存按钮会弹出下图所示界面。根据图中指示，我们首先填写SSH连接密码，然后打钩记住密码，最后点击确定按钮。 如果提示需要输入用户名（登录名），那么请输入root！ 点击确定按钮后服务器会自动连接，连接完毕后我们会来到下图所示界面 部署shadowsocks这里采用网上整理的一键部署的方案。简单方便操作。 首先复制以下内容： 1wget -N --no-check-certificate https://0123.cool/download/55r.sh &amp;&amp; chmod +x 55r.sh &amp;&amp; ./55r.sh 然后回到Xshell软件，右击选择粘贴，粘贴完毕后回车继续。 回车后系统会自行下载脚本文件并运行。根据下图图中指示，我们依次输入SSR的各项连接信息，最后回车继续。 安装完成后会出现下图所示界面。根据图中指示，我们将红框圈中的信息保存到记事本内。 配置锐意加速根据下图图中指示，我们继续复制下列信息： 1wget -N --no-check-certificate https://0123.cool/download/rs.sh &amp;&amp; bash rs.sh install 然后回到Xshell软件，右击选择粘贴，粘贴完毕后回车继续。 回车后系统会自行下载脚本文件并运行。根据下图图中指示，我们依次输入锐速的各项配置信息，最后回车继续。 回车后，系统自动执行命令完成破解版锐速安装，如下图所示。 我们首先输入： 1reboot 然后回车，Xshell会断开连接，系统会在1分钟后重启完毕，此时可以关闭Xshell软件了。 搭建教程到此结束，亲测成功。如果不能连接的，请检查自己的每一步操作。","raw":null,"content":null,"categories":[{"name":"vps","slug":"vps","permalink":"https://stanxia.github.io/categories/vps/"}],"tags":[{"name":"vps","slug":"vps","permalink":"https://stanxia.github.io/tags/vps/"}]},{"title":"spark报错集","slug":"spark报错集","date":"2017-10-30T13:58:58.000Z","updated":"2019-04-17T06:08:31.950Z","comments":true,"path":"2017/10/30/spark报错集/","link":"","permalink":"https://stanxia.github.io/2017/10/30/spark报错集/","excerpt":"有话要说针对一个老毛病：有些错误屡犯屡改，屡改屡犯，没有引起根本上的注意，或者没有从源头理解错误发生的底层原理，导致做很多无用功。\n总结历史，并从中吸取教训，减少无用功造成的时间浪费。特此将从目前遇到的spark问题全部记录在这里，搞清楚问题，自信向前。","text":"有话要说针对一个老毛病：有些错误屡犯屡改，屡改屡犯，没有引起根本上的注意，或者没有从源头理解错误发生的底层原理，导致做很多无用功。 总结历史，并从中吸取教训，减少无用功造成的时间浪费。特此将从目前遇到的spark问题全部记录在这里，搞清楚问题，自信向前。 问题汇总问题1：spark-hive classes are not found概述：1Exception in thread &quot;main&quot; java.lang.IllegalArgumentException: Unable to instantiate SparkSession with Hive support because Hive classes are not found. 场景：在本地调试spark程序，连接虚拟机上的集群，尝试执行sparkSQL时，启动任务就报错。 原理：缺少sparkSQL连接hive的必要和依赖jar包，添加相应的依赖包即可。 办法：123456789在项目／模块的pom.xml中添加相关的spark-hive依赖jar包。&lt;!-- https://mvnrepository.com/artifact/org.apache.spark/spark-hive_2.11 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.spark&lt;/groupId&gt; &lt;artifactId&gt;spark-hive_2.11&lt;/artifactId&gt; &lt;version&gt;2.1.1&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt;重新编译项目／模块即可。 问题2：Spark Local 模式写 Hive，user=xialinsheng概述：1Caused by: org.apache.hadoop.security.AccessControlException: Permission denied: user=xialinsheng, access=WRITE, inode=&quot;/user/hive/warehouse/xls002&quot;:hadoop:supergroup:drwxr-xr-x 场景：Spark Local 模式连接集群，对 Hadoop 无操作权限。 原理：Spark 在 Local 模式时，如果在本地机器没有设定 HADOOP_USER_NAME ，程序会使用本地的机器名作为 HADOOP_USER_NAME ，这就导致在 Hadoop 集群中无法识别该用户名，从而没权限操作 Hadoop 。 获取 HADOOP_USER_NAME 的核心源码如下： 1234567if (!isSecurityEnabled() &amp;&amp; (user == null)) &#123; String envUser = System.getenv(HADOOP_USER_NAME); if (envUser == null) &#123; envUser = System.getProperty(HADOOP_USER_NAME); &#125; user = envUser == null ? null : new User(envUser);&#125; 从源码可知，要想解决该问题，只要在本机的环境变量中添加 HADOOP_USER_NAME = Hadoop （对 Hadoop 集群有操作权限的用户，具体视自身情况而定。）参考博客：点我了解更多 解决：因为我的需求只是在测试的时候会使用 Local 模式连接集群上的 Hive 表，因而我的处理方式则是在程序代码中指定 ： 1System.setProperty(\"HADOOP_USER_NAME\",\"Hadoop有权限的用户名\"); 问题3：javax.servlet.FilterRegistration概述：在idea上运行spark程序时，出现以下信息： 1Spark error class &quot;javax.servlet.FilterRegistration&quot;&apos;s signer information does not match signer information of other classes in the same package 如图： 原理：包冲突导致。 解决：按照以下步骤操作： 右键模块项目 Open Module Settings 选择Dependencies 找到 javax.servlet:servlet-api:xx 移动到列表的最末端 Apply，Ok 如下图：","raw":null,"content":null,"categories":[{"name":"spark","slug":"spark","permalink":"https://stanxia.github.io/categories/spark/"}],"tags":[{"name":"spark","slug":"spark","permalink":"https://stanxia.github.io/tags/spark/"},{"name":"报错集","slug":"报错集","permalink":"https://stanxia.github.io/tags/报错集/"}]},{"title":"life","slug":"life","date":"2017-10-29T11:00:42.000Z","updated":"2019-04-17T06:08:31.936Z","comments":true,"path":"2017/10/29/life/","link":"","permalink":"https://stanxia.github.io/2017/10/29/life/","excerpt":"\n\nvar dplayer0 = new DPlayer({\"element\":document.getElementById(\"dplayer0\"),\"autoplay\":0,\"theme\":\"#FADFA3\",\"loop\":1,\"video\":{\"url\":\"http://oliji9s3j.bkt.clouddn.com/Unbroken%20-%20Motivational%20Video.mp4\",\"pic\":\"/images/pic/life.jpeg\"}});\nLife is simple &amp;&amp; funny.","text":"var dplayer0 = new DPlayer({\"element\":document.getElementById(\"dplayer0\"),\"autoplay\":0,\"theme\":\"#FADFA3\",\"loop\":1,\"video\":{\"url\":\"http://oliji9s3j.bkt.clouddn.com/Unbroken%20-%20Motivational%20Video.mp4\",\"pic\":\"/images/pic/life.jpeg\"}}); Life is simple &amp;&amp; funny.","raw":null,"content":null,"categories":[{"name":"movie","slug":"movie","permalink":"https://stanxia.github.io/categories/movie/"}],"tags":[{"name":"movie","slug":"movie","permalink":"https://stanxia.github.io/tags/movie/"}]},{"title":"杂乱无章","slug":"杂乱无章","date":"2017-10-29T01:31:31.000Z","updated":"2019-04-17T06:08:31.950Z","comments":true,"path":"2017/10/29/杂乱无章/","link":"","permalink":"https://stanxia.github.io/2017/10/29/杂乱无章/","excerpt":"时光的机器，加足马力冲回过去\n历史的长河，丝丝涟漪涌向未来","text":"时光的机器，加足马力冲回过去 历史的长河，丝丝涟漪涌向未来 道不清楚，说不明白，夜深人静的时候，说一些想到的废话。窗外隆隆作响，不知疲倦的机器不知疲倦的执行着不知疲倦的动作。窗内屏幕暗淡，双眼干涩，思索着宇宙外的回想。 小时候，望向星空，那时的天空群星闪烁，哪像现在，嘿，享受了大城市的霓虹，哪里再给你无垠的星空，贪。 躺在草地，微风轻拂脸颊，初秋的夜晚，有点微凉。 仰望星河，也想着外面的世界，多精彩。 揣摩着无垠的宇宙，翻过地球，越过银河，驶向无限拓展的星际，身上的烦恼，微风一吹，全散了。 风轻拂，静静望着天空，思考着外面的朋友或许也在渴望着远方的我，伸手触摸这天空，抓一把星辰贪婪的放入梦。 深邃的夜空，望不尽的远方，是光明中的无尽黑暗，也似黑暗道路的一束亮光，洒向我，思绪跟着遨游，呵，世界与我万千美好，我与世界却念念叨叨，琐琐碎碎，麻麻烦烦。心里是想放飞的。 夜深，车水呼啸，诉说着城市的不眠，可我困，关窗，闷。开窗，嘿，不知疲倦的机器又开始不知疲倦的执行不知疲倦的动作。这样的夜晚，眠难。 深夜思考，写作。夜使我宁静，内心的宁静，这白天的大城市给予不了。感谢夜的馈赠，接收这无上的加冕，驰骋在思绪的星空，痛快，精彩，精彩。 杂乱无章，呵，可以。","raw":null,"content":null,"categories":[{"name":"think","slug":"think","permalink":"https://stanxia.github.io/categories/think/"}],"tags":[{"name":"think","slug":"think","permalink":"https://stanxia.github.io/tags/think/"}]},{"title":"闲谈","slug":"闲谈","date":"2017-10-28T11:07:14.000Z","updated":"2019-04-17T06:08:31.950Z","comments":true,"path":"2017/10/28/闲谈/","link":"","permalink":"https://stanxia.github.io/2017/10/28/闲谈/","excerpt":"春回大地","text":"春回大地","raw":null,"content":null,"categories":[{"name":"think","slug":"think","permalink":"https://stanxia.github.io/categories/think/"}],"tags":[{"name":"think","slug":"think","permalink":"https://stanxia.github.io/tags/think/"}]},{"title":"这个杀手不太冷","slug":"这个杀手不太冷","date":"2017-10-28T01:18:04.000Z","updated":"2019-04-17T06:08:31.950Z","comments":true,"path":"2017/10/28/这个杀手不太冷/","link":"","permalink":"https://stanxia.github.io/2017/10/28/这个杀手不太冷/","excerpt":"Is life always this hard,or is it just when you’re a kid?Always like this.\n","text":"Is life always this hard,or is it just when you’re a kid?Always like this.","raw":null,"content":null,"categories":[{"name":"movie","slug":"movie","permalink":"https://stanxia.github.io/categories/movie/"}],"tags":[{"name":"movie","slug":"movie","permalink":"https://stanxia.github.io/tags/movie/"}]},{"title":"mac使用小技巧","slug":"mac使用小技巧","date":"2017-10-28T01:13:44.000Z","updated":"2019-04-17T06:08:31.936Z","comments":true,"path":"2017/10/28/mac使用小技巧/","link":"","permalink":"https://stanxia.github.io/2017/10/28/mac使用小技巧/","excerpt":"前言\n记录mac使用的小技巧和一些问题。不定期更新ing文件损坏的解决办法在安装一些网上下载的应用时，如果报错显示：文件已经损坏，请移至废纸篓。请不要惊慌，其实别不是文件真的损坏了，根本原因是 mac 系统的安全验证机制，默认是不允许某些应用的安装。要想避开该安全认证，其实方法也很简单，如下：\n第一步：打开系统偏好设置中的 安全性与隐私 ，解开锁，选择 任何来源 ，完成。\n第二步：在这里关键是很多朋友没找到这个 任何来源 ，不要着急，咱们接着往来下，打开 终端，输入如下命令：\n12cd ~sudo spctl --master-disable\n成功输入以上命令，再去执行第一步操作，完成，现在可以去开心的安装应用了。","text":"前言 记录mac使用的小技巧和一些问题。不定期更新ing文件损坏的解决办法在安装一些网上下载的应用时，如果报错显示：文件已经损坏，请移至废纸篓。请不要惊慌，其实别不是文件真的损坏了，根本原因是 mac 系统的安全验证机制，默认是不允许某些应用的安装。要想避开该安全认证，其实方法也很简单，如下： 第一步：打开系统偏好设置中的 安全性与隐私 ，解开锁，选择 任何来源 ，完成。 第二步：在这里关键是很多朋友没找到这个 任何来源 ，不要着急，咱们接着往来下，打开 终端，输入如下命令： 12cd ~sudo spctl --master-disable 成功输入以上命令，再去执行第一步操作，完成，现在可以去开心的安装应用了。终端 command not found 问题在初次使用 mac 终端的时候，终端除了能执行 cd 命令，其余的貌似都不得行，会报 command not found 的问题，下面给出解决方案。 原因：出现该问题的原因是没有将这些命令添加进环境变量中，导致系统无法识别。 第一步：先设置临时的环境变量，以使我们能继续进行下面的操作。 1export PATH=/usr/bin:/usr/sbin:/bin:/sbin 第二步：进入到用户的目录，并打开存储环境变量的文件 .bash_profile , vi 是操作文件的利器，如果没有文件会新建文件。 12cd ~vi .bash_profile 第三步：在打开的文件页面，输入 i 执行编辑操作，可看到页面的左下角有个 insert 的字样即可，然后添加环境变量信息： 1export PATH=/usr/bin:/usr/sbin:/bin:/sbin 添加完以上信息之后，按 esc 键退出编辑模式，然后输入 :wq 保存并退出编辑页面。 第四步：使刚才编辑的环境变量文件生效。 source 命令即可。 1source .bash_profile 完成之后则可以重启 终端 ，并执行如 ls 等 Linux 操作，验证是否成功。开启充电提示音（类似于iphone充电提示音，默认关闭）终端输入（开启）： 1defaults write com.apple.PowerChime ChimeOnAllHardware -bool true; open /System/Library/CoreServices/PowerChime.app &amp; 关闭： 1defaults write com.apple.PowerChime ChimeOnAllHardware -bool false;killall PowerChime 隐藏文件夹 更好的保护学习资料，有时候需要设置隐藏文件夹： 1mv foldername .foldername 查看隐藏文件夹 mac最新版本： 1⌘⇧.(Command + Shift + .) #隐藏 和显示 Macbook Pro 用外接显示器时，如何关闭笔记本屏幕，同时开盖使用 12sudo nvram boot-args=\"iog=0x0\" #(10.10以前版本)sudo nvram boot-args=\"niog=1\" #(10.10及以后版本)这个命令的意思就是外接显示器时关闭自身屏幕，重启生效 开机流程：连上电源和外接显示器，按开机键，立即合盖，等外接显示器有信号时开盖即可如果报错 (已知 10.11/10.12 会报错)nvram: Error setting variable - ‘boot-args’: (iokit/common) general error 重启，按住command + r 进入恢复界面 左上角菜单里面找到终端，输入nvram boot-args=”niog=1”，回车问题解决。重启生效","raw":null,"content":null,"categories":[{"name":"mac","slug":"mac","permalink":"https://stanxia.github.io/categories/mac/"}],"tags":[{"name":"mac","slug":"mac","permalink":"https://stanxia.github.io/tags/mac/"}]},{"title":"photo","slug":"photo","date":"1999-10-27T00:54:07.000Z","updated":"2019-04-17T06:08:31.936Z","comments":false,"path":"1999/10/27/photo/","link":"","permalink":"https://stanxia.github.io/1999/10/27/photo/","excerpt":"","text":"","raw":null,"content":null,"categories":[{"name":"photo","slug":"photo","permalink":"https://stanxia.github.io/categories/photo/"}],"tags":[{"name":"photo","slug":"photo","permalink":"https://stanxia.github.io/tags/photo/"}]}]}